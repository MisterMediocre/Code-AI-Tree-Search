{
  "prompt": "\nQUESTION:\nYou have a set of items, each having some integer weight not greater than $8$. You denote that a subset of items is good if total weight of items in the subset does not exceed $W$.\n\nYou want to calculate the maximum possible weight of a good subset of items. Note that you have to consider the empty set and the original set when calculating the answer.\n\n\n-----Input-----\n\nThe first line contains one integer $W$ ($0 \\le W \\le 10^{18}$) \u2014 the maximum total weight of a good subset.\n\nThe second line denotes the set of items you have. It contains $8$ integers $cnt_1$, $cnt_2$, ..., $cnt_8$ ($0 \\le cnt_i \\le 10^{16}$), where $cnt_i$ is the number of items having weight $i$ in the set.\n\n\n-----Output-----\n\nPrint one integer \u2014 the maximum possible weight of a good subset of items.\n\n\n-----Examples-----\nInput\n10\n1 2 3 4 5 6 7 8\n\nOutput\n10\n\nInput\n0\n0 0 0 0 0 0 0 0\n\nOutput\n0\n\nInput\n3\n0 4 1 0 0 9 8 3\n\nOutput\n3\n\nTUTORIAL:\n1132E - Knapsack\n\nLet's consider the optimal answer. Suppose we take c\u1d62 items of weight i.\n\nLet L be the least common multiple of all weights (that is 840). Then we may represent c\u1d62 as c\u1d62 = \u230aL / i\u230b\u00b7p\u1d62 + q\u1d62, where 0 \u2264 q < \u230aL / i\u230b. Let\u2019s do the following trick: we will take q\u1d62 items of weight i, and all the remaining items of this weight can be merged into some items of weight L.\n\nThen we can write a brute force solution that picks less than \u230aL / i\u230b items of each weight, transforms the remaining ones into items of weight L as much as possible, and when we fix the whole subset, adds maximum possible number of items of weight L to the answer.\n\nThis works in something like \u220f\u208d\u1d62\u208c\u2081 \u209c\u2092 \u2088\u208e \u230aL / i\u230b = L\u2078 / 8! operations, which is too much.\n\nHow can we speed it up? Rewrite it using dynamic programming! When we have fixed the number of items we take from x first sets, the only two things that matter now are the current total weight of taken items and the number of items of weight L we can use; and it\u2019s obvious that the more items of weight L we can use, the better. So let\u2019s write the following dynamic programming solution: dp[x][y] \u2014 maximum number of items of weight L we can have, if we processed first x types of items, and current total weight is y. Note that the second dimension should have size 8L.\n\n\nInstructions:\n\n\nYou are a Python3 code generator.  Output **only** valid Python code. No explanations, no commentary, no filenames, no Markdown formatting. You will spit out a code block that can be pasted into any script. It must read the input, execute the logic and then print the output. Ensure that you invoke the main() or solve() function at the end if you're writing your code inside them.\nANSWER:\n",
  "codes": [
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    W = int(data[0])\n    cnt = [int(x) for x in data[1:]]\n    dp = [[0] * (8 * W + 1) for _ in range(9)]\n    for i in range(1, 9):\n        for j in range(8 * W + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= i * cnt[i - 1]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - i * cnt[i - 1]] + i * cnt[i - 1])\n    print(dp[8][8 * W])\n\nif True:\n    solve()"
  ],
  "rewards": [
    0.0
  ],
  "train rewards": [
    0.18181818181818182
  ],
  "time": 5.248480796813965,
  "sample times": 5
}