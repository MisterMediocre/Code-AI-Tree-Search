{
  "prompt": "\nQUESTION:\nYou are at a water bowling training. There are l people who play with their left hand, r people, who play with their right hand, and a ambidexters, who can play with left or right hand.\n\nThe coach decided to form a team of even number of players, exactly half of the players should play with their right hand, and exactly half of the players should play with their left hand. One player should use only on of his hands.\n\nAmbidexters play as well with their right hand as with their left hand. In the team, an ambidexter can play with their left hand, or with their right hand.\n\nPlease find the maximum possible size of the team, where equal number of players use their left and right hands, respectively.\n\n\n-----Input-----\n\nThe only line contains three integers l, r and a (0 \u2264 l, r, a \u2264 100) \u2014 the number of left-handers, the number of right-handers and the number of ambidexters at the training. \n\n\n-----Output-----\n\nPrint a single even integer\u00a0\u2014 the maximum number of players in the team. It is possible that the team can only have zero number of players.\n\n\n-----Examples-----\nInput\n1 4 2\n\nOutput\n6\n\nInput\n5 5 5\n\nOutput\n14\n\nInput\n0 2 0\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example you can form a team of 6 players. You should take the only left-hander and two ambidexters to play with left hand, and three right-handers to play with right hand. The only person left can't be taken into the team.\n\nIn the second example you can form a team of 14 people. You have to take all five left-handers, all five right-handers, two ambidexters to play with left hand and two ambidexters to play with right hand.\n\nTUTORIAL:\nHint: Dynamic programming problem. To handle repetitions we have to construct the number from right to the left and calculate the answer when we reach a number equivalent to 0 modulo k.\n\nSolution: Let's define count(i, j) as a recursive function that calculates the number of numbers consisting of n digits satisfying the conditions of the problem and with a specific suffix of length i, S\u1d62 such that S\u1d62 \u2261 j (mod k).\n\nWe want to avoid repetition so by constructing the number from the right to the left when we reach a state with j = 0 with suffix \u2260 0 we return the answer immediately so any other suffix that contains this suffix won\u2019t be calculated.\n\nSo the base cases are count(n, 0) = 1, count(i, 0) = 9 * 10\u207f\u207b\u2071\u207b\u00b9 : i < n.\n\nSo state transitions will be  \ncount(i, j) = \u2211\u208d\u2093\u208c\u2080 \u209c\u2092 \u2089\u208e count(i + 1, (j + (x * 10\u2071)) % k)  \n(We add a digit to the left).\n\nAnd we can handle j = 0 case coming from a zero suffix easily with a boolean variable we set to true when we use a digit \u2260 0 in constructing the number.\n\nTime complexity: O(n * k)\n\n\nInstructions:\n\n\nYou are a Python3 code generator.  Output **only** valid Python code. No explanations, no commentary, no filenames, no Markdown formatting. You will spit out a code block that can be pasted into any script. It must read the input, execute the logic and then print the output. Ensure that you invoke the main() or solve() function at the end if you're writing your code inside them.\nANSWER:\n",
  "codes": [
    "def solve(l, r, a):\n    MOD = 10**9 + 7\n    dp = [[0] * (MOD + 1) for _ in range(l + r + a + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, l + r + a + 1):\n        for j in range(MOD + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][0]\n            else:\n                for x in range(10):\n                    dp[i][j] = (dp[i][j] + dp[i - 1][(j + (x * 10**(i - 1))) % MOD]) % MOD\n    \n    return dp[l + r + a][0]\n\nif True:\n    l, r, a = map(int, input().split())\n    print(solve(l, r, a))"
  ],
  "rewards": [
    0.0
  ],
  "train rewards": [
    0.0
  ],
  "time": 11.125797271728516,
  "sample times": 5
}