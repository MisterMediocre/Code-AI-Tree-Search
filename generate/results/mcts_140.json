{
  "prompt": "\nQUESTION:\nThe mayor of the Central Town wants to modernize Central Street, represented in this problem by the $(Ox)$ axis.\n\nOn this street, there are $n$ antennas, numbered from $1$ to $n$. The $i$-th antenna lies on the position $x_i$ and has an initial scope of $s_i$: it covers all integer positions inside the interval $[x_i - s_i; x_i + s_i]$.\n\nIt is possible to increment the scope of any antenna by $1$, this operation costs $1$ coin. We can do this operation as much as we want (multiple times on the same antenna if we want).\n\nTo modernize the street, we need to make all integer positions from $1$ to $m$ inclusive covered by at least one antenna. Note that it is authorized to cover positions outside $[1; m]$, even if it's not required.\n\nWhat is the minimum amount of coins needed to achieve this modernization?\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\le 80$ and $n \\le m \\le 100\\ 000$).\n\nThe $i$-th of the next $n$ lines contains two integers $x_i$ and $s_i$ ($1 \\le x_i \\le m$ and $0 \\le s_i \\le m$).\n\nOn each position, there is at most one antenna (values $x_i$ are pairwise distinct).\n\n\n-----Output-----\n\nYou have to output a single integer: the minimum amount of coins required to make all integer positions from $1$ to $m$ inclusive covered by at least one antenna.\n\n\n-----Examples-----\nInput\n3 595\n43 2\n300 4\n554 10\n\nOutput\n281\n\nInput\n1 1\n1 1\n\nOutput\n0\n\nInput\n2 50\n20 0\n3 1\n\nOutput\n30\n\nInput\n5 240\n13 0\n50 25\n60 5\n155 70\n165 70\n\nOutput\n26\n\n\n\n-----Note-----\n\nIn the first example, here is a possible strategy:\n\n  Increase the scope of the first antenna by $40$, so that it becomes $2 + 40 = 42$. This antenna will cover interval $[43 - 42; 43 + 42]$ which is $[1; 85]$  Increase the scope of the second antenna by $210$, so that it becomes $4 + 210 = 214$. This antenna will cover interval $[300 - 214; 300 + 214]$, which is $[86; 514]$  Increase the scope of the third antenna by $31$, so that it becomes $10 + 31 = 41$. This antenna will cover interval $[554 - 41; 554 + 41]$, which is $[513; 595]$ \n\nTotal cost is $40 + 210 + 31 = 281$. We can prove that it's the minimum cost required to make all positions from $1$ to $595$ covered by at least one antenna.\n\nNote that positions $513$ and $514$ are in this solution covered by two different antennas, but it's not important.\n\n\u2014\n\nIn the second example, the first antenna already covers an interval $[0; 2]$ so we have nothing to do.\n\nNote that the only position that we needed to cover was position $1$; positions $0$ and $2$ are covered, but it's not important.\n\nInstructions:\n\n\nYou are a Python3 code generator.  Output **only** valid Python code. No explanations, no commentary, no filenames, no Markdown formatting. You will spit out a code block that can be pasted into any script. It must read the input, execute the logic and then print the output. Ensure that you invoke the main() or solve() function at the end if you're writing your code inside them.\nANSWER:\n",
  "codes": [
    "def solve(n, m):\n    # Initialize the list of scopes for each antenna\n    scopes = [0] * n\n    \n    # Iterate over each antenna\n    for i in range(n):\n        # Update the scope of the current antenna\n        scopes[i] = max(0, min(m, scopes[i] + s[i]))\n    \n    # Calculate the total number of coins needed\n    total_coins = sum(scopes)\n    \n    return total_coins\n\n# Read input\nn, m = map(int, input().split())\nantennas = []\nfor _ in range(n):\n    x, s = map(int, input().split())\n    antennas.append((x, s))\n\n# Solve the problem\nresult = solve(n, m)\n\n# Print the result\nprint(result)",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [data[i:i+2] for i in range(2, 2*n, 2)]\n    \n    def can_cover(position):\n        return any(x <= position <= y for x, y in antennas)\n    \n    min_coins = 0\n    for i in range(1, m+1):\n        if not can_cover(i):\n            min_coins += 1\n    \n    print(min_coins)\n\nif True:\n    solve()",
    "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, sys.stdin.readline().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by their starting point\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    # Iterate through each antenna\n    for x, s in antennas:\n        # Calculate the new scope after adding the antenna's scope\n        new_scope = max(current_scope + s, x)\n        \n        # If the new scope exceeds the current range, add the difference to the total cost\n        if new_scope > m:\n            total_cost += new_scope - m\n        \n        # Update the current scope\n        current_scope = new_scope\n    \n    return total_cost\n\nif True:\n    solve()",
    "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [data[i:i+2] for i in range(2, 2*n, 2)]\n    \n    def can_cover(position):\n        return any(x <= position <= y for x, y in antennas)\n    \n    min_coins = 0\n    for i in range(1, m+1):\n        if not can_cover(i):\n            min_coins += 1\n    \n    print(min_coins)\n\nif True:\n    main()",
    "def solve(n, m, antennas):\n    # Sort antennas by their starting point\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    # Iterate through each antenna\n    for i in range(n):\n        # Calculate the new scope after increasing the current antenna's scope\n        new_scope = max(current_scope + antennas[i][1], antennas[i][0] + antennas[i][1])\n        \n        # Update the total cost\n        total_cost += new_scope - current_scope\n        \n        # Update the current scope\n        current_scope = new_scope\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(solve(n, m, antennas))",
    "from typing import List\n\ndef solve(n: int, m: int, antennas: List[List[int]]) -> int:\n    # Sort antennas by their starting point\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    # Iterate through each antenna\n    for i in range(n):\n        # Calculate the new scope after increasing the current antenna's scope\n        new_scope = max(current_scope + antennas[i][1], antennas[i][0] + antennas[i][1])\n        \n        # Update the total cost\n        total_cost += new_scope - current_scope\n        \n        # Update the current scope\n        current_scope = new_scope\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(solve(n, m, antennas))",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by their starting point\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    # Iterate through each antenna\n    for x, s in antennas:\n        # Calculate the new scope after adding the antenna's scope\n        new_scope = max(current_scope + s, x)\n        \n        # If the new scope exceeds the current maximum, update the maximum and add the cost\n        if new_scope > current_scope:\n            current_scope = new_scope\n            total_cost += new_scope - current_scope\n    \n    # Print the total cost\n    print(total_cost)\n\n# Call the solve function\nsolve()",
    "def solve(n, m):\n    positions = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        positions.append((x, s))\n    \n    positions.sort()\n    \n    total_cost = 0\n    \n    current_scope = 0\n    current_position = 0\n    \n    while current_position < m:\n        if current_position + current_scope >= m:\n            break\n        \n        for i in range(len(positions)):\n            if positions[i][0] <= current_position + current_scope <= positions[i][0] + positions[i][1]:\n                current_scope += 1\n                break\n        \n        total_cost += 1\n    \n    return total_cost\n\nif True:\n    n, m = map(int, input().split())\n    print(solve(n, m))",
    "def solve(n, m, x, s):\n    # Sort antennas based on their starting positions\n    antennas = sorted(zip(x, s), key=lambda pair: pair[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    # Iterate through each antenna\n    for i in range(n):\n        # Calculate the new scope after increasing the current antenna's scope\n        new_scope = max(current_scope + antennas[i][1], antennas[i][0] + antennas[i][1])\n        \n        # Update the total cost\n        total_cost += new_scope - current_scope\n        \n        # Update the current scope\n        current_scope = new_scope\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nx = list(map(int, input().split()))\ns = list(map(int, input().split()))\n\n# Solve the problem\nprint(solve(n, m, x, s))",
    "def solve(n, m):\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by their starting point\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    # Iterate through each antenna\n    for x, s in antennas:\n        # Calculate the new scope after adding the antenna's scope\n        new_scope = max(current_scope + s, x)\n        \n        # If the new scope exceeds the current maximum, update the maximum and add the cost\n        if new_scope > current_scope:\n            current_scope = new_scope\n            total_cost += new_scope - current_scope\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\n\n# Solve the problem\nprint(solve(n, m))",
    "import sys\nfrom typing import List\n\ndef solve(n: int, m: int, antennas: List[List[int]]) -> int:\n    # Sort antennas by their starting point\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    # Iterate through each antenna\n    for i in range(n):\n        # Calculate the new scope after increasing the current antenna's scope\n        new_scope = max(current_scope + antennas[i][1], antennas[i][0] + antennas[i][1])\n        \n        # Update the total cost\n        total_cost += new_scope - current_scope\n        \n        # Update the current scope\n        current_scope = new_scope\n    \n    return total_cost\n\n# Read input\ninput_data = sys.stdin.read().split()\nn = int(input_data[0])\nm = int(input_data[1])\nantennas = []\nfor _ in range(n):\n    x, s = map(int, input_data[2:])\n    antennas.append([x, s])\n\n# Solve the problem\nresult = solve(n, m, antennas)\nprint(result)",
    "def solve(n, m):\n    # Sort antennas based on their starting positions\n    antennas = sorted([(x, s) for x, s in zip(range(1, m+1), [int(input()) for _ in range(n)])])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    # Iterate through each antenna\n    for x, s in antennas:\n        # Calculate the new scope after increasing it by 1\n        new_scope = max(current_scope + 1, x + s)\n        \n        # If the new scope is greater than the current scope, update the total cost\n        if new_scope > current_scope:\n            total_cost += new_scope - current_scope\n        \n        # Update the current scope\n        current_scope = new_scope\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(solve(n, m))",
    "def min_coins(n, m, antennas):\n    # Sort antennas based on their starting positions\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    # Iterate through each antenna\n    for i in range(n):\n        # Calculate the new scope after increasing the current antenna's scope\n        new_scope = max(current_scope + antennas[i][1], antennas[i][0] + antennas[i][1])\n        \n        # Update the total cost with the difference between the new and old scopes\n        total_cost += new_scope - current_scope\n        \n        # Update the current scope\n        current_scope = new_scope\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(min_coins(n, m, antennas))",
    "def solve(n, m, antennas):\n    covered_positions = set()\n    for x, s in antennas:\n        for i in range(x - s, x + s + 1):\n            covered_positions.add(i)\n    \n    uncovered_positions = set(range(1, m + 1)) - covered_positions\n    \n    return len(uncovered_positions)\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nresult = solve(n, m, antennas)\n\n# Print the result\nprint(result)",
    "def solve(n, m, antennas):\n    positions = set(range(1, m+1))\n    for x, s in antennas:\n        positions -= set(range(x-s, x+s+1))\n    return len(positions)\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve and print output\nprint(solve(n, m, antennas))",
    "def solve(n, m, antennas):\n    # Initialize a set to keep track of covered positions\n    covered_positions = set()\n    \n    # Iterate through each antenna\n    for i in range(n):\n        x, s = antennas[i]\n        \n        # Add the entire interval [x-s, x+s] to the covered positions set\n        for j in range(x - s, x + s + 1):\n            covered_positions.add(j)\n    \n    # Calculate the number of uncovered positions\n    uncovered_positions_count = m - len(covered_positions)\n    \n    # Return the minimum number of coins needed\n    return uncovered_positions_count\n\n# Read input\nn, m = map(int, input().split())\nantennas = []\nfor _ in range(n):\n    x, s = map(int, input().split())\n    antennas.append((x, s))\n\n# Solve the problem\nresult = solve(n, m, antennas)\n\n# Print the result\nprint(result)",
    "def solve(n, m, x_s):\n    # Sort antennas based on their starting positions\n    x_s.sort()\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    # Iterate through each antenna\n    for i in range(n):\n        # Calculate the new scope after increasing it by 1\n        new_scope = current_scope + 1\n        \n        # Check if the new scope covers the current position\n        if x_s[i][0] <= new_scope <= x_s[i][1]:\n            continue\n        \n        # Calculate the number of coins needed to increase the scope\n        coins_needed = max(0, new_scope - x_s[i][0])\n        \n        # Update the total cost and current scope\n        total_cost += coins_needed\n        current_scope = new_scope\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nx_s = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(solve(n, m, x_s))",
    "def solve(n, m):\n    # Create a list to store the scopes of each antenna\n    scopes = [0] * n\n    \n    # Iterate over each antenna\n    for i in range(n):\n        # Update the scope of the current antenna\n        scopes[i] = max(scopes[i], abs(x_i - s_i))\n    \n    # Calculate the total number of coins needed\n    total_coins = sum(scopes)\n    \n    return total_coins\n\n# Read input\nn, m = map(int, input().split())\nantennas = []\nfor _ in range(n):\n    x_i, s_i = map(int, input().split())\n    antennas.append((x_i, s_i))\n\n# Solve the problem\ntotal_coins = solve(n, m)\n\n# Print the output\nprint(total_coins)",
    "def main():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by their starting point\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    # Iterate through each antenna\n    for x, s in antennas:\n        # Calculate the new scope after adding the antenna's scope\n        new_scope = max(current_scope + s, x)\n        \n        # If the new scope exceeds the current maximum, update the total cost\n        if new_scope > current_scope:\n            total_cost += new_scope - current_scope\n        \n        # Update the current scope\n        current_scope = new_scope\n    \n    # Print the minimum cost\n    print(total_cost)\n\nif True:\n    main()",
    "def solve(n, m, antennas):\n    # Create a set to store the positions covered by each antenna\n    covered_positions = set()\n    \n    # Iterate over each antenna\n    for i in range(n):\n        x, s = antennas[i]\n        \n        # Add the positions covered by the current antenna to the set\n        for j in range(max(1, x - s), min(m + 1, x + s) + 1):\n            covered_positions.add(j)\n    \n    # Calculate the number of uncovered positions\n    uncovered_positions_count = m - len(covered_positions)\n    \n    # Return the minimum number of coins needed to cover all uncovered positions\n    return uncovered_positions_count\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(solve(n, m, antennas))",
    "def solve(n, m, antennas):\n    positions_covered = set()\n    for x, s in antennas:\n        for i in range(x - s, x + s + 1):\n            positions_covered.add(i)\n    \n    return len(positions_covered) >= m\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = data[2:]\n    print(solve(n, m, antennas))\n\nif True:\n    main()",
    "def solve(n, m):\n    positions = sorted([int(input().split()[0]) for _ in range(n)])\n    scopes = [int(input().split()[1]) for _ in range(n)]\n    \n    total_cost = 0\n    \n    for i in range(m):\n        found = False\n        for j in range(n):\n            if positions[j] <= i <= positions[j] + scopes[j]:\n                found = True\n                break\n        \n        if not found:\n            total_cost += 1\n    \n    return total_cost\n\nif True:\n    n, m = map(int, input().split())\n    print(solve(n, m))",
    "def solve(n, m):\n    # Initialize a list to store the current scope of each antenna\n    scopes = [0] * n\n    \n    # Iterate over each antenna\n    for i in range(n):\n        # Update the scope of the current antenna\n        scopes[i] = max(scopes[i], abs(x_i - s_i))\n    \n    # Calculate the total number of coins needed\n    total_coins = sum(scopes)\n    \n    return total_coins\n\n# Read input\nn, m = map(int, input().split())\nantennas = []\nfor _ in range(n):\n    x_i, s_i = map(int, input().split())\n    antennas.append((x_i, s_i))\n\n# Solve the problem\nresult = solve(n, m)\n\n# Print the result\nprint(result)",
    "def solve(n, m, antennas):\n    covered = set()\n    for x, s in antennas:\n        for i in range(x - s, x + s + 1):\n            covered.add(i)\n    \n    return len(covered) >= m\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = data[2:]\n    print(solve(n, m, antennas))\n\nif True:\n    main()",
    "def solve(n, m):\n    antennas = sorted([(x, s) for x, s in zip(map(int, input().split()), map(int, input().split()))])\n    covered_positions = set()\n    \n    for x, s in antennas:\n        start = max(1, x - s)\n        end = min(m, x + s)\n        covered_positions.update(range(start, end + 1))\n    \n    return len(covered_positions)\n\nif True:\n    n, m = map(int, input().split())\n    print(solve(n, m))",
    "def solve(n, m, antennas):\n    # Sort the antennas based on their starting positions\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    # Iterate through each antenna\n    for i in range(n):\n        # Calculate the new scope after increasing the current antenna's scope\n        new_scope = max(current_scope + antennas[i][1], antennas[i][0] + antennas[i][1])\n        \n        # Update the total cost\n        total_cost += new_scope - current_scope\n        \n        # Update the current scope\n        current_scope = new_scope\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(solve(n, m, antennas))",
    "def solve(n, m, antennas):\n    # Initialize the coverage set with all positions from 1 to m\n    coverage_set = set(range(1, m + 1))\n    \n    # Iterate through each antenna\n    for i in range(n):\n        x, s = antennas[i]\n        \n        # Update the coverage set by removing positions within the current antenna's scope\n        coverage_set -= set(range(x - s, x + s + 1))\n    \n    # Calculate the number of uncovered positions\n    uncovered_positions = len(coverage_set)\n    \n    # If all positions are covered, return 0\n    if uncovered_positions == 0:\n        return 0\n    \n    # Otherwise, calculate the minimum number of coins needed\n    min_coins = uncovered_positions\n    \n    # Return the minimum number of coins\n    return min_coins\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nresult = solve(n, m, antennas)\n\n# Print the result\nprint(result)",
    "def solve(n, m):\n    positions = [int(input()) for _ in range(n)]\n    scopes = [int(input()) for _ in range(n)]\n\n    # Sort positions and scopes\n    sorted_positions = sorted(positions)\n    sorted_scopes = sorted(scopes)\n\n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    current_position = 0\n\n    # Iterate through positions\n    while current_position < m:\n        # Check if current position is within current scope\n        if current_position >= sorted_positions[current_scope]:\n            # Update current scope\n            current_scope += 1\n            # Increment total cost\n            total_cost += 1\n        else:\n            # Move to the next position\n            current_position += 1\n\n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nprint(solve(n, m))",
    "def solve(n, m):\n    # Sort the antennas based on their starting positions\n    antennas = sorted([(x, s) for x, s in zip(range(1, m+1), [int(input()) for _ in range(n)])])\n    \n    # Initialize the total cost\n    total_cost = 0\n    \n    # Iterate through each antenna\n    for i in range(n):\n        # Calculate the number of positions covered by the current antenna\n        covered_positions = max(0, min(m, x + s) - max(0, x - s))\n        \n        # If the current antenna does not cover enough positions, calculate the additional cost\n        if covered_positions < m:\n            additional_cost = m - covered_positions\n            total_cost += additional_cost\n        \n        # Update the starting position of the next antenna\n        x = antennas[i][0]\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(solve(n, m))",
    "def solve(n, m, antennas):\n    # Sort antennas based on their starting positions\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    # Iterate through each antenna\n    for i in range(n):\n        # Calculate the new scope after increasing the current antenna's scope\n        new_scope = max(current_scope + antennas[i][1], antennas[i][0] + antennas[i][1])\n        \n        # Update the total cost\n        total_cost += new_scope - current_scope\n        \n        # Update the current scope\n        current_scope = new_scope\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(solve(n, m, antennas))",
    "def solve(n, m, antennas):\n    covered_positions = set()\n    \n    for x, s in antennas:\n        for i in range(x - s, x + s + 1):\n            covered_positions.add(i)\n    \n    return len(covered_positions) >= m\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = data[2:]\n    \n    if solve(n, m, antennas):\n        print(0)\n    else:\n        print(sum([abs(x - y) for x, y in zip(sorted(antennas), sorted(antennas)[::-1])]))\n\nif True:\n    main()",
    "def solve(n, m, antennas):\n    # Initialize a list to keep track of the coverage of each position\n    coverage = [False] * (m + 1)\n    \n    # Iterate through each antenna\n    for i in range(n):\n        x, s = antennas[i]\n        \n        # Update the coverage of the current antenna\n        for j in range(max(1, x - s), min(m + 1, x + s) + 1):\n            coverage[j] = True\n    \n    # Count the number of uncovered positions\n    uncovered_positions = sum(not pos for pos in coverage)\n    \n    # Calculate the minimum cost\n    return uncovered_positions\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nresult = solve(n, m, antennas)\n\n# Print the result\nprint(result)",
    "def solve(n, m, antennas):\n    positions = set()\n    for x, s in antennas:\n        positions.update(range(x - s, x + s + 1))\n    \n    uncovered_positions = set(range(1, m + 1)) - positions\n    \n    return len(uncovered_positions)\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve and print output\nprint(solve(n, m, antennas))",
    "def solve(n, m, x, s):\n    covered = set()\n    for i in range(n):\n        left, right = x[i] - s[i], x[i] + s[i]\n        for j in range(left, right + 1):\n            covered.add(j)\n    \n    return len(covered) >= m\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    x = data[2:2+n]\n    s = data[2+n:]\n    print(solve(n, m, x, s))\n\nif True:\n    main()",
    "def solve(n, m):\n    # Initialize variables\n    positions = [0] * m\n    scopes = [0] * n\n    \n    # Read input\n    for i in range(n):\n        x, s = map(int, input().split())\n        positions[x - 1] = 1\n        scopes[i] = s\n    \n    # Sort positions and scopes\n    sorted_positions = sorted(range(m), key=lambda x: positions[x])\n    sorted_scopes = sorted(scopes)\n    \n    # Calculate minimum coins\n    coins = 0\n    for i in range(n):\n        if sorted_scopes[i] > 0:\n            coins += sorted_scopes[i]\n            sorted_scopes[i] -= 1\n    \n    return coins\n\n# Main function\nif True:\n    n, m = map(int, input().split())\n    print(solve(n, m))",
    "def solve(n, m, antennas):\n    # Initialize the set of covered positions\n    covered_positions = set()\n    \n    # Iterate over each antenna\n    for i in range(n):\n        x, s = antennas[i]\n        \n        # Add the entire interval [x-s, x+s] to the covered positions\n        for j in range(x - s, x + s + 1):\n            covered_positions.add(j)\n    \n    # Calculate the number of uncovered positions\n    uncovered_positions = set(range(1, m + 1)) - covered_positions\n    \n    # Return the minimum number of coins needed\n    return len(uncovered_positions)\n\n# Read input\nn, m = map(int, input().split())\nantennas = []\nfor _ in range(n):\n    x, s = map(int, input().split())\n    antennas.append((x, s))\n\n# Solve the problem\nprint(solve(n, m, antennas))",
    "def solve(n, m, antennas):\n    positions = [0] * (m + 1)\n    for x, s in antennas:\n        positions[x - s:x + s + 1] = [1] * len(positions[x - s:x + s + 1])\n    \n    return sum(sum(row) for row in positions)\n\n# Read input\nn, m = map(int, input().split())\nantennas = []\nfor _ in range(n):\n    x, s = map(int, input().split())\n    antennas.append((x, s))\n\n# Solve and print output\nprint(solve(n, m, antennas))",
    "def solve(n, m, antennas):\n    # Create a list to store the coverage intervals for each antenna\n    coverage_intervals = []\n    \n    # Iterate through each antenna\n    for i in range(n):\n        x, s = antennas[i]\n        \n        # Calculate the start and end of the coverage interval for the current antenna\n        start = max(1, x - s)\n        end = min(m, x + s)\n        \n        # Add the coverage interval to the list\n        coverage_intervals.append((start, end))\n    \n    # Sort the coverage intervals based on their start points\n    coverage_intervals.sort(key=lambda x: x[0])\n    \n    # Initialize variables to keep track of the total cost and the number of uncovered positions\n    total_cost = 0\n    uncovered_positions = set(range(1, m + 1))\n    \n    # Iterate through the sorted coverage intervals\n    for start, end in coverage_intervals:\n        # Update the set of uncovered positions\n        uncovered_positions -= set(range(start, end + 1))\n        \n        # If there are no uncovered positions left, break the loop\n        if not uncovered_positions:\n            break\n    \n    # Return the total cost\n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nresult = solve(n, m, antennas)\n\n# Print the result\nprint(result)",
    "def solve(n, m, antennas):\n    covered_positions = set()\n    total_cost = 0\n    \n    for x, s in antennas:\n        left_bound = max(1, x - s)\n        right_bound = min(m, x + s)\n        \n        for pos in range(left_bound, right_bound + 1):\n            covered_positions.add(pos)\n    \n    uncovered_positions = set(range(1, m + 1)) - covered_positions\n    \n    while uncovered_positions:\n        uncovered_position = min(uncovered_positions)\n        for x, s in antennas:\n            left_bound = max(1, x - s)\n            right_bound = min(m, x + s)\n            \n            if uncovered_position >= left_bound and uncovered_position <= right_bound:\n                uncovered_positions.remove(uncovered_position)\n                total_cost += 1\n                break\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nresult = solve(n, m, antennas)\n\n# Print the result\nprint(result)",
    "def solve(n, m, x, s):\n    total_cost = 0\n    for i in range(n):\n        current_scope = s[i]\n        while True:\n            if current_scope >= m:\n                break\n            total_cost += 1\n            current_scope += 1\n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nx = list(map(int, input().split()))\ns = list(map(int, input().split()))\n\n# Solve the problem\nprint(solve(n, m, x, s))",
    "def solve(n, m, antennas):\n    # Sort antennas by their start positions\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    # Iterate through each antenna\n    for i in range(n):\n        # Calculate the new scope after increasing the current antenna's scope\n        new_scope = max(current_scope + antennas[i][1], antennas[i][0] + antennas[i][1])\n        \n        # Update the total cost\n        total_cost += new_scope - current_scope\n        \n        # Update the current scope\n        current_scope = new_scope\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(solve(n, m, antennas))",
    "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [data[i:i+2] for i in range(2, 2*n, 2)]\n    \n    def can_cover(position):\n        return any(x <= position <= y for x, y in antennas)\n    \n    min_coins = 0\n    for i in range(1, m+1):\n        if not can_cover(i):\n            min_coins += 1\n    \n    print(min_coins)\n\nif True:\n    main()",
    "def solve(n, m, antennas):\n    # Initialize a set to store covered positions\n    covered_positions = set()\n    \n    # Iterate through each antenna\n    for i in range(n):\n        x, s = antennas[i]\n        \n        # Add the entire interval [x-s, x+s] to the covered positions set\n        for j in range(x - s, x + s + 1):\n            covered_positions.add(j)\n    \n    # Calculate the number of uncovered positions\n    uncovered_positions_count = m - len(covered_positions)\n    \n    # Return the minimum cost required to cover all positions\n    return uncovered_positions_count\n\n# Read input\nn, m = map(int, input().split())\nantennas = []\nfor _ in range(n):\n    x, s = map(int, input().split())\n    antennas.append((x, s))\n\n# Solve the problem\nresult = solve(n, m, antennas)\n\n# Print the result\nprint(result)",
    "def solve(n, m):\n    antennas = [(x, s) for x, s in sorted(zip(range(1, m+1), [int(input()) for _ in range(n)]))]\n    covered_positions = set()\n    \n    for _, s in antennas:\n        start = max(1, x - s)\n        end = min(m, x + s)\n        covered_positions.update(range(start, end + 1))\n    \n    return len(covered_positions)\n\n# Read input\nn, m = map(int, input().split())\nprint(solve(n, m))",
    "def solve(n, m, antennas):\n    covered_positions = set()\n    for i in range(n):\n        left, right = max(1, antennas[i][0] - antennas[i][1]), min(m, antennas[i][0] + antennas[i][1])\n        for j in range(left, right + 1):\n            covered_positions.add(j)\n    \n    return len(covered_positions) == m\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [data[i:i+2] for i in range(2, 2*n, 2)]\n    print(solve(n, m, antennas))\n\nif True:\n    main()",
    "def solve(n, m, x_s):\n    x_s.sort()\n    ans = 0\n    for i in range(1, m+1):\n        found = False\n        for j in range(n):\n            if x_s[j][0] <= i <= x_s[j][1]:\n                ans += 1\n                found = True\n                break\n        if not found:\n            return -1\n    return ans\n\n# Read input\nn, m = map(int, input().split())\nx_s = []\nfor _ in range(n):\n    x, s = map(int, input().split())\n    x_s.append((x, s))\n\n# Solve the problem\nresult = solve(n, m, x_s)\nprint(result)",
    "def solve(n, m, antennas):\n    covered_positions = set()\n    \n    for i in range(n):\n        x, s = antennas[i]\n        for j in range(x - s, x + s + 1):\n            covered_positions.add(j)\n    \n    uncovered_positions = set(range(1, m + 1)) - covered_positions\n    \n    return len(uncovered_positions)\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nresult = solve(n, m, antennas)\n\n# Print the result\nprint(result)",
    "def solve(n, m, antennas):\n    # Sort antennas by their starting point\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    # Iterate through each antenna\n    for i in range(n):\n        # Calculate the new scope after increasing the current antenna's scope\n        new_scope = max(current_scope + antennas[i][1], antennas[i][0] + antennas[i][1])\n        \n        # Update the total cost\n        total_cost += new_scope - current_scope\n        \n        # Update the current scope\n        current_scope = new_scope\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(solve(n, m, antennas))",
    "def solve(n, m, antennas):\n    # Create a set of all positions from 1 to m\n    positions = set(range(1, m + 1))\n    \n    # Initialize the total cost to 0\n    total_cost = 0\n    \n    # Iterate over each antenna\n    for i in range(n):\n        # Get the position and scope of the current antenna\n        x, s = antennas[i]\n        \n        # Calculate the new scope of the antenna after incrementing it by 1\n        new_s = s + 1\n        \n        # Update the positions covered by the antenna\n        positions.update(range(x - new_s, x + new_s + 1))\n    \n    # Calculate the number of uncovered positions\n    uncovered_positions = len(positions)\n    \n    # If there are uncovered positions, calculate the total cost\n    if uncovered_positions > 0:\n        total_cost = uncovered_positions\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nresult = solve(n, m, antennas)\n\n# Print the result\nprint(result)",
    "def solve(n, m):\n    positions = sorted(set([x for x, _ in zip(range(1, m+1), range(1, n+1))]))\n    total_cost = 0\n    \n    for i in range(len(positions)):\n        if i == 0:\n            total_cost += positions[i]\n        else:\n            total_cost += positions[i] - positions[i-1]\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(solve(n, m))",
    "def solve(n, m, antennas):\n    # Sort the antennas by their starting positions\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    # Iterate through each antenna\n    for i in range(n):\n        # Calculate the new scope after increasing the current antenna's scope\n        new_scope = max(current_scope + antennas[i][1], antennas[i][0] + antennas[i][1])\n        \n        # Update the total cost\n        total_cost += new_scope - current_scope\n        \n        # Update the current scope\n        current_scope = new_scope\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(solve(n, m, antennas))"
  ],
  "rewards": [
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.045454545454545456,
    0.0,
    0.0,
    0.045454545454545456,
    0.0,
    0.0,
    0.0,
    0.06818181818181818,
    0.06818181818181818,
    0.0,
    0.045454545454545456,
    0.0,
    0.0,
    0.06818181818181818,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.06818181818181818,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.06818181818181818,
    0.0,
    0.0,
    0.06818181818181818,
    0.0,
    0.045454545454545456,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.06818181818181818,
    0.0,
    0.0,
    0.0,
    0.0
  ],
  "train rewards": [
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.045454545454545456,
    0.0,
    0.0,
    0.045454545454545456,
    0.0,
    0.0,
    0.0,
    0.1590909090909091,
    0.1590909090909091,
    0.09090909090909091,
    0.045454545454545456,
    0.022727272727272728,
    0.0,
    0.11363636363636363,
    0.0,
    0.0,
    0.022727272727272728,
    0.0,
    0.0,
    0.0,
    0.1590909090909091,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.1590909090909091,
    0.0,
    0.0,
    0.1590909090909091,
    0.0,
    0.045454545454545456,
    0.0,
    0.0,
    0.0,
    0.0,
    0.09090909090909091,
    0.0,
    0.0,
    0.0,
    0.1590909090909091,
    0.0,
    0.0,
    0.0,
    0.0
  ],
  "time": [
    23.63500475883484,
    27.57432246208191,
    44.31789946556091,
    48.23376393318176,
    62.0182580947876,
    67.7366669178009,
    73.1141288280487,
    77.7686231136322,
    93.21908020973206,
    98.77840781211853,
    105.49377703666687,
    111.54394936561584,
    117.33271265029907,
    121.05151104927063,
    124.69945645332336,
    130.4002435207367,
    136.83986258506775,
    141.52412819862366,
    148.65338850021362,
    153.8772633075714,
    157.46363496780396,
    163.49682712554932,
    168.1358392238617,
    171.36317467689514,
    174.7704381942749,
    179.96466255187988,
    186.11768436431885,
    191.55298829078674,
    197.72484970092773,
    202.82553458213806,
    207.0941503047943,
    212.31110453605652,
    215.6014654636383,
    219.83433079719543,
    230.13930130004883,
    235.80078268051147,
    239.97211122512817,
    248.11987018585205,
    254.4382963180542,
    267.66357612609863,
    273.4510872364044,
    277.56573510169983,
    291.9056680202484,
    295.7442054748535,
    300.3679099082947,
    304.97365164756775,
    308.8399872779846,
    314.88720536231995,
    321.58693051338196,
    325.61315870285034,
    330.63537883758545
  ],
  "sample times": 51
}