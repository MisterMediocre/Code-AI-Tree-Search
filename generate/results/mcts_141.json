{
  "prompt": "\nQUESTION:\nYou have a set of items, each having some integer weight not greater than $8$. You denote that a subset of items is good if total weight of items in the subset does not exceed $W$.\n\nYou want to calculate the maximum possible weight of a good subset of items. Note that you have to consider the empty set and the original set when calculating the answer.\n\n\n-----Input-----\n\nThe first line contains one integer $W$ ($0 \\le W \\le 10^{18}$) \u2014 the maximum total weight of a good subset.\n\nThe second line denotes the set of items you have. It contains $8$ integers $cnt_1$, $cnt_2$, ..., $cnt_8$ ($0 \\le cnt_i \\le 10^{16}$), where $cnt_i$ is the number of items having weight $i$ in the set.\n\n\n-----Output-----\n\nPrint one integer \u2014 the maximum possible weight of a good subset of items.\n\n\n-----Examples-----\nInput\n10\n1 2 3 4 5 6 7 8\n\nOutput\n10\n\nInput\n0\n0 0 0 0 0 0 0 0\n\nOutput\n0\n\nInput\n3\n0 4 1 0 0 9 8 3\n\nOutput\n3\n\nInstructions:\n\n\nYou are a Python3 code generator.  Output **only** valid Python code. No explanations, no commentary, no filenames, no Markdown formatting. You will spit out a code block that can be pasted into any script. It must read the input, execute the logic and then print the output. Ensure that you invoke the main() or solve() function at the end if you're writing your code inside them.\nANSWER:\n",
  "codes": [
    "def solve(W, cnt):\n    max_weight = 0\n    for i in range(1, 9):\n        max_weight += min(cnt[i], W // i)\n    return max_weight\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "import sys\n\ndef solve():\n    W = int(sys.stdin.readline())\n    cnts = list(map(int, sys.stdin.readline().split()))\n    \n    max_weight = 0\n    for i in range(1, 9):\n        max_weight += min(W // i, cnts[i - 1])\n    \n    return max_weight\n\nif True:\n    solve()",
    "def solve():\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    \n    max_weight = 0\n    for i in range(1, 9):\n        max_weight += min(W // i, cnts[i - 1])\n    \n    return max_weight\n\nif True:\n    solve()",
    "def main():\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    \n    max_weight = 0\n    for i in range(1, 9):\n        max_weight += min(W // i, cnts[i - 1])\n    \n    print(max_weight)\n\nif True:\n    main()",
    "def solve(W, cnts):\n    max_weight = 0\n    for i in range(1, 9):\n        max_weight += min(cnts[i], W // i)\n    return max_weight\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def max_good_subset_weight(W, cnts):\n    # Initialize the dp array with zeros\n    dp = [0] * (W + 1)\n    \n    # Iterate over each item's weight\n    for cnt in cnts:\n        # Update the dp array for each possible weight from the current item's weight up to W\n        for i in range(cnt, W + 1):\n            dp[i] = max(dp[i], dp[i - cnt] + cnt)\n    \n    return dp[W]\n\n# Read input\nW = int(input())\ncnts = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_good_subset_weight(W, cnts))",
    "def solve(W, weights):\n    max_weight = 0\n    for i in range(1, 9):\n        max_weight += min(weights[i], W // i)\n    return max_weight\n\nif True:\n    W = int(input())\n    weights = list(map(int, input().split()))\n    print(solve(W, weights))",
    "def max_good_subset_weight(W, weights):\n    # Initialize a list to store the maximum weight for each weight\n    dp = [0] * (W + 1)\n    \n    # Iterate over each weight from 1 to W\n    for w in range(1, W + 1):\n        # Update the maximum weight for each weight based on the previous weights\n        for i in range(1, 9):\n            if weights[i - 1] <= w:\n                dp[w] = max(dp[w], dp[w - weights[i - 1]] + i)\n    \n    return dp[W]\n\n# Read input\nW = int(input())\nweights = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_good_subset_weight(W, weights))",
    "def max_good_subset_weight(W, cnt):\n    # Initialize the dp array with zeros\n    dp = [0] * (W + 1)\n    \n    # Iterate over each item's weight\n    for i in range(1, 9):\n        # Update the dp array based on the current item's count\n        for j in range(i, W + 1):\n            dp[j] = max(dp[j], dp[j - i] + cnt[i - 1])\n    \n    return dp[W]\n\n# Read input from stdin\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_good_subset_weight(W, cnt))",
    "def solve(W, cnt):\n    dp = [0] * (W + 1)\n    for i in range(1, 9):\n        for j in range(cnt[i], W + 1):\n            dp[j] = max(dp[j], dp[j - cnt[i]] + i)\n    return dp[W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    W = data[0]\n    cnts = data[1:]\n    \n    max_weight = 0\n    for i in range(1, 9):\n        max_weight += min(W // i, cnts[i - 1]) * i\n    \n    return max_weight\n\nif True:\n    solve()",
    "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    W = data[0]\n    cnts = data[1:]\n    \n    def max_weight(cnts):\n        dp = [0] * (W + 1)\n        for cnt in cnts:\n            for i in range(W, -1, -1):\n                if i >= cnt:\n                    dp[i] = max(dp[i], dp[i - cnt] + cnt)\n        return dp[W]\n\n    print(max_weight(cnts))\n\nif True:\n    main()",
    "def max_good_subset_weight(W, counts):\n    # Initialize the result with the minimum possible weight (0)\n    result = 0\n    \n    # Iterate through each count from 1 to 8\n    for i in range(1, 9):\n        # Calculate the maximum weight that can be included in the subset\n        max_weight = min(counts[i], W // i)\n        \n        # Update the result by adding the maximum weight found\n        result += max_weight\n    \n    return result\n\n# Read input\nW = int(input())\ncounts = list(map(int, input().split()))\n\n# Solve the problem\nprint(max_good_subset_weight(W, counts))",
    "def solve(W, cnt):\n    return min(W, sum(cnt))\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve(W, cnt):\n    return max(0, min(W, sum(cnt)))\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve(W, counts):\n    max_weight = 0\n    for i in range(1, 9):\n        max_weight += min(counts[i], W // i)\n    return max_weight\n\nif True:\n    W = int(input())\n    counts = list(map(int, input().split()))\n    print(solve(W, counts))",
    "def solve(W: int, cnts: list[int]) -> int:\n    max_weight = 0\n    for i in range(1, 9):\n        max_weight += min(cnts[i], W // i)\n    return max_weight\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, min(W, sum(cnt * i for i, cnt in enumerate(cnts))))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    # Initialize the dp array with zeros\n    dp = [0] * (W + 1)\n    \n    # Iterate over each item's weight\n    for cnt in cnts:\n        # Update the dp array for each possible weight from the current item's weight up to W\n        for i in range(cnt, W + 1):\n            dp[i] = max(dp[i], dp[i - cnt] + cnt)\n    \n    # Return the maximum weight of a good subset\n    return dp[W]\n\n# Read input\nW = int(input())\ncnts = list(map(int, input().split()))\n\n# Solve the problem\nprint(solve(W, cnts))",
    "def solve(W, cnts):\n    return min(W, sum(cnt * i for i, cnt in enumerate(cnts)))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, sum(cnt * min(W // cnt, 8) for cnt in cnts))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(sum(cnt * i for i, cnt in enumerate(cnts)) for cnt in range(9))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, min(sum(cnts[i] * i for i in range(1, 9)), W))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    # Sort the counts in descending order\n    cnts.sort(reverse=True)\n    \n    # Initialize the current weight and the result\n    current_weight = 0\n    result = 0\n    \n    # Iterate through the sorted counts\n    for cnt in cnts:\n        # If adding the current count would exceed the limit, break\n        if current_weight + cnt > W:\n            break\n        \n        # Add the current count to the current weight and update the result\n        current_weight += cnt\n        result += cnt\n    \n    return result\n\n# Read input\nW = int(input())\ncnts = list(map(int, input().split()))\n\n# Solve the problem\nprint(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(W - sum(cnts[i] * i for i in range(1, 9)), 0)\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return min(W, max(cnts))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, min(W, sum(cnts)))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    # Initialize a list to store the maximum weight for each weight from 0 to 8\n    max_weights = [0] * 9\n    \n    # Iterate through each count of items for each weight\n    for i in range(1, 9):\n        for j in range(cnts[i-1], 0, -1):\n            # Update the maximum weight for this weight by adding the current count\n            max_weights[i] = max(max_weights[i], max_weights[i-j] + j)\n    \n    # Return the maximum weight for the given weight limit W\n    return max_weights[W]\n\n# Read input\nW = int(input())\ncnts = list(map(int, input().split()))\n\n# Solve the problem\nprint(solve(W, cnts))",
    "def solve(W, cnts):\n    return min(W, sum(cnts))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return min(max(0, W - sum(cnts)), max(0, sum(cnts)))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    # Initialize the result with the minimum possible weight\n    result = float('-inf')\n    \n    # Iterate over all possible subsets of items\n    for i in range(1 << 8):\n        current_weight = 0\n        \n        # Calculate the weight of the current subset\n        for j in range(8):\n            if (i >> j) & 1:\n                current_weight += cnts[j]\n        \n        # Update the result if the current subset is good and has a higher weight\n        if current_weight <= W and current_weight > result:\n            result = current_weight\n    \n    return result\n\n# Read input from stdin\nW = int(input())\ncnts = list(map(int, input().split()))\n\n# Call the solve function and print the result\nprint(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, W - sum(cnt * i for i, cnt in enumerate(cnts)))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, sum(min(cnt, W // i) for i, cnt in enumerate(cnts)))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return min(W, sum(cnt for cnt in cnts))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, min(W, sum(cnt for cnt in cnts)))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, min(W - sum(cnts[i] * i for i in range(1, 9)), sum(cnts[i] * i for i in range(1, 9)))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, min(W, sum(cnt * (i + 1) for i, cnt in enumerate(cnts))))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, min(W, sum(cnt * i for i, cnt in enumerate(cnts, start=1))))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, min(W + sum(cnts[i] * i for i in range(1, 9)), sum(cnts)))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, min(W, sum(cnt * i for i, cnt in enumerate(cnts))))\n    \nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, min(W, sum(cnt * i for i, cnt in enumerate(cnts))))\n\n# Read input\nW = int(input())\ncnts = list(map(int, input().split()))\n\n# Print output\nprint(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, min(W, sum(cnt * i for i, cnt in enumerate(cnts))))\n\nif True:\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    W = data[0]\n    cnts = data[1:]\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, min(W, sum(cnt * i for i, cnt in enumerate(cnts))))\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, min(W, sum(cnt * i for i, cnt in enumerate(cnts, start=1))))\n\n# Read input\nW = int(input())\ncnts = list(map(int, input().split()))\n\n# Print output\nprint(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, min(W, sum(cnt * i for i, cnt in enumerate(cnts, start=1))))\n\nif True:\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    W = data[0]\n    cnts = data[1:]\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, min(max(cnts[i] for i in range(1, 9)), W))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, min(W, sum(cnt * i for i, cnt in enumerate(cnts))))",
    "def solve(W, cnts):\n    return max(0, min(W, sum(cnt * i for i, cnt in enumerate(cnts))))\n\ndef main():\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))\n\nif True:\n    main()",
    "def solve(W, cnts):\n    return max(0, sum(cnt * i for i, cnt in enumerate(cnts) if i <= W))\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, min(W, sum(cnt * i for i, cnt in enumerate(cnts, start=1))))\n    \nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W, cnts):\n    return max(0, min(W, sum(cnt * i for i, cnt in enumerate(cnts, start=1))))\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))"
  ],
  "rewards": [
    0.0,
    0.0,
    0.0,
    0.11363636363636363,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.22727272727272727,
    0.22727272727272727,
    0.0,
    0.0,
    0.45454545454545453,
    0.0,
    0.45454545454545453,
    0.0,
    0.0,
    0.0,
    0.13636363636363635,
    0.0,
    0.06818181818181818,
    0.22727272727272727,
    0.06818181818181818,
    0.22727272727272727,
    0.06818181818181818,
    0.13636363636363635,
    0.06818181818181818,
    0.0,
    0.22727272727272727,
    0.22727272727272727,
    0.0,
    0.8181818181818182,
    0.8181818181818182,
    0.0,
    0.45454545454545453,
    0.45454545454545453,
    0.45454545454545453,
    0.45454545454545453,
    0.8181818181818182,
    0.8181818181818182,
    0.0,
    0.0,
    0.45454545454545453,
    0.022727272727272728,
    0.8181818181818182,
    0.8181818181818182
  ],
  "train rewards": [
    0.0,
    0.0,
    0.0,
    0.20454545454545456,
    0.0,
    0.4318181818181818,
    0.0,
    0.13636363636363635,
    0.13636363636363635,
    0.0,
    0.0,
    0.18181818181818182,
    0.0,
    0.36363636363636365,
    0.36363636363636365,
    0.0,
    0.0,
    0.7272727272727273,
    0.4318181818181818,
    0.7272727272727273,
    0.0,
    0.045454545454545456,
    0.0,
    0.13636363636363635,
    0.0,
    0.25,
    0.36363636363636365,
    0.11363636363636363,
    0.36363636363636365,
    0.11363636363636363,
    0.18181818181818182,
    0.13636363636363635,
    0.0,
    0.36363636363636365,
    0.36363636363636365,
    0.0,
    0.9545454545454546,
    0.9545454545454546,
    0.0,
    0.7272727272727273,
    0.7272727272727273,
    0.7272727272727273,
    0.7272727272727273,
    0.9545454545454546,
    0.9545454545454546,
    0.0,
    0.0,
    0.7272727272727273,
    0.11363636363636363,
    0.9545454545454546,
    0.9545454545454546
  ],
  "time": [
    2.4415338039398193,
    4.9803454875946045,
    7.2936930656433105,
    9.63994812965393,
    12.030507802963257,
    16.26554560661316,
    18.597583293914795,
    23.236680507659912,
    27.36701989173889,
    30.303601026535034,
    33.171828508377075,
    36.944087743759155,
    40.87933278083801,
    42.355668783187866,
    43.92180895805359,
    46.24082660675049,
    48.89707326889038,
    50.81457328796387,
    54.922282457351685,
    56.740466356277466,
    58.5504674911499,
    60.416942834854126,
    62.301769971847534,
    66.57420897483826,
    68.523845911026,
    69.96552085876465,
    71.38221859931946,
    76.04777979850769,
    77.46774816513062,
    79.29431343078613,
    84.1079969406128,
    86.07603430747986,
    88.04729557037354,
    89.75799322128296,
    91.47416830062866,
    93.97172498703003,
    95.5919098854065,
    97.27963471412659,
    99.42650938034058,
    101.03145694732666,
    102.49850273132324,
    104.32934999465942,
    105.8928861618042,
    107.38015007972717,
    109.19452333450317,
    111.20661282539368,
    111.81322598457336,
    113.52705430984497,
    115.48131966590881,
    117.10524940490723,
    118.66959547996521
  ],
  "sample times": 51
}