{
  "prompt": "\nQUESTION:\nThe mayor of the Central Town wants to modernize Central Street, represented in this problem by the $(Ox)$ axis.\n\nOn this street, there are $n$ antennas, numbered from $1$ to $n$. The $i$-th antenna lies on the position $x_i$ and has an initial scope of $s_i$: it covers all integer positions inside the interval $[x_i - s_i; x_i + s_i]$.\n\nIt is possible to increment the scope of any antenna by $1$, this operation costs $1$ coin. We can do this operation as much as we want (multiple times on the same antenna if we want).\n\nTo modernize the street, we need to make all integer positions from $1$ to $m$ inclusive covered by at least one antenna. Note that it is authorized to cover positions outside $[1; m]$, even if it's not required.\n\nWhat is the minimum amount of coins needed to achieve this modernization?\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\le 80$ and $n \\le m \\le 100\\ 000$).\n\nThe $i$-th of the next $n$ lines contains two integers $x_i$ and $s_i$ ($1 \\le x_i \\le m$ and $0 \\le s_i \\le m$).\n\nOn each position, there is at most one antenna (values $x_i$ are pairwise distinct).\n\n\n-----Output-----\n\nYou have to output a single integer: the minimum amount of coins required to make all integer positions from $1$ to $m$ inclusive covered by at least one antenna.\n\n\n-----Examples-----\nInput\n3 595\n43 2\n300 4\n554 10\n\nOutput\n281\n\nInput\n1 1\n1 1\n\nOutput\n0\n\nInput\n2 50\n20 0\n3 1\n\nOutput\n30\n\nInput\n5 240\n13 0\n50 25\n60 5\n155 70\n165 70\n\nOutput\n26\n\n\n\n-----Note-----\n\nIn the first example, here is a possible strategy:\n\n  Increase the scope of the first antenna by $40$, so that it becomes $2 + 40 = 42$. This antenna will cover interval $[43 - 42; 43 + 42]$ which is $[1; 85]$  Increase the scope of the second antenna by $210$, so that it becomes $4 + 210 = 214$. This antenna will cover interval $[300 - 214; 300 + 214]$, which is $[86; 514]$  Increase the scope of the third antenna by $31$, so that it becomes $10 + 31 = 41$. This antenna will cover interval $[554 - 41; 554 + 41]$, which is $[513; 595]$ \n\nTotal cost is $40 + 210 + 31 = 281$. We can prove that it's the minimum cost required to make all positions from $1$ to $595$ covered by at least one antenna.\n\nNote that positions $513$ and $514$ are in this solution covered by two different antennas, but it's not important.\n\n\u2014\n\nIn the second example, the first antenna already covers an interval $[0; 2]$ so we have nothing to do.\n\nNote that the only position that we needed to cover was position $1$; positions $0$ and $2$ are covered, but it's not important.\n\nTUTORIAL:\nWe can add an antenna (x = 0, s = 0). It will not modify the answer, because it would be non-optimal to increase the scope of this antenna.\n\nLet dp\u2093 be the minimum cost to cover all positions from x to m inclusive, knowing that position x is covered. We compute dp in decreasing order of x.\n\nBase case is dp\u2098 := 0.\n\nThe default transition is dp\u2093 := (m \u2212 x).\n\nIf position x + 1 is initially covered, dp\u2093 := dp\u2093\u208a\u2081\n\nOtherwise, let's consider all antennas and their initial intervals [l\u1d62; r\u1d62]. If x < l\u1d62, let  \nu = (l\u1d62 \u2212 x \u2212 1), then a possible transition is dp\u2093 := u + dp\u2098\u1d62\u2099(m, r\u1d62 + u).\n\nWe take the minimum of all these transitions. Note that we always extend intervals as less as possible, but it's optimal because:\n\n\u2022 If after using this interval i, we use another interval j (at the right of i), the time spent to extend i could have been used to extend j instead, which will be more optimal.\n\u2022 If i was the last interval used, we don't care because the default transition will take care of this case.\n\nThe final answer will be dp\u2080.\n\nThere are O(m) states and O(n) transitions, hence final complexity is O(nm) with very low constant. O(n\u00b2 \u00b7 m) can also get AC because of very low constant.\n\n\nInstructions:\n\n\nYou are a Python3 code generator.  Output **only** valid Python code. No explanations, no commentary, no filenames, no Markdown formatting. You will spit out a code block that can be pasted into any script. It must read the input, execute the logic and then print the output. Ensure that you invoke the main() or solve() function at the end if you're writing your code inside them.\nANSWER:\n",
  "codes": [
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i], data[i+1]) for i in range(2, 2*n, 2)]\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x + s <= m:\n                dp[x] = min(dp[x], dp[x+s])\n        \n        if x + 1 < m and dp[x+1] != float('inf'):\n            for _, s in antennas:\n                if x + s + 1 <= m:\n                    dp[x] = min(dp[x], dp[x+s+1] + (m - x - 1))\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, sys.stdin.readline().split())\n        antennas.append((x, s))\n    \n    # Add an antenna at position 0 with scope 0\n    antennas.insert(0, (0, 0))\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x < s:\n                continue\n            u = max(x - s - 1, 0)\n            dp[x] = min(dp[x], u + dp[m - s])\n    \n    return dp[0]\n\nif True:\n    print(solve())",
    "def solve(n, m, antennas):\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m - 1, -1, -1):\n        dp[x] = min(dp[x], m - x)\n        \n        for i in range(n):\n            l, r = antennas[i]\n            if x < l:\n                u = l - x - 1\n                dp[x] = min(dp[x], u + dp[m - r])\n    \n    return dp[0]\n\n# Read input\nn, m = map(int, input().split())\nantennas = []\nfor _ in range(n):\n    x, s = map(int, input().split())\n    antennas.append((x, s))\n\n# Solve and print output\nprint(solve(n, m, antennas))",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Add an antenna at position 0 with scope 0\n    antennas.insert(0, (0, 0))\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x < s:\n                continue\n            u = max(x - s - 1, 0)\n            dp[x] = min(dp[x], u + dp[m - s])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i], data[i+1]) for i in range(2, 2*n, 2)]\n    \n    def dp(x):\n        if x == m:\n            return 0\n        min_cost = m - x\n        for _, s in antennas:\n            if x < s:\n                u = s - x - 1\n                min_cost = min(min_cost, u + dp(m - s))\n        return min_cost\n    \n    print(dp(0))\n\nif True:\n    main()",
    "from typing import *\nimport sys\n\ndef solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Add an antenna at position 0 with scope 0\n    antennas.insert(0, (0, 0))\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x >= s:\n                dp[x] = min(dp[x], dp[x + s])\n            else:\n                for i, (l, r) in enumerate(antennas):\n                    if x < l:\n                        u = (l - x - 1)\n                        dp[x] = min(dp[x], u + dp[m - r + u])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "import sys\nfrom typing import List\n\ndef solve(n: int, m: int, antennas: List[List[int]]) -> int:\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m - 1, -1, -1):\n        dp[x] = min(dp[x], m - x)\n        \n        for x1, s1 in antennas:\n            if x < x1:\n                u = x1 - x - 1\n                dp[x] = min(dp[x], u + dp[m - s1])\n    \n    return dp[0]\n\nif True:\n    input_data = sys.stdin.read().split()\n    n, m = map(int, input_data[:2])\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input_data[2:])\n        antennas.append([x, s])\n    print(solve(n, m, antennas))",
    "def solve(n, m):\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m - 1, -1, -1):\n        dp[x] = min(dp[x], m - x)\n        \n        for i in range(n):\n            l, r = x - s[i], x + s[i]\n            if l > m:\n                continue\n            \n            if l == 0:\n                dp[x] = min(dp[x], dp[m])\n            else:\n                u = l - x - 1\n                dp[x] = min(dp[x], u + dp[m - s[i]])\n    \n    return dp[0]\n\n# Read input\nn, m = map(int, input().split())\nantennas = []\nfor _ in range(n):\n    x, s = map(int, input().split())\n    antennas.append((x, s))\n\n# Solve the problem\nprint(solve(n, m))",
    "def main():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by their starting point in descending order\n    antennas.sort(key=lambda x: x[0], reverse=True)\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x + s <= m:\n                dp[x] = min(dp[x], dp[x + s])\n        \n        # Add an antenna at position 0 with scope 0\n        dp[x] = min(dp[x], x + 0)\n    \n    print(dp[0])\n\nif True:\n    main()",
    "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i], data[i+1]) for i in range(2, 2*n, 2)]\n    \n    def dp(x):\n        if x == m:\n            return 0\n        min_cost = m - x\n        for _, s in antennas:\n            if x < s:\n                u = s - x - 1\n                min_cost = min(min_cost, u + dp(m - s))\n        return min_cost\n    \n    print(dp(0))\n\nif True:\n    main()",
    "def modernize_street(n, m, antennas):\n    # Initialize dp array where dp[x] represents the minimum cost to cover positions from x to m\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Add an antenna at position 0 with scope 0\n    for x, s in antennas:\n        dp[x] = 0\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m - 1, -1, -1):\n        # Default transition\n        dp[x] = m - x\n        \n        # Check if position x + 1 is initially covered\n        if dp[x + 1] != float('inf'):\n            dp[x] = min(dp[x], dp[x + 1])\n        \n        # Consider all antennas and their initial intervals\n        for i in range(n):\n            l, r = antennas[i]\n            if x < l:\n                u = l - x - 1\n                dp[x] = min(dp[x], u + dp[m - r])\n    \n    return dp[0]\n\n# Read input\nn, m = map(int, input().split())\nantennas = []\nfor _ in range(n):\n    x, s = map(int, input().split())\n    antennas.append((x, s))\n\n# Print output\nprint(modernize_street(n, m, antennas))",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i], data[i+1]) for i in range(2, 2*n, 2)]\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Iterate over positions in reverse order\n    for x in range(m, -1, -1):\n        # Default transition\n        dp[x] = min(dp[x], m - x)\n        \n        # Check if position x + 1 is initially covered\n        if x + 1 <= m:\n            dp[x] = min(dp[x], dp[x + 1])\n        \n        # Consider all antennas\n        for l, r in antennas:\n            if x < l:\n                u = l - x - 1\n                dp[x] = min(dp[x], u + dp[m - r])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve(n, m, x_s):\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x, s in sorted(x_s, reverse=True):\n        for i in range(x + 1, m + 1):\n            dp[i] = min(dp[i], dp[i - 1])\n            if i + s <= m:\n                dp[i + s] = min(dp[i + s], dp[i] + s)\n    \n    return dp[0]\n\n# Read input\nn, m = map(int, input().split())\nx_s = []\nfor _ in range(n):\n    x, s = map(int, input().split())\n    x_s.append((x, s))\n\n# Solve and print output\nprint(solve(n, m, x_s))",
    "def solve():\n    import sys\n    data = sys.stdin.read().split()\n    n, m = int(data[0]), int(data[1])\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, data[_ * 2 + 2:])\n        antennas.append((x, s))\n    \n    # Sort antennas by their starting point in descending order\n    antennas.sort(key=lambda x: x[0], reverse=True)\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x + s <= m:\n                dp[x] = min(dp[x], dp[x + s] + s)\n    \n    # Print the result\n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, data[_ * 2 + 1:_ * 2 + 3])\n        antennas.append((x, s))\n    \n    # Sort antennas by their starting point in descending order\n    antennas.sort(key=lambda x: x[0], reverse=True)\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x >= s:\n                dp[x] = min(dp[x], dp[x + s] + s)\n    \n    # Print the result\n    print(dp[0])\n\nif True:\n    solve()",
    "import sys\nfrom collections import defaultdict\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, sys.stdin.readline().split())\n        antennas.append((x, s))\n    \n    # Add an antenna at position 0 with scope 0\n    antennas.insert(0, (0, 0))\n    \n    # Initialize dp array\n    dp = defaultdict(lambda: float('inf'))\n    dp[m] = 0\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x >= s:\n                dp[x] = min(dp[x], dp[x + s] + s)\n    \n    return dp[0]\n\nif True:\n    print(solve())",
    "import sys\n\ndef solve():\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i], data[i+1]) for i in range(2, 2*n, 2)]\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x + s <= m:\n                dp[x] = min(dp[x], dp[x+s])\n        \n        if x + 1 < m and dp[x+1] != float('inf'):\n            for _, s in antennas:\n                if x + s + 1 <= m:\n                    dp[x] = min(dp[x], dp[x+s+1] + (m - x - 1))\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "from typing import List\n\ndef solve(n: int, m: int, antennas: List[List[int]]) -> int:\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m - 1, -1, -1):\n        dp[x] = min(dp[x], m - x)\n        \n        for x1, s1 in antennas:\n            if x < x1:\n                u = x1 - x - 1\n                dp[x] = min(dp[x], u + dp[m - s1])\n    \n    return dp[0]\n\n# Example usage:\nif True:\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append([x, s])\n    print(solve(n, m, antennas))",
    "def solve():\n    from typing import *\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i], data[i+1]) for i in range(2, 2*n, 2)]\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Iterate over positions in reverse order\n    for x in range(m, -1, -1):\n        # Default transition\n        dp[x] = min(dp[x], m - x)\n        \n        # Check if position x + 1 is initially covered\n        if x + 1 <= m:\n            dp[x] = min(dp[x], dp[x + 1])\n        \n        # Consider all antennas\n        for l, r in antennas:\n            if x < l:\n                u = l - x - 1\n                dp[x] = min(dp[x], u + dp[m - r])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "import sys\nfrom typing import *\nfrom collections import *\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, sys.stdin.readline().split())\n        antennas.append((x, s))\n    \n    # Add an antenna at position 0 with scope 0\n    antennas.insert(0, (0, 0))\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x >= s:\n                dp[x] = min(dp[x], dp[x + s])\n            else:\n                for i, (l, r) in enumerate(antennas):\n                    if x < l:\n                        u = (l - x - 1)\n                        dp[x] = min(dp[x], u + dp[m - r + u])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    from collections import defaultdict\n    \n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    data = data[2:]\n    \n    intervals = defaultdict(list)\n    for i in range(n):\n        x, s = data[i*2], data[i*2+1]\n        intervals[x].append((x-s, x+s))\n    \n    dp = [float('inf')] * (m+1)\n    dp[m] = 0\n    \n    for x in range(m-1, -1, -1):\n        for l, r in intervals[x]:\n            if l > x:\n                continue\n            u = max(0, l-x-1)\n            dp[x] = min(dp[x], u + dp[r+u])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve(n, m, positions):\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m - 1, -1, -1):\n        dp[x] = min(dp[x], m - x)\n        \n        for pos, scope in positions:\n            if pos < x:\n                u = pos - x - 1\n                dp[x] = min(dp[x], u + dp[m - scope])\n    \n    return dp[0]\n\n# Read input\nn, m = map(int, input().split())\npositions = []\nfor _ in range(n):\n    x, s = map(int, input().split())\n    positions.append((x, s))\n\n# Solve and print output\nprint(solve(n, m, positions))",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    \n    def read_int():\n        return int(input().strip())\n    \n    def read_ints():\n        return list(map(int, input().split()))\n    \n    def read_str():\n        return input().strip()\n    \n    def read_strs():\n        return list(map(str, input().split()))\n    \n    n, m = read_ints()\n    antennas = []\n    for _ in range(n):\n        x, s = read_ints()\n        antennas.append((x, s))\n    \n    # Sort antennas by x in descending order\n    antennas.sort(key=lambda x: x[0], reverse=True)\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x + s <= m:\n                dp[x] = min(dp[x], dp[x + s])\n        \n        # Add an antenna at position 0 with scope 0\n        dp[x] = min(dp[x], x + 0)\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    ants = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        ants.append((x, s))\n    \n    # Add an antenna at position 0 with scope 0\n    ants.insert(0, (0, 0))\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m, -1, -1):\n        for _, s in ants:\n            if x < s:\n                continue\n            u = max(x - s - 1, 0)\n            dp[x] = min(dp[x], u + dp[m - s])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "import sys\n\ndef read_input():\n    n, m = map(int, sys.stdin.readline().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, sys.stdin.readline().split())\n        antennas.append((x, s))\n    return n, m, antennas\n\ndef solve(n, m, antennas):\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        if x == m:\n            continue\n        \n        for _, s in antennas:\n            if x + s > m:\n                break\n            \n            if x + s >= x:\n                dp[x] = min(dp[x], dp[x + s])\n            \n            for i in range(x + 1, m + 1):\n                if i <= x + s:\n                    dp[i] = min(dp[i], dp[x] + i - x - 1)\n    \n    return dp[0]\n\ndef main():\n    n, m, antennas = read_input()\n    result = solve(n, m, antennas)\n    print(result)\n\nif True:\n    main()",
    "def solve():\n    import sys\n    input=sys.stdin.read\n    data=input().split()\n    n=int(data[0])\n    m=int(data[1])\n    antennas=[]\n    for _ in range(n):\n        x,s=map(int,data[2:])\n        antennas.append((x,s))\n    antennas.sort(key=lambda x:x[0])\n    dp=[float('inf')]*(m+1)\n    dp[m]=0\n    for x in range(m-1,-1,-1):\n        for _,s in antennas:\n            if x<s:\n                continue\n            u=x-s-1\n            if u>=0:\n                dp[x]=min(dp[x],u+dp[m-s])\n            else:\n                dp[x]=min(dp[x],dp[m])\n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n\n    def read_input():\n        return map(int, sys.stdin.read().split())\n\n    def main():\n        n, m = read_input()\n        antennas = []\n        for _ in range(n):\n            x, s = read_input()\n            antennas.append((x, s))\n\n        # Sort antennas by their starting point in descending order\n        antennas.sort(key=lambda x: x[0], reverse=True)\n\n        dp = [float('inf')] * (m + 1)\n        dp[m] = 0\n\n        for x in range(m, -1, -1):\n            if x == m:\n                continue\n\n            # Check if x+1 is initially covered\n            if x + 1 <= m:\n                dp[x] = min(dp[x], dp[x + 1])\n\n            # Consider all antennas and their initial intervals\n            for _, s in antennas:\n                if x < s:\n                    u = s - x - 1\n                    dp[x] = min(dp[x], u + dp[m - s + u])\n\n        print(dp[0])\n\n    if True:\n        main()",
    "def solve(n, m):\n    # Initialize dp array where dp[x] represents the minimum cost to cover all positions from x to m inclusive\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Iterate over positions in reverse order\n    for x in range(m - 1, -1, -1):\n        # Default transition: cover all positions from x to m\n        dp[x] = m - x\n        \n        # Check if position x + 1 is initially covered\n        if x + 1 <= m:\n            dp[x] = min(dp[x], dp[x + 1])\n        \n        # Consider all antennas and their initial intervals [l_i; r_i]\n        for i in range(n):\n            l_i, r_i = x - s[i], x + s[i]\n            if x < l_i:\n                u = l_i - x - 1\n                dp[x] = min(dp[x], u + dp[m - r_i - u])\n    \n    return dp[0]\n\n# Read input\nn, m = map(int, input().split())\nantennas = []\nfor _ in range(n):\n    x, s = map(int, input().split())\n    antennas.append((x, s))\n\n# Solve the problem\nprint(solve(n, m))",
    "def solve():\n    n, m = map(int, input().split())\n    positions = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        positions.append((x, s))\n    \n    # Sort positions by x in descending order\n    positions.sort(key=lambda p: p[0], reverse=True)\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x, s in positions:\n        for i in range(x, m + 1):\n            if i == x:\n                dp[i] = min(dp[i], dp[x + s])\n            else:\n                dp[i] = min(dp[i], dp[i - 1] + max(0, x - i + s))\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "import sys\nfrom typing import *\ninput = sys.stdin.read\ndata = input().split()\ndef solve():\n    n, m = map(int, data)\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, data[n:])\n        antennas.append((x, s))\n    antennas.sort(key=lambda x: x[0])\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    for x in range(m, -1, -1):\n        if x == m:\n            continue\n        for _, s in antennas:\n            if x + s > m:\n                break\n            dp[x] = min(dp[x], dp[x + s] + 1)\n    return dp[0]\nif True:\n    solve()",
    "import sys\nfrom typing import *\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, sys.stdin.readline().split())\n        antennas.append((x, s))\n    \n    # Add an antenna at position 0 with scope 0\n    antennas.insert(0, (0, 0))\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x >= s:\n                dp[x] = min(dp[x], dp[x + s])\n            else:\n                for i, (l, r) in enumerate(antennas):\n                    if x < l:\n                        u = (l - x - 1)\n                        dp[x] = min(dp[x], u + dp[m - r + u])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve(n, m):\n    def dp(x):\n        if x == m:\n            return 0\n        res = m - x\n        for i in range(n):\n            l, r = x + 1, x + 1 + s[i]\n            if l <= r:\n                res = min(res, dp(r) + l - x)\n        return res\n    \n    return dp(0)\n\n# Read input\nn, m = map(int, input().split())\ns = list(map(int, input().split()))\n\n# Solve and print output\nprint(solve(n, m))",
    "import sys\n\ndef solve(n, m, antennas):\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        if x == 0:\n            continue\n        \n        # Default transition\n        dp[x] = min(dp[x], m - x)\n        \n        # Consider all antennas\n        for i in range(n):\n            l, r = antennas[i]\n            if x < l:\n                u = l - x - 1\n                dp[x] = min(dp[x], u + dp[m - r])\n    \n    return dp[0]\n\ndef main():\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = data[2:]\n    print(solve(n, m, antennas))\n\nif True:\n    main()",
    "def solve():\n    n, m = map(int, input().split())\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Add an antenna at position 0 with scope 0\n    for _ in range(n):\n        x, s = map(int, input().split())\n        dp[x] = min(dp[x], dp[m])\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m - 1, -1, -1):\n        for i in range(n):\n            l, r = map(int, input().split())\n            if x < l:\n                u = (l - x - 1)\n                dp[x] = min(dp[x], u + dp[m - r])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def main():\n    input_data = input().split()\n    n, m = int(input_data[0]), int(input_data[1])\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by their starting point in descending order\n    antennas.sort(key=lambda x: x[0], reverse=True)\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x >= s:\n                dp[x] = min(dp[x], dp[x + s] + s)\n    \n    print(dp[0])\n\nif True:\n    main()",
    "def solve(input_data):\n    n, m = map(int, input_data.split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input_data.split()[1:])\n        antennas.append((x, s))\n    \n    # Sort antennas by their starting point in descending order\n    antennas.sort(key=lambda x: x[0], reverse=True)\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x + s <= m:\n                dp[x] = min(dp[x], dp[x + s])\n        \n        # Add an antenna at position 0 with scope 0\n        dp[x] = min(dp[x], x + 0)\n    \n    return dp[0]\n\n# Read input data\ninput_data = input()\n\n# Solve the problem\noutput = solve(input_data)\n\n# Print the output\nprint(output)",
    "def solve():\n    import sys\n    input = sys.stdin.read\n\n    def read_int():\n        return int(input().strip())\n\n    def read_ints():\n        return list(map(int, input().split()))\n\n    n, m = read_ints()\n    antennas = []\n    for _ in range(n):\n        x, s = read_ints()\n        antennas.append((x, s))\n\n    # Add an antenna at position 0 with scope 0\n    antennas.insert(0, (0, 0))\n\n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n\n    # Compute dp values in decreasing order of x\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x < s:\n                continue\n            u = max(x - s - 1, 0)\n            dp[x] = min(dp[x], u + dp[m - s])\n\n    print(dp[0])\n\nif True:\n    solve()",
    "import sys\nfrom typing import *\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, sys.stdin.readline().split())\n        antennas.append((x, s))\n    \n    # Add an antenna at position 0 with scope 0\n    antennas.insert(0, (0, 0))\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x >= s:\n                dp[x] = min(dp[x], dp[x + s])\n            else:\n                for i, (l, r) in enumerate(antennas):\n                    if x < l:\n                        u = (l - x - 1)\n                        dp[x] = min(dp[x], u + dp[m - r + u])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    \n    n, m = data[:2]\n    antennas = [(data[i], data[i+1]) for i in range(2, 2*n, 2)]\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x + s <= m:\n                dp[x] = min(dp[x], dp[x+s])\n        \n        if x + 1 < m and dp[x+1] != float('inf'):\n            for _, s in antennas:\n                if x + s + 1 <= m:\n                    dp[x] = min(dp[x], dp[x+s+1] + (m - x - 1))\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "from typing import *\nimport collections\n\ndef solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by their starting point in descending order\n    antennas.sort(key=lambda x: x[0], reverse=True)\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Process each antenna in descending order\n    for x, s in antennas:\n        # Update dp values for positions covered by this antenna\n        for i in range(x + s, m + 1):\n            dp[i] = min(dp[i], dp[x] + s)\n    \n    # Print the result\n    print(dp[0])\n\nif True:\n    solve()",
    "import sys\n\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, sys.stdin.readline().split())\n        antennas.append((x, s))\n    \n    # Add an antenna at position 0 with scope 0\n    antennas.insert(0, (0, 0))\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x >= s:\n                dp[x] = min(dp[x], dp[x + s] + 1)\n    \n    return dp[0]\n\n\nif True:\n    print(solve())",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    \n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by their starting point in descending order\n    antennas.sort(key=lambda x: x[0], reverse=True)\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x >= s:\n                dp[x] = min(dp[x], dp[x + s])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve(n, m, antennas):\n    # Initialize dp array where dp[x] represents the minimum cost to cover positions from x to m\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Add an antenna at position 0 with scope 0\n    for x, s in antennas:\n        dp[x] = 0\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m - 1, -1, -1):\n        # Default transition\n        dp[x] = m - x\n        \n        # Check if position x + 1 is initially covered\n        if dp[x + 1] != float('inf'):\n            dp[x] = min(dp[x], dp[x + 1])\n        \n        # Consider all antennas and their initial intervals\n        for i in range(n):\n            l, r = antennas[i]\n            if x < l:\n                u = l - x - 1\n                dp[x] = min(dp[x], u + dp[m - r])\n    \n    return dp[0]\n\n# Read input\nn, m = map(int, input().split())\nantennas = []\nfor _ in range(n):\n    x, s = map(int, input().split())\n    antennas.append((x, s))\n\n# Solve the problem\nprint(solve(n, m, antennas))",
    "def solve():\n    import sys\n    \n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    \n    n, m = data[:2]\n    antennas = [(data[i], data[i+1]) for i in range(2, 2*n, 2)]\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x + s <= m:\n                dp[x] = min(dp[x], dp[x+s])\n        \n        if x + 1 < m and dp[x+1] != float('inf'):\n            for _, s in antennas:\n                if x + s + 1 <= m:\n                    dp[x] = min(dp[x], dp[x+s+1] + (m - x - 1))\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "import sys\nfrom typing import List\n\ndef main():\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i], data[i+1]) for i in range(2, 2*n, 2)]\n    \n    def dp(x):\n        if x == m:\n            return 0\n        min_cost = m - x\n        for _, s in antennas:\n            if x < s:\n                u = s - x - 1\n                min_cost = min(min_cost, u + dp(m - s))\n        return min_cost\n    \n    print(dp(0))\n\nif True:\n    main()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Add an antenna at position 0 with scope 0\n    antennas.append([0, 0])\n    \n    # Sort antennas by their leftmost position\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize DP array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute DP values in decreasing order of leftmost position\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x + s <= m:\n                dp[x] = min(dp[x], dp[x + s] + s)\n    \n    return dp[0]\n\nif True:\n    print(solve())",
    "import sys\n\ndef solve():\n    # Read input\n    n, m = map(int, sys.stdin.readline().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, sys.stdin.readline().split())\n        antennas.append((x, s))\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x + s <= m:\n                dp[x] = min(dp[x], dp[x + s])\n        \n        # Add an antenna at position 0 with scope 0\n        dp[x] = min(dp[x], dp[x + 1])\n    \n    # Print result\n    print(dp[0])\n\nif True:\n    solve()",
    "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    n, m = map(int, input_data[:2])\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input_data[2:])\n        antennas.append((x, s))\n    \n    # Add an antenna at position 0 with scope 0\n    antennas.insert(0, (0, 0))\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x >= s:\n                dp[x] = min(dp[x], dp[x + s] + 1)\n    \n    return dp[0]\n\nif True:\n    print(solve())",
    "import sys\nfrom typing import List, Tuple\n\ndef solve(n: int, m: int, antennas: List[Tuple[int, int]]) -> int:\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        if x == 0:\n            continue\n        \n        for _, s in antennas:\n            if x + s <= m:\n                dp[x] = min(dp[x], dp[x + s])\n        \n        for i in range(x + 1, m + 1):\n            for _, s in antennas:\n                if x < s and i >= x + s:\n                    dp[i] = min(dp[i], dp[x] + i - x - s)\n    \n    return dp[0]\n\nif True:\n    input_data = sys.stdin.read().strip()\n    data = list(map(int, input_data.split()))\n    n, m = data[:2]\n    antennas = data[2:]\n    result = solve(n, m, antennas)\n    print(result)",
    "import sys\n\ndef solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Add an antenna at position 0 with scope 0\n    antennas.insert(0, (0, 0))\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x < s:\n                continue\n            u = max(x - s - 1, 0)\n            dp[x] = min(dp[x], u + dp[m - s])\n    \n    return dp[0]\n\nif True:\n    print(solve())",
    "from typing import *\nfrom collections import *\n\ndef solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Add an antenna at position 0 with scope 0\n    antennas.insert(0, (0, 0))\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x >= s:\n                dp[x] = min(dp[x], dp[x + s])\n            else:\n                for i, (l, r) in enumerate(antennas):\n                    if x < l:\n                        u = (l - x - 1)\n                        dp[x] = min(dp[x], u + dp[m - r + u])\n    \n    print(dp[0])\n\nif True:\n    solve()"
  ],
  "rewards": [
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0
  ],
  "train rewards": [
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.045454545454545456,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0
  ],
  "time": [
    8.35838270187378,
    25.46368980407715,
    40.62940192222595,
    57.86057233810425,
    73.8906238079071,
    83.56848549842834,
    93.58398628234863,
    99.51680445671082,
    107.69306516647339,
    123.91747808456421,
    134.87049412727356,
    154.32409572601318,
    169.09342432022095,
    187.9172785282135,
    196.99147415161133,
    205.01244950294495,
    222.9766228199005,
    241.13427090644836,
    260.3672585487366,
    269.5390672683716,
    277.5906708240509,
    287.5260350704193,
    307.8792860507965,
    314.7485775947571,
    333.05443692207336,
    347.7620117664337,
    356.5777909755707,
    366.43804836273193,
    373.907434463501,
    388.6720721721649,
    395.42279386520386,
    399.35228085517883,
    407.36550879478455,
    415.3115441799164,
    422.9774489402771,
    432.9982748031616,
    442.5274221897125,
    451.058899641037,
    458.84758949279785,
    476.46738290786743,
    491.61765909194946,
    498.366003036499,
    506.33226132392883,
    524.3059163093567,
    540.9627640247345,
    547.7745199203491,
    564.9438028335571,
    572.3582093715668,
    581.7617208957672,
    591.7293529510498,
    611.3433725833893
  ],
  "sample times": 51
}