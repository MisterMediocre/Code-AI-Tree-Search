{
  "prompt": "\nQUESTION:\nYou have a set of items, each having some integer weight not greater than $8$. You denote that a subset of items is good if total weight of items in the subset does not exceed $W$.\n\nYou want to calculate the maximum possible weight of a good subset of items. Note that you have to consider the empty set and the original set when calculating the answer.\n\n\n-----Input-----\n\nThe first line contains one integer $W$ ($0 \\le W \\le 10^{18}$) \u2014 the maximum total weight of a good subset.\n\nThe second line denotes the set of items you have. It contains $8$ integers $cnt_1$, $cnt_2$, ..., $cnt_8$ ($0 \\le cnt_i \\le 10^{16}$), where $cnt_i$ is the number of items having weight $i$ in the set.\n\n\n-----Output-----\n\nPrint one integer \u2014 the maximum possible weight of a good subset of items.\n\n\n-----Examples-----\nInput\n10\n1 2 3 4 5 6 7 8\n\nOutput\n10\n\nInput\n0\n0 0 0 0 0 0 0 0\n\nOutput\n0\n\nInput\n3\n0 4 1 0 0 9 8 3\n\nOutput\n3\n\nTUTORIAL:\n1132E - Knapsack\n\nLet's consider the optimal answer. Suppose we take c\u1d62 items of weight i.\n\nLet L be the least common multiple of all weights (that is 840). Then we may represent c\u1d62 as c\u1d62 = \u230aL / i\u230b\u00b7p\u1d62 + q\u1d62, where 0 \u2264 q < \u230aL / i\u230b. Let\u2019s do the following trick: we will take q\u1d62 items of weight i, and all the remaining items of this weight can be merged into some items of weight L.\n\nThen we can write a brute force solution that picks less than \u230aL / i\u230b items of each weight, transforms the remaining ones into items of weight L as much as possible, and when we fix the whole subset, adds maximum possible number of items of weight L to the answer.\n\nThis works in something like \u220f\u208d\u1d62\u208c\u2081 \u209c\u2092 \u2088\u208e \u230aL / i\u230b = L\u2078 / 8! operations, which is too much.\n\nHow can we speed it up? Rewrite it using dynamic programming! When we have fixed the number of items we take from x first sets, the only two things that matter now are the current total weight of taken items and the number of items of weight L we can use; and it\u2019s obvious that the more items of weight L we can use, the better. So let\u2019s write the following dynamic programming solution: dp[x][y] \u2014 maximum number of items of weight L we can have, if we processed first x types of items, and current total weight is y. Note that the second dimension should have size 8L.\n\n\nInstructions:\n\n\nYou are a Python3 code generator.  Output **only** valid Python code. No explanations, no commentary, no filenames, no Markdown formatting. You will spit out a code block that can be pasted into any script. It must read the input, execute the logic and then print the output. Ensure that you invoke the main() or solve() function at the end if you're writing your code inside them.\nANSWER:\n",
  "codes": [
    "def solve(W, cnt):\n    L = 840\n    n = len(cnt)\n    dp = [[0 for _ in range(8 * L)] for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        for j in range(L):\n            if i == 0:\n                dp[i][j] = 0\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][(j // L) * L + min(j % L, cnt[i - 1])])\n    \n    return dp[n][W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "import sys\n\ndef solve():\n    W = int(sys.stdin.readline())\n    cnts = list(map(int, sys.stdin.readline().split()))\n    \n    def dp(x, y):\n        if x == 0:\n            return 0\n        \n        if dp[x-1][y] >= dp[x][y]:\n            return dp[x-1][y]\n        \n        if y >= cnts[x-1]:\n            return max(dp[x-1][y], dp[x-1][y-cnts[x-1]] + cnts[x-1])\n        \n        return dp[x-1][y]\n    \n    return dp(8, W)\n\nif True:\n    print(solve())",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    W = data[0]\n    cnts = data[1:]\n    \n    def dp(x, y):\n        if x == 0:\n            return 0\n        if y >= 8 * cnts[x-1]:\n            return dp(x-1, y)\n        else:\n            return max(dp(x-1, y), dp(x-1, y+8*cnts[x-1]) + cnts[x-1])\n    \n    print(dp(8, 0))\n\nif True:\n    solve()",
    "from typing import *\nimport sys\n\ndef solve(W: int, cnts: List[int]) -> int:\n    MOD = 10**9 + 7\n    N = len(cnts)\n    L = 840\n    dp = [[0 for _ in range(L)] for _ in range(N+1)]\n    \n    for i in range(1, N+1):\n        for j in range(L):\n            dp[i][j] = dp[i-1][j]\n            if j >= cnts[i-1]:\n                dp[i][j] = max(dp[i][j], dp[i-1][j-cnts[i-1]] + cnts[i-1])\n    \n    return dp[N][L]\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    W = data[0]\n    cnts = data[1:]\n    \n    def knapsack(W, cnts):\n        n = len(cnts)\n        dp = [[0 for _ in range(8 * W + 1)] for _ in range(n + 1)]\n        \n        for i in range(1, n + 1):\n            for j in range(8 * W + 1):\n                dp[i][j] = dp[i - 1][j]\n                \n                if j >= cnts[i - 1]:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - cnts[i - 1]] + cnts[i - 1])\n        \n        return dp[n][8 * W]\n    \n    print(knapsack(W, cnts))\n\nif True:\n    main()",
    "def solve(W, cnts):\n    MOD = 10**9 + 7\n    N = len(cnts)\n    L = 8 * N\n    \n    # dp[i][j] - max number of items of weight L we can have, if we processed first i types of items, and current total weight is j\n    dp = [[0] * (L + 1) for _ in range(N + 1)]\n    \n    for i in range(1, N + 1):\n        for j in range(L + 1):\n            dp[i][j] = dp[i - 1][j]\n            \n            if j >= cnts[i - 1]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - cnts[i - 1]] + cnts[i - 1])\n    \n    return dp[N][L]\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve():\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    \n    # Calculate the least common multiple of all weights\n    lcm = 1\n    for cnt in cnts:\n        lcm *= cnt\n    \n    # Initialize the DP table\n    dp = [[0] * (lcm // 8 + 1) for _ in range(9)]\n    \n    # Fill the DP table\n    for i in range(1, 9):\n        for j in range(lcm // 8 + 1):\n            if j >= cnts[i-1]:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-cnts[i-1]] + cnts[i-1])\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    # The answer is the maximum value in the last row of the DP table\n    print(max(dp[8]))\n\nif True:\n    solve()",
    "import sys\nfrom typing import *\ninput = sys.stdin.read\nreadline = sys.stdin.readline\nsys.setrecursionlimit(10**6)\n\ndef solve():\n    W = int(readline())\n    cnts = list(map(int, readline().split()))\n    \n    def dp(x, y):\n        if x == 0:\n            return 0\n        if y >= W:\n            return y // W\n        \n        if dp[x-1][y] >= dp[x-1][y+cnts[x-1]]:\n            return dp[x-1][y]\n        \n        return max(dp[x-1][y], dp[x-1][y+cnts[x-1]] + dp[x-1][y+cnts[x-1]])\n    \n    print(dp(len(cnts), 0))\n\nif True:\n    solve()",
    "def solve(W, cnt):\n    MOD = 10**9 + 7\n    N = len(cnt)\n    L = 840\n    dp = [[0 for _ in range(L+1)] for _ in range(N+1)]\n    \n    for i in range(1, N+1):\n        for j in range(L+1):\n            dp[i][j] = dp[i-1][j]\n            if j >= cnt[i-1]:\n                dp[i][j] = max(dp[i][j], dp[i-1][j-cnt[i-1]] + cnt[i-1])\n    \n    return dp[N][W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve(W, cnt):\n    import math\n    L = math.lcm(1, *cnt)\n    n = len(cnt)\n    \n    dp = [[0 for _ in range(L)] for _ in range(n+1)]\n    \n    for i in range(1, n+1):\n        for j in range(L):\n            dp[i][j] = max(dp[i-1][j], dp[i-1][(j-cnt[i-1])%L] + cnt[i-1])\n    \n    return dp[n][W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve(W, cnts):\n    L = 8 * 8 * 8 * 8 * 8 * 8 * 8 * 8\n    dp = [[0 for _ in range(L + 1)] for _ in range(9)]\n    \n    for i in range(1, 9):\n        for j in range(L + 1):\n            dp[i][j] = dp[i - 1][j]\n            \n            if j >= cnts[i - 1]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - cnts[i - 1]] + cnts[i - 1])\n                \n    return dp[8][W]\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def max_good_subset_weight(W, cnt):\n    MOD = 10**9 + 7\n    N = 8\n    L = 840\n    \n    # Initialize DP table\n    dp = [[0 for _ in range(L)] for _ in range(N+1)]\n    \n    # Base case: dp[0][0] = 1\n    dp[0][0] = 1\n    \n    # Fill DP table\n    for i in range(1, N+1):\n        for j in range(L):\n            dp[i][j] = dp[i-1][j]\n            if j >= cnt[i-1]:\n                dp[i][j] += dp[i-1][(j-cnt[i-1])//L]*MOD\n                dp[i][j] %= MOD\n    \n    # Find the maximum weight of a good subset\n    ans = 0\n    for j in range(L):\n        ans = max(ans, dp[N][j])\n    \n    return ans\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Solve the problem\nprint(max_good_subset_weight(W, cnt))",
    "def solve(W, cnts):\n    import math\n    MOD = 10**9 + 7\n    \n    # Calculate the least common multiple of all weights\n    L = math.lcm(1, *cnts)\n    \n    # Initialize the DP table\n    dp = [[0 for _ in range(L+1)] for _ in range(len(cnts)+1)]\n    \n    # Fill the DP table\n    for i in range(1, len(cnts)+1):\n        for j in range(1, L+1):\n            dp[i][j] = dp[i-1][j]\n            if j >= cnts[i-1]:\n                dp[i][j] = max(dp[i][j], dp[i-1][j-cnts[i-1]] + cnts[i-1])\n    \n    # The result is the maximum number of items of weight L we can have\n    return dp[len(cnts)][L]\n\n# Read input\nW = int(input())\ncnts = list(map(int, input().split()))\n\n# Print the output\nprint(solve(W, cnts))",
    "def solve(W, counts):\n    MOD = 10**9 + 7\n    N = len(counts)\n    \n    # Calculate the least common multiple of all weights\n    L = 1\n    for i in range(1, 9):\n        L *= i\n    \n    # Initialize DP table\n    dp = [[0] * (N + 1) for _ in range(L + 1)]\n    \n    # Fill DP table\n    for i in range(N + 1):\n        for j in range(L + 1):\n            if i == 0:\n                dp[j][i] = 0\n            else:\n                dp[j][i] = max(dp[j][i], dp[j][i - 1])\n                if j >= L // counts[i - 1]:\n                    dp[j][i] = max(dp[j][i], dp[j - L // counts[i - 1]][i - 1] + counts[i - 1])\n    \n    return dp[L][N]\n\n# Read input\nW = int(input())\ncounts = list(map(int, input().split()))\n\n# Solve and print the result\nprint(solve(W, counts))",
    "def solve(W, cnt):\n    L = 8 * 8 * 8 * 8 * 8 * 8 * 8 * 8\n    dp = [[0 for _ in range(L + 1)] for _ in range(9)]\n    \n    for i in range(1, 9):\n        for j in range(L + 1):\n            dp[i][j] = dp[i - 1][j]\n            \n            if j >= i * cnt[i - 1]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - i * cnt[i - 1]] + i)\n    \n    return dp[8][W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def main():\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    \n    # Calculate the least common multiple of all weights\n    lcm = 1\n    for cnt in cnts:\n        lcm *= cnt\n    \n    # Initialize the DP table\n    dp = [[0] * (lcm // 8 + 1) for _ in range(9)]\n    \n    # Fill the DP table\n    for i in range(1, 9):\n        for j in range(lcm // 8 + 1):\n            if j >= cnts[i-1]:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-cnts[i-1]] + cnts[i-1])\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    # Print the result\n    print(max(dp[8]))\n\nif True:\n    main()",
    "from typing import List\n\ndef solve(W: int, cnts: List[int]) -> int:\n    MOD = 10**9 + 7\n    N = len(cnts)\n    L = 8 * max(cnts)\n    \n    @cache\n    def dp(x: int, y: int) -> int:\n        if x == N:\n            return y <= L\n        if y > L:\n            return 0\n        \n        ans = dp(x + 1, y)\n        for i in range(1, min(L // y + 1, cnts[x]) + 1):\n            ans = (ans + dp(x + 1, y + i * L // y)) % MOD\n        return ans\n    \n    return dp(0, 0)\n\n# Example usage:\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W: int, cnts: list[int]) -> int:\n    MOD = 10**9 + 7\n    N = len(cnts)\n    L = 8 * max(cnts)\n    \n    @cache\n    def dp(x, y):\n        if x == N:\n            return 0\n        if y >= L:\n            return min(L - y, cnts[x])\n        \n        ans = dp(x + 1, y)\n        if cnts[x]:\n            ans = max(ans, dp(x + 1, y + cnts[x]))\n        return (ans + dp(x + 1, y)) % MOD\n    \n    return dp(0, 0)\n\n# Example usage:\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "def solve(W):\n    cnts = list(map(int, input().split()))\n    L = 8 * 8 * 8 * 8 * 8 * 8 * 8 * 8\n    dp = [[0 for _ in range(L + 1)] for _ in range(9)]\n    \n    for i in range(1, 9):\n        for j in range(L + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= cnts[i - 1]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - cnts[i - 1]] + cnts[i - 1])\n    \n    return dp[8][W]\n\nif True:\n    W = int(input())\n    print(solve(W))",
    "def solve():\n    from math import gcd\n    from functools import reduce\n    \n    def lcm(a, b):\n        return abs(a*b) // gcd(a, b)\n    \n    def max_weight(W, cnts):\n        n = len(cnts)\n        L = lcm(1, *cnts)\n        \n        @cache\n        def dp(x, y):\n            if x == 0:\n                return 0\n            if y >= L:\n                return min(y // L, cnts[x-1])\n            \n            ans = dp(x-1, y)\n            for i in range(min(L, y+1)):\n                ans = max(ans, dp(x-1, y-i) + cnts[x-1])\n            return ans\n        \n        return dp(n, W)\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(max_weight(W, cnts))",
    "def solve(W, cnt):\n    MOD = int(1e9+7)\n    N = len(cnt)\n    L = 840\n    dp = [[0 for _ in range(L)] for _ in range(N+1)]\n    \n    for i in range(1, N+1):\n        for j in range(L):\n            dp[i][j] = dp[i-1][j]\n            if j >= cnt[i-1]:\n                dp[i][j] = max(dp[i][j], dp[i-1][j-cnt[i-1]] + cnt[i-1])\n    \n    return dp[N][W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve(W, cnt):\n    MOD = 998244353\n    N = 8\n    L = 840\n    dp = [[0 for _ in range(L)] for _ in range(N+1)]\n    \n    for i in range(1, N+1):\n        for j in range(L):\n            if j >= cnt[i-1]:\n                dp[i][j] = max(dp[i][j], dp[i-1][j-cnt[i-1]] + cnt[i-1])\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    return dp[N][W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve():\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    \n    # Calculate the least common multiple of all weights\n    L = 1\n    for i in range(1, 9):\n        L *= i\n    \n    # Initialize the DP table\n    dp = [[0] * (L + 1) for _ in range(9)]\n    \n    # Fill the DP table\n    for i in range(9):\n        for j in range(L + 1):\n            if j >= cnt[i]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - cnt[i]] + cnt[i])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    # The answer is the maximum value in the last row of the DP table\n    print(max(dp[8]))\n\nif True:\n    solve()",
    "def solve(W, cnt):\n    import math\n    MOD = 10**9 + 7\n    N = 8\n    L = math.lcm(1, *cnt)\n    dp = [[0 for _ in range(L+1)] for _ in range(N+1)]\n    \n    for i in range(1, N+1):\n        for j in range(L+1):\n            dp[i][j] = dp[i-1][j]\n            if j >= cnt[i-1]:\n                dp[i][j] = max(dp[i][j], dp[i-1][j-cnt[i-1]] + cnt[i-1])\n    \n    return dp[N][W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve(W, cnt):\n    import math\n    \n    # Calculate the least common multiple of all weights\n    lcm = math.lcm(1, *cnt)\n    \n    # Initialize the DP table\n    dp = [[0 for _ in range(lcm + 1)] for _ in range(len(cnt) + 1)]\n    \n    # Fill the DP table\n    for i in range(1, len(cnt) + 1):\n        for j in range(1, lcm + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= cnt[i - 1]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - cnt[i - 1]] + cnt[i - 1])\n    \n    # The result is the maximum number of items of weight L we can have\n    return dp[len(cnt)][lcm]\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Print the output\nprint(solve(W, cnt))",
    "def solve(W, cnt):\n    import math\n    N = len(cnt)\n    MOD = int(1e9+7)\n    \n    # Calculate the least common multiple of all weights\n    L = math.lcm(*range(1, 9))\n    \n    # Initialize the DP table\n    dp = [[0 for _ in range(L)] for _ in range(N+1)]\n    \n    # Base case: dp[0][0] = 1\n    dp[0][0] = 1\n    \n    # Fill the DP table\n    for i in range(1, N+1):\n        for j in range(L):\n            dp[i][j] = dp[i-1][j]\n            if j >= cnt[i-1]:\n                dp[i][j] += dp[i-1][(j-cnt[i-1])%L]\n                dp[i][j] %= MOD\n    \n    # The answer is the maximum value in the last row\n    return max(dp[N])\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Solve the problem\nprint(solve(W, cnt))",
    "import sys\nfrom collections import defaultdict\n\ndef solve():\n    W = int(sys.stdin.readline())\n    cnts = list(map(int, sys.stdin.readline().split()))\n    \n    # Calculate the least common multiple of all weights\n    lcm = 1\n    for cnt in cnts:\n        lcm *= cnt\n    \n    # Initialize the DP table\n    dp = defaultdict(lambda: defaultdict(int))\n    dp[0][0] = 0\n    \n    # Fill the DP table\n    for x in range(1, len(cnts) + 1):\n        for y in range(lcm // x):\n            for z in range(y + 1):\n                dp[x][y] = max(dp[x][y], dp[x - 1][z])\n                dp[x][y] = max(dp[x][y], dp[x - 1][y - z] + cnts[x - 1])\n    \n    # The answer is the maximum value in the last row of the DP table\n    return dp[len(cnts)][lcm // len(cnts)]\n\nif True:\n    print(solve())",
    "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    W = data[0]\n    cnts = data[1:]\n    \n    def knapsack(W, cnts):\n        n = len(cnts)\n        dp = [[0 for _ in range(8 * W + 1)] for _ in range(n + 1)]\n        \n        for i in range(1, n + 1):\n            for j in range(8 * W + 1):\n                dp[i][j] = dp[i - 1][j]\n                \n                if j >= cnts[i - 1]:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - cnts[i - 1]] + cnts[i - 1])\n        \n        return dp[n][8 * W]\n    \n    print(knapsack(W, cnts))\n\nif True:\n    main()",
    "import sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return abs(a*b) // gcd(a, b)\n\ndef solve(W, cnts):\n    N = len(cnts)\n    L = lcm(1, *cnts)\n    \n    dp = [[0 for _ in range(L+1)] for _ in range(N+1)]\n    \n    for i in range(1, N+1):\n        for j in range(L+1):\n            dp[i][j] = max(dp[i-1][j], dp[i-1][j-cnts[i-1]] + cnts[i-1])\n            \n    return dp[N][W]\n\nif True:\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    W = data[0]\n    cnts = data[1:]\n    print(solve(W, cnts))",
    "import sys\n\ndef solve(W, cnt):\n    MOD = 10**9 + 7\n    N = len(cnt)\n    L = 8 * N\n    \n    dp = [[0 for _ in range(L + 1)] for _ in range(N + 1)]\n    \n    for i in range(1, N + 1):\n        for j in range(L + 1):\n            dp[i][j] = dp[i - 1][j]\n            \n            if j >= cnt[i - 1]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - cnt[i - 1]] + cnt[i - 1])\n    \n    return dp[N][W]\n\nif True:\n    input = sys.stdin.read\n    data = input().split()\n    W = int(data[0])\n    cnt = list(map(int, data[1:]))\n    print(solve(W, cnt))",
    "def solve(W, cnt):\n    L = 840\n    n = len(cnt)\n    \n    # Initialize DP table\n    dp = [[0 for _ in range(8 * L)] for _ in range(n + 1)]\n    \n    # Base case: no items processed, total weight is 0\n    dp[0][0] = 0\n    \n    # Fill DP table\n    for i in range(1, n + 1):\n        for j in range(L):\n            dp[i][j] = max(dp[i - 1][j], dp[i - 1][(j - cnt[i - 1]) % L] + cnt[i - 1])\n    \n    # Find the maximum weight of a good subset\n    return dp[n][W]\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Solve and print the result\nprint(solve(W, cnt))",
    "import sys\nfrom typing import List\n\ndef solve(W: int, cnts: List[int]) -> int:\n    MOD = 10**9 + 7\n    N = len(cnts)\n    L = 840\n    dp = [[0 for _ in range(L)] for _ in range(N+1)]\n    \n    for i in range(1, N+1):\n        for j in range(L):\n            dp[i][j] = dp[i-1][j]\n            if j >= cnts[i-1]:\n                dp[i][j] = max(dp[i][j], dp[i-1][j-cnts[i-1]] + cnts[i-1])\n    \n    return dp[N][L]\n\nif True:\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    W = data[0]\n    cnts = data[1:]\n    print(solve(W, cnts))",
    "def solve(W, cnt):\n    L = 1\n    for i in range(1, 9):\n        L *= i\n    \n    dp = [[0] * (L + 1) for _ in range(9)]\n    \n    for i in range(9):\n        for j in range(L + 1):\n            if j >= cnt[i]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - cnt[i]] + cnt[i])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    return dp[8][W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve(W, cnt):\n    MOD = 10**9+7\n    N = len(cnt)\n    L = 840\n    dp = [[0]*(N*L+1) for _ in range(N+1)]\n    \n    for i in range(1, N+1):\n        for j in range(L*N+1):\n            dp[i][j] = dp[i-1][j]\n            if j >= cnt[i-1]:\n                dp[i][j] = max(dp[i][j], dp[i-1][j-cnt[i-1]] + cnt[i-1])\n    \n    return dp[N][W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "import sys\n\ndef read_input():\n    return map(int, sys.stdin.read().split())\n\ndef solve(W, cnt):\n    L = 840\n    n = len(cnt)\n    \n    dp = [[0 for _ in range(L)] for _ in range(n+1)]\n    \n    for i in range(1, n+1):\n        for j in range(L):\n            dp[i][j] = max(dp[i-1][j], dp[i-1][(j - cnt[i-1]) % L] + cnt[i-1])\n    \n    return dp[n][W]\n\nif True:\n    W, cnt = read_input()\n    print(solve(W, cnt))",
    "def main():\n    # Read input\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    \n    # Calculate L\n    L = 8 * 8 * 8 * 8 * 8 * 8 * 8 * 8\n    \n    # Initialize DP table\n    dp = [[0 for _ in range(L + 1)] for _ in range(9)]\n    \n    # Fill DP table\n    for i in range(9):\n        for j in range(L + 1):\n            if j >= cnts[i]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - cnts[i]] + cnts[i])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    # Print result\n    print(max(dp[8]))\n\nif True:\n    main()",
    "def solve(W, items):\n    L = 8 * 8 * 8 * 8 * 8 * 8 * 8 * 8\n    dp = [[0 for _ in range(L + 1)] for _ in range(9)]\n    \n    for i in range(1, 9):\n        for j in range(L + 1):\n            if j >= items[i - 1]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - items[i - 1]] + items[i - 1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    return dp[8][W]\n\n# Read input\nW = int(input())\nitems = list(map(int, input().split()))\n\n# Solve and print output\nprint(solve(W, items))",
    "def solve(W, cnt):\n    L = 840\n    dp = [[0 for _ in range(8 * L)] for _ in range(len(cnt))]\n    \n    for i in range(len(cnt)):\n        for j in range(L):\n            if cnt[i] == 0:\n                continue\n            if j >= i * L // cnt[i]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - i * L // cnt[i]] + cnt[i])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    return dp[-1][-1]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "import sys\n\ndef solve():\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    \n    # Calculate the least common multiple of all weights\n    lcm = 1\n    for cnt in cnts:\n        lcm *= cnt\n    \n    # Initialize the DP table\n    dp = [[0] * (lcm // 8 + 1) for _ in range(9)]\n    \n    # Fill the DP table\n    for i in range(1, 9):\n        for j in range(lcm // 8 + 1):\n            if j >= cnts[i-1]:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-cnts[i-1]] + cnts[i-1])\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    # The answer is the maximum value in the last row of the DP table\n    print(max(dp[8]))\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    W = int(data[0])\n    cnts = list(map(int, data[1:]))\n\n    def dp(x, y):\n        if x == 0:\n            return 0\n        if y >= 8 * cnts[x - 1]:\n            return dp(x - 1, y)\n        else:\n            return max(dp(x - 1, y), dp(x - 1, y + 8 * cnts[x - 1]) + cnts[x - 1])\n\n    print(dp(8, 0))\n\nif True:\n    solve()",
    "def solve(W, cnt):\n    L = max(cnt)\n    dp = [[0 for _ in range(8 * L)] for _ in range(len(cnt))]\n    \n    for i in range(L):\n        for j in range(8 * L):\n            if j >= cnt[i]:\n                dp[0][j] = max(dp[0][j], dp[0][j - cnt[i]] + 1)\n    \n    for i in range(1, len(cnt)):\n        for j in range(8 * L):\n            for k in range(j // cnt[i]):\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - k * cnt[i]] + k)\n    \n    return dp[-1][-1]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "import sys\nfrom typing import *\nfrom collections import *\n\ndef solve(W: int, cnts: List[int]) -> int:\n    MOD = 10**9 + 7\n    N = len(cnts)\n    L = 840\n    dp = [[0 for _ in range(L)] for _ in range(N+1)]\n    \n    for i in range(1, N+1):\n        for j in range(L):\n            dp[i][j] = dp[i-1][j]\n            if j >= cnts[i-1]:\n                dp[i][j] = max(dp[i][j], dp[i-1][j-cnts[i-1]] + cnts[i-1])\n    \n    return dp[N][L]\n\nif True:\n    input = sys.stdin.read\n    data = input().split()\n    W = int(data[0])\n    cnts = list(map(int, data[1:]))\n    print(solve(W, cnts))",
    "def solve(W, cnt):\n    MOD = 10**18 + 7\n    N = 8\n    L = 840\n    dp = [[0 for _ in range(L)] for _ in range(N+1)]\n    \n    for i in range(1, N+1):\n        for j in range(L):\n            if j >= cnt[i-1]:\n                dp[i][j] = max(dp[i][j], dp[i-1][j-cnt[i-1]] + cnt[i-1])\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    return dp[N][W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve(W, cnt):\n    L = int(8 * 10**16)\n    dp = [[0 for _ in range(L + 1)] for _ in range(9)]\n    \n    for i in range(1, 9):\n        for j in range(L + 1):\n            dp[i][j] = dp[i - 1][j]\n            \n            if j >= i:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - i] + cnt[i - 1])\n    \n    return dp[8][W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve(W, cnts):\n    L = 840\n    dp = [[0 for _ in range(8 * L)] for _ in range(len(cnts) + 1)]\n    \n    for i in range(len(cnts)):\n        for j in range(L):\n            dp[i + 1][j] = max(dp[i + 1][j], dp[i][j])\n            if j >= cnts[i]:\n                dp[i + 1][j + cnts[i]] = max(dp[i + 1][j + cnts[i]], dp[i][j] + cnts[i])\n    \n    return dp[len(cnts)][W]\n\nif True:\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    print(solve(W, cnts))",
    "import sys\n\ndef solve(W, cnts):\n    MOD = 10**9 + 7\n    N = len(cnts)\n    \n    # Calculate the least common multiple of all weights\n    L = 1\n    for i in range(1, 9):\n        L *= i\n    \n    # Initialize the DP table\n    dp = [[0] * (N + 1) for _ in range(L + 1)]\n    \n    # Fill the DP table\n    for i in range(N + 1):\n        for j in range(L + 1):\n            if i == 0:\n                dp[j][i] = 0\n            else:\n                dp[j][i] = max(dp[j][i], dp[j][i - 1])\n                if j >= cnts[i - 1]:\n                    dp[j][i] = max(dp[j][i], dp[(j - cnts[i - 1]) // L][i - 1] + cnts[i - 1])\n    \n    return dp[L][N]\n\nif True:\n    input = sys.stdin.read\n    data = input().split()\n    W = int(data[0])\n    cnts = list(map(int, data[1:]))\n    print(solve(W, cnts))",
    "def solve(W, cnt):\n    MOD = 10**9 + 7\n    L = 840\n    dp = [[0 for _ in range(8 * L)] for _ in range(len(cnt) + 1)]\n    \n    for i in range(len(cnt)):\n        for j in range(L):\n            if cnt[i] > 0:\n                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j])\n                if j >= i * L:\n                    dp[i + 1][j + i * L] = (dp[i + 1][j + i * L] + cnt[i]) % MOD\n    \n    return dp[len(cnt)][W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve(W, cnt):\n    L = 8 * 10**16\n    dp = [[0 for _ in range(L + 1)] for _ in range(9)]\n    \n    for i in range(1, 9):\n        for j in range(L + 1):\n            dp[i][j] = max(dp[i][j], dp[i - 1][j])\n            if j >= i * cnt[i - 1]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - i * cnt[i - 1]] + i)\n    \n    return dp[8][W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve():\n    W = int(input().strip())\n    cnts = list(map(int, input().strip().split()))\n    \n    # Calculate the least common multiple of all weights\n    lcm = 1\n    for cnt in cnts:\n        lcm *= cnt\n    \n    # Initialize the DP table\n    dp = [[0] * (lcm // 8 + 1) for _ in range(9)]\n    \n    # Fill the DP table\n    for i in range(1, 9):\n        for j in range(lcm // 8 + 1):\n            if j >= cnts[i-1]:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-cnts[i-1]] + cnts[i-1])\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    # The answer is the maximum value in the last row of the DP table\n    print(max(dp[8]))\n\nif True:\n    solve()",
    "def solve(W, cnt):\n    MOD = 10**9 + 7\n    \n    # Calculate the least common multiple of all weights\n    L = 1\n    for i in range(1, 9):\n        L *= i\n    \n    # Initialize the DP table\n    dp = [[0] * (L + 1) for _ in range(9)]\n    \n    # Fill the DP table\n    for i in range(1, 9):\n        for j in range(L + 1):\n            if j >= i:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j])\n                if j >= i * cnt[i]:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - i * cnt[i]] + cnt[i])\n    \n    # The result is the maximum number of items of weight L we can have\n    return dp[8][W]\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Print the output\nprint(solve(W, cnt))",
    "import sys\nfrom collections import *\n\ndef solve():\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    \n    # Calculate the least common multiple of all weights\n    lcm = 1\n    for cnt in cnts:\n        lcm = lcm * cnt // gcd(lcm, cnt)\n    \n    # Initialize the DP table\n    dp = [[0] * (lcm + 1) for _ in range(9)]\n    \n    # Fill the DP table\n    for i in range(9):\n        for j in range(lcm + 1):\n            if j >= cnts[i]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - cnts[i]] + cnts[i])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    # The answer is the maximum value in the last row of the DP table\n    print(max(dp[8]))\n\nif True:\n    solve()"
  ],
  "rewards": [
    0.06818181818181818,
    0.0,
    0.06818181818181818,
    0.0,
    0.0,
    0.022727272727272728,
    0.06818181818181818,
    0.0,
    0.11363636363636363,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.06818181818181818,
    0.0,
    0.0,
    0.0,
    0.0,
    0.11363636363636363,
    0.09090909090909091,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.09090909090909091,
    0.045454545454545456,
    0.0,
    0.0,
    0.11363636363636363,
    0.0,
    0.0,
    0.0,
    0.06818181818181818,
    0.06818181818181818,
    0.06818181818181818,
    0.0,
    0.0,
    0.09090909090909091,
    0.0,
    0.06818181818181818,
    0.0,
    0.06818181818181818,
    0.0,
    0.06818181818181818,
    0.0,
    0.0
  ],
  "train rewards": [
    0.11363636363636363,
    0.0,
    0.045454545454545456,
    0.0,
    0.0,
    0.045454545454545456,
    0.11363636363636363,
    0.0,
    0.18181818181818182,
    0.0,
    0.0,
    0.022727272727272728,
    0.11363636363636363,
    0.0,
    0.0,
    0.11363636363636363,
    0.0,
    0.0,
    0.0,
    0.0,
    0.18181818181818182,
    0.18181818181818182,
    0.0,
    0.13636363636363635,
    0.11363636363636363,
    0.0,
    0.11363636363636363,
    0.0,
    0.0,
    0.18181818181818182,
    0.045454545454545456,
    0.0,
    0.0,
    0.18181818181818182,
    0.0,
    0.0,
    0.0,
    0.11363636363636363,
    0.11363636363636363,
    0.045454545454545456,
    0.0,
    0.0,
    0.18181818181818182,
    0.0,
    0.11363636363636363,
    0.0,
    0.11363636363636363,
    0.0,
    0.11363636363636363,
    0.0,
    0.0
  ],
  "time": [
    8.064241170883179,
    13.588913440704346,
    18.906890153884888,
    25.44819402694702,
    36.012611865997314,
    54.697911739349365,
    61.76149535179138,
    66.36062860488892,
    75.40184044837952,
    82.145742893219,
    89.18547201156616,
    105.24394154548645,
    110.96841979026794,
    119.39946746826172,
    130.98873329162598,
    147.8956127166748,
    154.77301120758057,
    162.4236536026001,
    168.82520008087158,
    186.58357000350952,
    195.3993158340454,
    204.58897352218628,
    211.24558067321777,
    224.41392850875854,
    229.78041553497314,
    235.5142433643341,
    266.83379340171814,
    279.0326600074768,
    297.40100288391113,
    305.60086965560913,
    313.3177533149719,
    320.2904725074768,
    351.1899576187134,
    365.46400356292725,
    372.4296553134918,
    403.7163541316986,
    418.2435610294342,
    434.8288872241974,
    442.04168581962585,
    472.40217208862305,
    479.9977262020111,
    497.1186821460724,
    506.6025035381317,
    514.2503976821899,
    531.3086297512054,
    540.9931066036224,
    560.4993081092834,
    568.4392559528351,
    585.7999014854431,
    591.2824599742889,
    607.6237442493439
  ],
  "sample times": 51
}