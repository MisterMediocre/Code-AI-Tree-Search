{
  "prompt": "\nQUESTION:\nAndrey thinks he is truly a successful developer, but in reality he didn't know about the binary search algorithm until recently. After reading some literature Andrey understood that this algorithm allows to quickly find a certain number $x$ in an array. For an array $a$ indexed from zero, and an integer $x$ the pseudocode of the algorithm is as follows:\n\nBinarySearch(a, x)\n  left = 0\n  right = a.size()\n  while left < right\n    middle = (left + right) / 2\n    if a[middle] <= x then\n      left = middle + 1\n    else\n      right = middle\n  \n  if left > 0 and a[left - 1] == x then\n    return true\n  else\n    return false\n\nNote that the elements of the array are indexed from zero, and the division is done in integers (rounding down).\n\nAndrey read that the algorithm only works if the array is sorted. However, he found this statement untrue, because there certainly exist unsorted arrays for which the algorithm find $x$!\n\nAndrey wants to write a letter to the book authors, but before doing that he must consider the permutations of size $n$ such that the algorithm finds $x$ in them. A permutation of size $n$ is an array consisting of $n$ distinct integers between $1$ and $n$ in arbitrary order.\n\nHelp Andrey and find the number of permutations of size $n$ which contain $x$ at position $pos$ and for which the given implementation of the binary search algorithm finds $x$ (returns true). As the result may be extremely large, print the remainder of its division by $10^9+7$.\n\n\n-----Input-----\n\nThe only line of input contains integers $n$, $x$ and $pos$ ($1 \\le x \\le n \\le 1000$, $0 \\le pos \\le n - 1$) \u2014 the required length of the permutation, the number to search, and the required position of that number, respectively.\n\n\n-----Output-----\n\nPrint a single number\u00a0\u2014 the remainder of the division of the number of valid permutations by $10^9+7$.\n\n\n-----Examples-----\nInput\n4 1 2\n\nOutput\n6\n\nInput\n123 42 24\n\nOutput\n824071958\n\n\n\n-----Note-----\n\nAll possible permutations in the first test case: $(2, 3, 1, 4)$, $(2, 4, 1, 3)$, $(3, 2, 1, 4)$, $(3, 4, 1, 2)$, $(4, 2, 1, 3)$, $(4, 3, 1, 2)$.\n\nTUTORIAL:\nLet's simulate a binary search algorithm. Initially, we have the required position pos. For the next middle position in the binary search, we can determine exactly whether the next number at this position should be greater or less than x. For all other positions, the values can be either greater or less than x. As a result of the simulation of the algorithm, we have cntBig positions at which numbers must be greater than x and cntLess positions at which numbers must be less than x. Let the large numbers be hasBig, and the smaller ones hasLess. Now let's count the number of ways to place large numbers in cntBig positions using the formula C(hasBig, cntBig) \u00b7 cntBig!.\n\nLet's calculate in a similar way for smaller numbers, and the product of the resulting results will be the answer to the problem.\n\n\nInstructions:\n\n\nYou are a Python3 code generator.  Output **only** valid Python code. No explanations, no commentary, no filenames, no Markdown formatting. You will spit out a code block that can be pasted into any script. It must read the input, execute the logic and then print the output. Ensure that you invoke the main() or solve() function at the end if you're writing your code inside them.\nANSWER:\n",
  "codes": [
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    hasBig = 0\n    hasLess = 0\n    \n    # Count the number of larger and smaller numbers\n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    # Calculate the number of ways to place larger and smaller numbers\n    cntBig = hasBig // 2\n    cntLess = hasLess // 2\n    \n    # Calculate the number of valid permutations\n    ans = (comb(hasBig, cntBig) * comb(hasLess, cntLess)) % mod\n    \n    return ans\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nprint(solve(n, x, pos))",
    "from math import comb\n\ndef solve(n, x, pos):\n    hasBig = 0\n    hasLess = 0\n    \n    # Count the number of larger and smaller numbers\n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    # Calculate the number of ways to place larger and smaller numbers\n    bigWays = comb(hasBig, pos)\n    smallWays = comb(hasLess, n - pos - 1)\n    \n    # Return the total number of valid permutations modulo 10^9 + 7\n    return (bigWays * smallWays) % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "import math\n\ndef solve(n, x, pos):\n    # Calculate the number of ways to choose positions for larger numbers\n    hasBig = n - pos - 1\n    cntBig = pos + 1\n    resBig = math.comb(hasBig, cntBig)\n\n    # Calculate the number of ways to choose positions for smaller numbers\n    hasLess = n - pos - 1\n    cntLess = n - pos - 1\n    resLess = math.comb(hasLess, cntLess)\n\n    # The total number of valid permutations is the product of the two results\n    return (resBig * resLess) % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def bin_search_permutations(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of ways to choose positions for larger numbers\n    hasBig = n - pos\n    cntBig = min(pos, n - pos)\n    \n    # Calculate the number of ways to choose positions for smaller numbers\n    hasLess = pos\n    cntLess = min(pos, n - pos)\n    \n    # Calculate the number of ways to arrange larger numbers\n    C_hasBig = math.comb(hasBig, cntBig)\n    \n    # Calculate the number of ways to arrange smaller numbers\n    C_hasLess = math.comb(hasLess, cntLess)\n    \n    # Calculate the total number of valid permutations\n    total_permutations = (C_hasBig * cntBig % mod) * (C_hasLess * cntLess % mod) % mod\n    \n    return total_permutations\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Print the result\nprint(bin_search_permutations(n, x, pos))",
    "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, x, pos = data\n    ans = binomial_coefficient(n - pos, n - pos - 1) * binomial_coefficient(pos, pos - 1) % (10**9 + 7)\n    print(ans)\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, x, pos = data\n    ans = binomial_coefficient(n - pos, n - pos - 1) * binomial_coefficient(pos, pos - 1) % (10**9 + 7)\n    print(ans)\n\nif True:\n    main()",
    "import sys\nfrom math import comb\n\ndef solve(n, x, pos):\n    hasBig = 0\n    hasLess = 0\n    \n    # Count the number of larger and smaller numbers\n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    # Calculate the number of ways to place larger and smaller numbers\n    bigWays = comb(hasBig, pos)\n    smallWays = comb(hasLess, n - pos - 1)\n    \n    # Return the total number of valid permutations modulo 10^9 + 7\n    return (bigWays * smallWays) % (10**9 + 7)\n\n# Read input\ninput_data = sys.stdin.read().strip().split()\nn, x, pos = map(int, input_data)\n\n# Solve the problem\nresult = solve(n, x, pos)\nprint(result)",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, x, pos = data\n    \n    def bin_search(arr, x):\n        left, right = 0, len(arr)\n        while left < right:\n            mid = (left + right) // 2\n            if arr[mid] <= x:\n                left = mid + 1\n            else:\n                right = mid\n        return left > 0 and arr[left - 1] == x\n    \n    def count_permutations(n, x, pos):\n        if not bin_search(list(range(1, n + 1)), x):\n            return 0\n        \n        hasBig = sum(1 for i in range(pos + 1) if i >= x)\n        hasLess = sum(1 for i in range(pos + 1) if i < x)\n        \n        mod = 10**9 + 7\n        return (binomial(hasBig, pos) * binomial(hasLess, n - pos)) % mod\n    \n    def binomial(n, k):\n        if k > n // 2:\n            k = n - k\n        res = 1\n        for i in range(k):\n            res *= (n - i)\n            res //= (i + 1)\n        return res\n    \n    print(count_permutations(n, x, pos))\n\nif True:\n    solve()",
    "from math import comb\ndef solve(n, x, pos):\n    hasBig = 0\n    hasLess = 0\n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    cntBig = hasBig - pos\n    cntLess = hasLess - pos\n    \n    ans = comb(hasBig, cntBig) * comb(hasLess, cntLess)\n    \n    return ans % (10**9 + 7)\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "import math\nfrom typing import *\nMOD = 10**9 + 7\n\ndef solve(n: int, x: int, pos: int) -> int:\n    cntBig = 0\n    cntLess = 0\n    for i in range(n):\n        if i == pos:\n            continue\n        if a[i] > x:\n            cntBig += 1\n        elif a[i] < x:\n            cntLess += 1\n    \n    hasBig = cntBig\n    hasLess = cntLess\n    ans = 1\n    for i in range(1, hasBig + 1):\n        ans *= i\n        ans %= MOD\n    for i in range(1, hasLess + 1):\n        ans *= i\n        ans %= MOD\n    return ans\n\nif True:\n    n, x, pos = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(solve(n, x, pos))",
    "from math import comb, pow\n\ndef solve(n, x, pos):\n    hasBig = 0\n    hasLess = 0\n    \n    # Count the number of larger and smaller numbers\n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    # Calculate the number of ways to place larger and smaller numbers\n    bigWays = comb(hasBig, pos)\n    smallWays = comb(hasLess, n - pos - 1)\n    \n    # Calculate the total number of valid permutations\n    totalWays = bigWays * smallWays\n    \n    # Return the result modulo 10^9 + 7\n    return totalWays % (pow(10, 9) + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "import math\n\ndef bin_search_permutations(n, x, pos):\n    # Calculate the number of ways to choose positions for larger numbers\n    has_big = n - pos - 1\n    cnt_big = min(pos, has_big)\n    \n    # Calculate the number of ways to choose positions for smaller numbers\n    has_less = pos\n    cnt_less = min(n - pos - 1, has_less)\n    \n    # Calculate the number of ways to arrange larger numbers in their chosen positions\n    ways_has_big = math.comb(has_big, cnt_big)\n    \n    # Calculate the number of ways to arrange smaller numbers in their chosen positions\n    ways_has_less = math.comb(has_less, cnt_less)\n    \n    # Calculate the total number of valid permutations\n    total_permutations = ways_has_big * ways_has_less\n    \n    # Return the result modulo 10^9 + 7\n    return total_permutations % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Print the result\nprint(bin_search_permutations(n, x, pos))",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    cntBig = pos + 1\n    hasBig = n - pos - 1\n    ansBig = comb(hasBig, cntBig) * cntBig % MOD\n    \n    # Calculate the number of ways to place small numbers in cntLess positions\n    cntLess = n - pos - 1\n    hasLess = n - pos - 1\n    ansLess = comb(hasLess, cntLess) * cntLess % MOD\n    \n    # The total number of valid permutations is the product of the two results\n    return (ansBig * ansLess) % MOD\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "from math import comb\nMOD = 10**9 + 7\n\ndef solve(n, x, pos):\n    cntBig = 0\n    cntLess = 0\n    \n    # Count the number of positions where x should be greater than the current element\n    for i in range(pos):\n        if a[i] > x:\n            cntBig += 1\n    \n    # Count the number of positions where x should be less than the current element\n    for i in range(pos + 1, n):\n        if a[i] < x:\n            cntLess += 1\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    hasBig = cntBig\n    hasLess = n - cntBig - 1\n    \n    ans = comb(hasBig, cntBig) * comb(hasLess, cntLess)\n    \n    return ans % MOD\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Create the array a with elements from 1 to n\na = list(range(1, n + 1))\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    hasBig = 0\n    hasLess = 0\n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    mod = 10**9 + 7\n    bigComb = math.comb(hasBig, pos)\n    smallComb = math.comb(hasLess, n - pos - 1)\n    \n    return (bigComb * smallComb) % mod\n\nif True:\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    x = int(data[1])\n    pos = int(data[2])\n    print(solve(n, x, pos))",
    "from math import comb\n\ndef solve(n, x, pos):\n    # Calculate the number of ways to place large numbers in cntBig positions\n    cntBig = pos\n    hasBig = n - pos - 1\n    ans = comb(hasBig, cntBig) * cntBig\n    \n    # Calculate the number of ways to place small numbers in cntLess positions\n    cntLess = n - pos - 1\n    hasLess = n - pos - 1\n    ans *= comb(hasLess, cntLess) * cntLess\n    \n    # Return the remainder of the division of the answer by 10^9+7\n    return ans % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    mod = 1_000_000_007\n    hasBig = 0\n    hasLess = 0\n    \n    # Count the number of larger and smaller numbers\n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    # Calculate the number of ways to place larger and smaller numbers\n    cntBig = hasBig // 2\n    cntLess = hasLess // 2\n    \n    # Calculate the number of valid permutations\n    ans = (comb(hasBig, cntBig) * comb(hasLess, cntLess)) % mod\n    \n    return ans\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nprint(solve(n, x, pos))",
    "def solve(n, x, pos):\n    hasBig = pos\n    hasLess = n - pos - 1\n    \n    def binomial_coefficient(n, k):\n        if k > n // 2:\n            k = n - k\n        res = 1\n        for i in range(1, k + 1):\n            res *= (n - i + 1) // i\n        return res\n    \n    big_combinations = binomial_coefficient(hasBig, hasBig)\n    small_combinations = binomial_coefficient(hasLess, hasLess)\n    \n    return (big_combinations * small_combinations) % (10**9 + 7)\n\nif True:\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    x = int(data[1])\n    pos = int(data[2])\n    print(solve(n, x, pos))",
    "from math import comb\n\ndef main():\n    n, x, pos = map(int, input().split())\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    cntBig = pos + 1\n    hasBig = n - pos\n    \n    # Calculate the number of ways to place small numbers in cntLess positions\n    cntLess = n - pos - 1\n    hasLess = pos\n    \n    # Calculate the number of valid permutations\n    result = comb(hasBig, cntBig) * comb(hasLess, cntLess)\n    \n    # Print the result modulo 10^9+7\n    print(result % (10**9 + 7))\n\nif True:\n    main()",
    "def solve():\n    n, x, pos = map(int, input().split())\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    hasBig = n - pos\n    cntBig = pos + 1\n    ans = comb(hasBig, cntBig) * cntBig\n    \n    # Calculate the number of ways to place small numbers in cntLess positions\n    hasLess = n - pos - 1\n    cntLess = n - pos - 1\n    ans *= comb(hasLess, cntLess) * cntLess\n    \n    # Print the result modulo 10^9+7\n    print(ans % (10**9 + 7))\n\nif True:\n    solve()",
    "def solve(n, x, pos):\n    hasBig = hasLess = 0\n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    mod = 10**9 + 7\n    bigComb = comb(hasBig, pos)\n    smallComb = comb(hasLess, n - pos - 1)\n    \n    return (bigComb * smallComb) % mod\n\ndef comb(n, k):\n    if k > n // 2:\n        k = n - k\n    res = 1\n    for i in range(k):\n        res *= (n - i)\n        res //= (i + 1)\n    return res\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "from math import comb\n\ndef solve(n, x, pos):\n    cntBig = 0\n    cntLess = 0\n    \n    # Count the number of positions where x should be greater than the current element\n    for i in range(pos + 1, n):\n        if a[i] > x:\n            cntBig += 1\n    \n    # Count the number of positions where x should be less than the current element\n    for i in range(pos):\n        if a[i] < x:\n            cntLess += 1\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    hasBig = cntBig\n    hasLess = n - cntBig - 1\n    \n    ans = comb(hasBig, cntBig) * comb(hasLess, cntLess)\n    \n    # Return the remainder of the division of the answer by 10^9+7\n    return ans % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Create the array a with elements from 1 to n\na = list(range(1, n + 1))\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def bin_search_count(n, x, pos):\n    # Calculate the number of ways to place large numbers in cntBig positions\n    def comb(n, k):\n        return math.comb(n, k)\n\n    # Calculate the number of ways to place small numbers in cntLess positions\n    def comb_small(n, k):\n        return math.comb(n, k)\n\n    # Calculate the number of valid permutations\n    hasBig = n - pos - 1\n    hasLess = pos\n    cntBig = hasBig // 2\n    cntLess = hasLess // 2\n\n    # Calculate the number of ways to place large numbers in cntBig positions\n    ways_big = comb(hasBig, cntBig)\n\n    # Calculate the number of ways to place small numbers in cntLess positions\n    ways_small = comb_small(hasLess, cntLess)\n\n    # Calculate the total number of valid permutations\n    total_permutations = ways_big * ways_small\n\n    # Return the remainder of the division of the number of valid permutations by 10^9+7\n    return total_permutations % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Print the result\nprint(bin_search_count(n, x, pos))",
    "import math\n\ndef factorial(n):\n    return math.factorial(n)\n\ndef combination(n, k):\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef solve(n, x, pos):\n    hasBig = 0\n    hasLess = 0\n    \n    # Count the number of larger and smaller numbers\n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    # Calculate the number of ways to place larger and smaller numbers\n    cntBig = hasBig - (hasBig - pos)\n    cntLess = hasLess - pos\n    \n    # Calculate the total number of permutations\n    total_permutations = combination(hasBig + hasLess, hasBig)\n    \n    # Print the result modulo 10^9 + 7\n    print(total_permutations % (10**9 + 7))\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nsolve(n, x, pos)",
    "def solve(n, x, pos):\n    hasBig, hasLess = 0, 0\n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    mod = 10**9 + 7\n    bigComb = math.comb(hasBig, pos)\n    smallComb = math.comb(hasLess, n - pos - 1)\n    \n    return (bigComb * smallComb) % mod\n\nif True:\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n, x, pos = map(int, data)\n    print(solve(n, x, pos))",
    "from math import factorial\n\ndef solve(n, x, pos):\n    hasBig = 0\n    hasLess = 0\n    \n    # Count the number of larger and smaller numbers\n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    # Calculate the number of ways to place larger and smaller numbers\n    bigWays = factorial(hasBig)\n    smallWays = factorial(hasLess)\n    \n    # Calculate the total number of valid permutations\n    totalPermutations = bigWays * smallWays\n    \n    # Return the remainder of the division by 10^9+7\n    return totalPermutations % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "from math import comb\n\ndef solve():\n    n, x, pos = map(int, input().split())\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    cntBig = pos + 1\n    hasBig = n - cntBig\n    \n    # Calculate the number of ways to place small numbers in cntLess positions\n    cntLess = n - pos - 1\n    hasLess = n - cntLess\n    \n    # Calculate the number of valid permutations\n    ans = comb(hasBig, cntBig) * comb(hasLess, cntLess)\n    \n    # Print the remainder of the division of the number of valid permutations by 10^9+7\n    print(ans % (10**9 + 7))\n\nif True:\n    solve()",
    "from math import factorial\n\ndef binomial_coefficient(n, k):\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef solve(n, x, pos):\n    cntBig = 0\n    cntLess = 0\n    \n    # Count the number of positions where x should be greater than the current element\n    for i in range(pos):\n        if a[i] > x:\n            cntBig += 1\n    \n    # Count the number of positions where x should be less than the current element\n    for i in range(pos + 1, n):\n        if a[i] < x:\n            cntLess += 1\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    hasBig = cntBig\n    cntBig = binomial_coefficient(hasBig, cntBig)\n    \n    # Calculate the number of ways to place small numbers in cntLess positions\n    hasLess = cntLess\n    cntLess = binomial_coefficient(hasLess, cntLess)\n    \n    # The total number of valid permutations is the product of the two results\n    result = cntBig * cntLess % (10**9 + 7)\n    \n    return result\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Initialize the array with numbers from 1 to n\na = list(range(1, n + 1))\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "from math import comb\n\ndef solve(n, x, pos):\n    hasBig = pos\n    hasLess = n - pos - 1\n    \n    cntBig = hasBig // 2\n    cntLess = hasLess // 2\n    \n    if hasBig % 2 != 0:\n        cntBig += 1\n    if hasLess % 2 != 0:\n        cntLess += 1\n    \n    ans = comb(hasBig, cntBig) * comb(hasLess, cntLess)\n    \n    return ans % (10**9 + 7)\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "from math import factorial\nMOD = 10**9 + 7\n\ndef binomial_coefficient(n, k):\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef solve(n, x, pos):\n    cntBig = 0\n    cntLess = 0\n    \n    # Count the number of positions where x should be greater than the current element\n    for i in range(pos):\n        if a[i] > x:\n            cntBig += 1\n    \n    # Count the number of positions where x should be less than the current element\n    for i in range(pos + 1, n):\n        if a[i] < x:\n            cntLess += 1\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    hasBig = cntBig\n    cntBig = binomial_coefficient(hasBig, cntBig)\n    \n    # Calculate the number of ways to place small numbers in cntLess positions\n    hasLess = cntLess\n    cntLess = binomial_coefficient(hasLess, cntLess)\n    \n    # The total number of valid permutations is the product of the two results\n    result = (cntBig * cntLess) % MOD\n    \n    return result\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Initialize the array with numbers from 1 to n\na = list(range(1, n + 1))\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "from math import comb\n\ndef solve(n, x, pos):\n    hasBig = sum(1 for i in range(pos) if i != x)\n    hasLess = sum(1 for i in range(pos + 1, n) if i != x)\n    \n    return (comb(hasBig, n - pos) * comb(hasLess, pos)) % (10**9 + 7)\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "from math import comb\n\ndef solve(n, x, pos):\n    hasBig, hasLess = 0, 0\n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    cntBig = hasBig - (hasBig - pos)\n    cntLess = hasLess - pos\n    \n    ans = comb(hasBig, cntBig) * comb(hasLess, cntLess)\n    \n    return ans % (10**9 + 7)\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "from math import comb, pow\nMOD = 10**9 + 7\n\ndef solve(n, x, pos):\n    hasBig = 0\n    hasLess = 0\n    \n    # Count the number of larger and smaller numbers\n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    # Calculate the number of ways to place larger and smaller numbers\n    bigWays = comb(hasBig, pos) * pow(hasBig, pos, MOD)\n    smallWays = comb(hasLess, n - pos - 1) * pow(hasLess, n - pos - 1, MOD)\n    \n    # Return the total number of valid permutations modulo MOD\n    return (bigWays + smallWays) % MOD\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "from math import comb\n\ndef solve(n, x, pos):\n    # Initialize counters for larger and smaller numbers\n    cntBig = 0\n    cntLess = 0\n    \n    # Count the occurrences of x in the array\n    for i in range(n):\n        if i == pos:\n            continue\n        if a[i] == x:\n            cntBig += 1\n        elif a[i] < x:\n            cntLess += 1\n    \n    # Calculate the number of ways to place larger numbers\n    hasBig = cntBig\n    hasLess = n - cntBig - cntLess\n    \n    # Calculate the number of valid permutations\n    ans = comb(hasBig, cntBig) * comb(hasLess, cntLess)\n    \n    # Return the result modulo 10^9 + 7\n    return ans % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "from math import factorial\n\ndef solve(n, x, pos):\n    # Calculate the number of ways to choose cntBig positions out of n-1\n    cntBig = n - pos - 1\n    hasBig = cntBig\n    \n    # Calculate the number of ways to choose cntLess positions out of n-1\n    cntLess = pos\n    hasLess = cntLess\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    waysBig = factorial(hasBig) // (factorial(cntBig) * factorial(hasBig - cntBig))\n    \n    # Calculate the number of ways to place small numbers in cntLess positions\n    waysLess = factorial(hasLess) // (factorial(cntLess) * factorial(hasLess - cntLess))\n    \n    # The total number of valid permutations is the product of the two results\n    result = waysBig * waysLess\n    \n    # Return the result modulo 10^9+7\n    return result % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nprint(solve(n, x, pos))",
    "from math import factorial\n\ndef mod_inverse(n, p):\n    return pow(n, p-2, p)\n\ndef binomial_coefficient(n, k):\n    return factorial(n) // (factorial(k) * factorial(n-k))\n\ndef solve(n, x, pos):\n    hasBig = 0\n    hasLess = 0\n    \n    for i in range(pos):\n        if i < x:\n            hasLess += 1\n        else:\n            hasBig += 1\n            \n    for i in range(pos+1, n):\n        if i < x:\n            hasBig += 1\n        else:\n            hasLess += 1\n            \n    cntBig = hasBig - pos\n    cntLess = hasLess - pos\n    \n    ans = binomial_coefficient(cntBig, cntBig) * cntBig % (10**9 + 7)\n    \n    ans *= binomial_coefficient(cntLess, cntLess) * cntLess % (10**9 + 7)\n    \n    ans *= mod_inverse(factorial(pos), 10**9 + 7)\n    \n    return ans\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "from math import factorial\n\ndef binomial(n, k):\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef solve(n, x, pos):\n    hasBig = 0\n    hasLess = 0\n    \n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    cntBig = hasBig - pos\n    cntLess = hasLess - pos\n    \n    ans = binomial(hasBig, cntBig) * binomial(hasLess, cntLess)\n    \n    return ans % (10**9 + 7)\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "from math import factorial\n\ndef solve(n, x, pos):\n    if x == n:\n        return 1\n    \n    # Calculate the number of ways to place larger numbers\n    hasBig = n - x\n    cntBig = pos + 1\n    resBig = factorial(hasBig) // (factorial(cntBig) * factorial(hasBig - cntBig))\n    \n    # Calculate the number of ways to place smaller numbers\n    hasLess = x - 1\n    cntLess = n - pos - 1\n    resLess = factorial(hasLess) // (factorial(cntLess) * factorial(hasLess - cntLess))\n    \n    # The total number of valid permutations\n    return (resBig * resLess) % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nprint(solve(n, x, pos))",
    "from math import comb\n\ndef binary_search_permutations(n, x, pos):\n    # Calculate the number of positions where x must be greater than the current element\n    cntBig = sum(1 for i in range(pos) if a[i] >= x)\n    \n    # Calculate the number of positions where x must be less than the current element\n    cntLess = sum(1 for i in range(pos, n) if a[i] <= x)\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    hasBig = comb(cntBig, cntBig)\n    \n    # Calculate the number of ways to place small numbers in cntLess positions\n    hasLess = comb(cntLess, cntLess)\n    \n    # The total number of valid permutations is the product of the two results\n    return hasBig * hasLess % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Create the array with distinct integers from 1 to n\na = list(range(1, n + 1))\n\n# Print the result\nprint(binary_search_permutations(n, x, pos))",
    "from math import comb\n\ndef solve(n, x, pos):\n    # Calculate the number of positions where x must be greater than the current element\n    cntBig = pos\n    \n    # Calculate the number of positions where x must be less than the current element\n    cntLess = n - pos - 1\n    \n    # Calculate the number of ways to choose cntBig positions out of hasBig elements\n    hasBig = x - 1\n    waysBig = comb(hasBig, cntBig)\n    \n    # Calculate the number of ways to choose cntLess positions out of hasLess elements\n    hasLess = n - x\n    waysLess = comb(hasLess, cntLess)\n    \n    # The total number of valid permutations is the product of the two combinations\n    totalPermutations = waysBig * waysLess\n    \n    # Return the remainder of the division of the total number of permutations by 10^9+7\n    return totalPermutations % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "from math import comb\n\ndef solve(n, x, pos):\n    # Calculate the number of larger and smaller numbers\n    hasBig = n - pos - 1\n    hasLess = pos\n    \n    # Calculate the number of ways to choose positions for larger numbers\n    cntBig = comb(hasBig, x)\n    \n    # Calculate the number of ways to choose positions for smaller numbers\n    cntLess = comb(hasLess, n - x - 1)\n    \n    # Calculate the total number of valid permutations\n    total_permutations = cntBig * cntLess\n    \n    # Return the result modulo 10^9 + 7\n    return total_permutations % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "from math import comb\n\ndef solve(n, x, pos):\n    cntBig = cntLess = 0\n    for i in range(1, n + 1):\n        if i > x:\n            cntBig += 1\n        elif i < x:\n            cntLess += 1\n    \n    hasBig = cntBig\n    hasLess = cntLess\n    \n    ans = 1\n    for i in range(pos + 1):\n        if i < pos:\n            ans *= comb(hasLess, i)\n        else:\n            ans *= comb(hasBig, i - pos)\n    \n    return ans % (10**9 + 7)\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "from math import comb\n\ndef solve(n, x, pos):\n    cntBig, cntLess = 0, 0\n    for i in range(n):\n        if i == pos:\n            continue\n        if i < pos:\n            cntLess += 1\n        else:\n            cntBig += 1\n    \n    hasBig = cntBig\n    hasLess = n - cntLess - 1\n    \n    ans = comb(hasBig, cntBig) * comb(hasLess, cntLess)\n    \n    return ans % (10**9 + 7)\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "from math import comb\n\ndef solve(n, x, pos):\n    hasBig = sum(i > x for i in range(1, n + 1))\n    hasLess = sum(i < x for i in range(1, n + 1))\n    \n    cntBig = pos + 1\n    cntLess = n - pos\n    \n    ans = comb(hasBig, cntBig) * comb(hasLess, cntLess)\n    return ans % (10**9 + 7)\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "from math import comb\n\ndef solve(n, x, pos):\n    cntBig = pos\n    cntLess = n - pos - 1\n    \n    hasBig = cntBig\n    hasLess = cntLess\n    \n    ans = comb(hasBig, cntBig) * comb(hasLess, cntLess)\n    \n    return ans % (10**9 + 7)\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "from math import factorial\n\ndef solve(n, x, pos):\n    hasBig = pos\n    hasLess = n - pos - 1\n    \n    cntBig = hasBig // 2\n    cntLess = hasLess // 2\n    \n    if hasBig % 2 != 0:\n        cntBig += 1\n    if hasLess % 2 != 0:\n        cntLess += 1\n    \n    ans = factorial(cntBig) * factorial(cntLess)\n    \n    return ans % (10**9 + 7)\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "from math import factorial\n\ndef solve(n, x, pos):\n    hasBig = sum(1 for i in range(pos + 1, n + 1) if i > x)\n    hasLess = sum(1 for i in range(pos + 1, n + 1) if i < x)\n    \n    cntBig = pos + 1\n    cntLess = n - pos\n    \n    ans = factorial(cntBig) * factorial(cntLess)\n    ans %= 10**9 + 7\n    \n    return ans\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "from math import comb, pow, modf\n\ndef solve(n, x, pos):\n    hasBig = 0\n    hasLess = 0\n    \n    # Count the number of larger and smaller numbers\n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    # Calculate the number of ways to place larger and smaller numbers\n    bigWays = comb(hasBig, pos)\n    smallWays = comb(hasLess, n - pos - 1)\n    \n    # Calculate the total number of valid permutations\n    totalPermutations = bigWays * smallWays\n    \n    # Return the remainder of the division by 10^9+7\n    return int(totalPermutations % (pow(10, 9) + 7))\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "from math import factorial\n\ndef solve(n, x, pos):\n    if pos == 0:\n        return 1\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    cntBig = pos\n    hasBig = n - pos\n    ansBig = factorial(hasBig) // (factorial(cntBig) * factorial(hasBig - cntBig))\n    \n    # Calculate the number of ways to place small numbers in cntLess positions\n    cntLess = n - pos - 1\n    hasLess = n - pos - 1\n    ansLess = factorial(hasLess) // (factorial(cntLess) * factorial(hasLess - cntLess))\n    \n    # The total number of valid permutations is the product of the two results\n    return (ansBig * ansLess) % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nprint(solve(n, x, pos))",
    "from math import factorial\n\ndef solve(n, x, pos):\n    hasBig, hasLess = 0, 0\n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    cntBig = hasBig - pos\n    cntLess = hasLess - pos\n    \n    if cntBig < 0 or cntLess < 0:\n        return 0\n    \n    return factorial(cntBig) * factorial(cntLess) % (10**9 + 7)\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "from math import factorial\n\ndef solve(n, x, pos):\n    if n == 1:\n        return 1 if x == pos else 0\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    cntBig = pos\n    hasBig = n - cntBig\n    waysBig = factorial(hasBig) // (factorial(cntBig) * factorial(hasBig - cntBig))\n    \n    # Calculate the number of ways to place small numbers in cntLess positions\n    cntLess = n - pos - 1\n    hasLess = n - cntLess - 1\n    waysLess = factorial(hasLess) // (factorial(cntLess) * factorial(hasLess - cntLess))\n    \n    # The total number of valid permutations\n    total_permutations = waysBig * waysLess\n    \n    # Return the remainder of the division by 10^9+7\n    return total_permutations % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "from math import factorial\ndef solve(n, x, pos):\n    hasBig = 0\n    hasLess = 0\n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    cntBig = hasBig - pos\n    cntLess = hasLess - pos\n    \n    ans = factorial(cntBig + cntLess) // (factorial(cntBig) * factorial(cntLess))\n    \n    return ans % (10**9 + 7)\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))"
  ],
  "rewards": [
    0.0,
    0.075,
    0.025,
    0.0,
    0.0,
    0.075,
    0.025,
    0.025,
    0.0,
    0.075,
    0.025,
    0.0,
    0.025,
    0.075,
    0.025,
    0.0,
    0.025,
    0.05,
    0.0,
    0.025,
    0.025,
    0.025,
    0.0,
    0.075,
    0.175,
    0.05,
    0.025,
    0.025,
    0.025,
    0.05,
    0.05,
    0.0,
    0.0,
    0.025,
    0.025,
    0.025,
    0.0,
    0.025,
    0.075,
    0.025,
    0.05,
    0.025,
    0.05,
    0.025,
    0.025,
    0.0,
    0.075,
    0.0,
    0.075,
    0.0,
    0.025
  ],
  "train rewards": [
    0.0,
    0.2,
    0.175,
    0.05,
    0.0,
    0.2,
    0.05,
    0.025,
    0.0,
    0.2,
    0.1,
    0.0,
    0.075,
    0.2,
    0.175,
    0.0,
    0.075,
    0.2,
    0.0,
    0.1,
    0.05,
    0.075,
    0.05,
    0.2,
    0.375,
    0.175,
    0.075,
    0.075,
    0.075,
    0.2,
    0.125,
    0.0,
    0.025,
    0.075,
    0.075,
    0.025,
    0.025,
    0.075,
    0.225,
    0.1,
    0.175,
    0.175,
    0.2,
    0.075,
    0.1,
    0.025,
    0.2,
    0.05,
    0.225,
    0.05,
    0.025
  ],
  "time": [
    8.553040027618408,
    14.16030502319336,
    19.341235876083374,
    25.518558979034424,
    34.83964943885803,
    40.64905905723572,
    51.41213369369507,
    55.659539461135864,
    61.53472971916199,
    67.54906845092773,
    73.99065351486206,
    79.34542989730835,
    86.07295274734497,
    93.73283100128174,
    98.6783459186554,
    106.67522120475769,
    115.33661842346191,
    122.51263236999512,
    129.0471155643463,
    159.9360978603363,
    166.86940932273865,
    174.19727325439453,
    180.5282678604126,
    188.2225661277771,
    193.9642403125763,
    201.1136040687561,
    209.60141849517822,
    215.85786247253418,
    224.54805040359497,
    229.4195749759674,
    235.92805671691895,
    242.33328413963318,
    248.14986896514893,
    254.5835781097412,
    265.2117962837219,
    273.26071977615356,
    280.4908754825592,
    287.08949732780457,
    293.4682605266571,
    298.3277339935303,
    305.29333877563477,
    312.4640974998474,
    318.98364090919495,
    324.81457352638245,
    332.91951966285706,
    338.87700057029724,
    345.09142780303955,
    350.70525193214417,
    356.83535861968994,
    363.08024501800537,
    367.3764317035675
  ],
  "sample times": 51
}