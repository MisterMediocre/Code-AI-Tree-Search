{
  "prompt": "\nQUESTION:\nThe mayor of the Central Town wants to modernize Central Street, represented in this problem by the $(Ox)$ axis.\n\nOn this street, there are $n$ antennas, numbered from $1$ to $n$. The $i$-th antenna lies on the position $x_i$ and has an initial scope of $s_i$: it covers all integer positions inside the interval $[x_i - s_i; x_i + s_i]$.\n\nIt is possible to increment the scope of any antenna by $1$, this operation costs $1$ coin. We can do this operation as much as we want (multiple times on the same antenna if we want).\n\nTo modernize the street, we need to make all integer positions from $1$ to $m$ inclusive covered by at least one antenna. Note that it is authorized to cover positions outside $[1; m]$, even if it's not required.\n\nWhat is the minimum amount of coins needed to achieve this modernization?\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\le 80$ and $n \\le m \\le 100\\ 000$).\n\nThe $i$-th of the next $n$ lines contains two integers $x_i$ and $s_i$ ($1 \\le x_i \\le m$ and $0 \\le s_i \\le m$).\n\nOn each position, there is at most one antenna (values $x_i$ are pairwise distinct).\n\n\n-----Output-----\n\nYou have to output a single integer: the minimum amount of coins required to make all integer positions from $1$ to $m$ inclusive covered by at least one antenna.\n\n\n-----Examples-----\nInput\n3 595\n43 2\n300 4\n554 10\n\nOutput\n281\n\nInput\n1 1\n1 1\n\nOutput\n0\n\nInput\n2 50\n20 0\n3 1\n\nOutput\n30\n\nInput\n5 240\n13 0\n50 25\n60 5\n155 70\n165 70\n\nOutput\n26\n\n\n\n-----Note-----\n\nIn the first example, here is a possible strategy:\n\n  Increase the scope of the first antenna by $40$, so that it becomes $2 + 40 = 42$. This antenna will cover interval $[43 - 42; 43 + 42]$ which is $[1; 85]$  Increase the scope of the second antenna by $210$, so that it becomes $4 + 210 = 214$. This antenna will cover interval $[300 - 214; 300 + 214]$, which is $[86; 514]$  Increase the scope of the third antenna by $31$, so that it becomes $10 + 31 = 41$. This antenna will cover interval $[554 - 41; 554 + 41]$, which is $[513; 595]$ \n\nTotal cost is $40 + 210 + 31 = 281$. We can prove that it's the minimum cost required to make all positions from $1$ to $595$ covered by at least one antenna.\n\nNote that positions $513$ and $514$ are in this solution covered by two different antennas, but it's not important.\n\n\u2014\n\nIn the second example, the first antenna already covers an interval $[0; 2]$ so we have nothing to do.\n\nNote that the only position that we needed to cover was position $1$; positions $0$ and $2$ are covered, but it's not important.\n\nInstructions:\n\n\nYou are a Python3 code generator.  Output **only** valid Python code. No explanations, no commentary, no filenames, no Markdown formatting. You will spit out a code block that can be pasted into any script. It must read the input, execute the logic and then print the output. Ensure that you invoke the main() or solve() function at the end if you're writing your code inside them.\nANSWER:\n",
  "codes": [
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = []\n    for i in range(n):\n        x, s = data[i*2+2:i*2+4]\n        antennas.append((x, s))\n    antennas.sort()\n    \n    covered_positions = set()\n    total_cost = 0\n    \n    for x, s in antennas:\n        start = max(1, x - s)\n        end = min(m, x + s)\n        for pos in range(start, end + 1):\n            if pos not in covered_positions:\n                covered_positions.add(pos)\n                total_cost += 1\n                \n    print(total_cost)\n\nif True:\n    solve()",
    "def solve(n, m, x_s):\n    # Sort antennas based on their starting positions\n    x_s.sort(key=lambda x: x[0])\n    \n    # Initialize variables for coverage and coin count\n    coverage = set()\n    coin_count = 0\n    \n    # Iterate through each antenna\n    for x, s in x_s:\n        # Add new positions covered by the current antenna to the coverage set\n        coverage.update(range(x - s, x + s + 1))\n        \n        # If the coverage set now includes all positions up to m, return the coin count\n        if max(coverage) >= m:\n            return coin_count\n    \n    # If we reach this point, it means we didn't cover all positions up to m with the given antennas\n    # Calculate the number of additional positions needed to cover m\n    additional_positions_needed = m - max(coverage)\n    # Each additional position needs to be covered by at least one antenna\n    coin_count += additional_positions_needed\n    \n    return coin_count\n\n# Read input\nn, m = map(int, input().split())\nx_s = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(solve(n, m, x_s))",
    "def solve(n, m):\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas based on their starting points\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = [False] * (m + 1)\n    \n    # Iterate through each antenna\n    for x, s in antennas:\n        # Extend current scope\n        for i in range(x - s, x + s + 1):\n            current_scope[i] = True\n        \n        # If current scope is complete, break the loop\n        if all(current_scope):\n            break\n    \n    # Calculate the minimum cost\n    min_cost = sum(s for _, s in antennas) - len(antennas)\n    \n    return min_cost\n\n# Read input\nn, m = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, m)\n\n# Print the result\nprint(result)",
    "def solve(n, m):\n    positions = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        positions.append((x - s, x + s))\n    \n    positions.sort()\n    \n    covered = set()\n    total_cost = 0\n    \n    for start, end in positions:\n        if start not in covered:\n            covered.update(range(start, end + 1))\n            total_cost += end - start + 1\n    \n    return total_cost\n\nif True:\n    n, m = map(int, input().split())\n    print(solve(n, m))",
    "def solve(n, m):\n    # Initialize a list to store the current scope of each antenna\n    scopes = [0] * n\n    \n    # Sort the antennas based on their initial scopes\n    scopes.sort()\n    \n    # Initialize the total cost to 0\n    total_cost = 0\n    \n    # Iterate through each position from 1 to m\n    for i in range(1, m + 1):\n        # Find the antenna with the largest remaining scope that covers the current position\n        max_scope_antenna = -1\n        max_scope = 0\n        \n        for j in range(n):\n            if scopes[j] > 0 and i >= x[j] - s[j] and i <= x[j] + s[j]:\n                if scopes[j] > max_scope:\n                    max_scope = scopes[j]\n                    max_scope_antenna = j\n        \n        # If no antenna covers the current position, increase the scope of the antenna with the largest remaining scope\n        if max_scope_antenna == -1:\n            total_cost += 1\n            scopes[max_scope_antenna] -= 1\n        else:\n            scopes[max_scope_antenna] -= 1\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nx = []\ns = []\nfor _ in range(n):\n    x_i, s_i = map(int, input().split())\n    x.append(x_i)\n    s.append(s_i)\n\n# Print the result\nprint(solve(n, m))",
    "def solve(n, m, antennas):\n    covered = set()\n    for i in range(n):\n        left, right = antennas[i][0] - antennas[i][1], antennas[i][0] + antennas[i][1]\n        for j in range(left, right + 1):\n            covered.add(j)\n    \n    uncovered = set(range(1, m + 1)) - covered\n    \n    return len(uncovered)\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve and print output\nprint(solve(n, m, antennas))",
    "def solve(n, m, x_s):\n    # Sort the antennas based on their starting points\n    x_s.sort()\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    for x, s in x_s:\n        # Update the current scope\n        current_scope += s\n        \n        # If the current scope covers more than half of the range [1, m]\n        if current_scope > (m + 1) // 2:\n            break\n        \n        # Increment the total cost\n        total_cost += 1\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nx_s = []\nfor _ in range(n):\n    x, s = map(int, input().split())\n    x_s.append((x, s))\n\n# Print output\nprint(solve(n, m, x_s))",
    "def solve(n, m):\n    # Sort the antennas based on their starting positions\n    antennas = sorted([(x, s) for x, s in zip(map(int, input().split()), map(int, input().split()))])\n    \n    # Initialize variables to keep track of the current position and the number of coins used\n    pos = 0\n    coins = 0\n    \n    # Iterate over each antenna\n    for x, s in antennas:\n        # If the current position is less than the starting position of the antenna,\n        # increment the position and use one coin\n        while pos < x:\n            pos += 1\n            coins += 1\n        \n        # Update the position to the ending position of the antenna\n        pos += s\n    \n    return coins\n\n# Read input values\nn, m = map(int, input().split())\n\n# Call the solve function with the input values and print the result\nprint(solve(n, m))",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by their starting point\n    antennas.sort()\n    \n    total_cost = 0\n    \n    # Iterate through each antenna\n    for i, (x, s) in enumerate(antennas):\n        # If the current antenna does not cover the beginning of the interval\n        if x > 1:\n            total_cost += max(x - 1, 0)\n        \n        # Update the ending point of the current antenna\n        x += s\n    \n    # If the last antenna does not cover the end of the interval\n    if x < m:\n        total_cost += max(m - x, 0)\n    \n    print(total_cost)\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by their start position\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_coverage = set()\n    \n    # Iterate through each antenna\n    for x, s in antennas:\n        # Calculate the new coverage after adding the antenna's scope\n        new_coverage = set(range(x - s, x + s + 1))\n        \n        # Update the current coverage\n        current_coverage |= new_coverage\n        \n        # If the current coverage includes all positions up to m,\n        # we don't need to add more scopes\n        if len(current_coverage) >= m:\n            break\n        \n        # Otherwise, add the cost of increasing the scope of the antenna\n        total_cost += s\n    \n    # Print the minimum cost\n    print(total_cost)\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas based on their leftmost position\n    antennas.sort(key=lambda x: x[0])\n    \n    total_cost = 0\n    \n    for i in range(n):\n        x, s = antennas[i]\n        # Check if current antenna covers all positions from 1 to m\n        if x <= 1 and x + 2 * s >= m:\n            continue\n        # Calculate how many additional coins are needed to cover remaining positions\n        remaining_positions = max(0, m - (x + 2 * s))\n        total_cost += remaining_positions\n    \n    print(total_cost)\n\nif True:\n    solve()",
    "def solve(n, m):\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    covered_positions = set()\n    min_coins = 0\n    \n    for i in range(1, m+1):\n        if i not in covered_positions:\n            found_antenna = False\n            for antenna in antennas:\n                if antenna[0] <= i <= antenna[0] + antenna[1]:\n                    covered_positions.add(i)\n                    found_antenna = True\n                    break\n            \n            if not found_antenna:\n                min_coins += 1\n    \n    return min_coins\n\n# Main function\nif True:\n    n, m = map(int, input().split())\n    print(solve(n, m))",
    "def solve(n, m):\n    # Sort antennas based on their starting points\n    antennas = sorted([(x, s) for x, s in zip(range(1, m+1), range(s, m+s+1))])\n    \n    # Initialize variables\n    total_cost = 0\n    current_coverage = set()\n    \n    # Iterate through each antenna\n    for x, s in antennas:\n        # Update the current coverage with new positions covered by this antenna\n        current_coverage.update(range(x-s, x+s+1))\n        \n        # If the current coverage covers all positions up to m, return the total cost\n        if len(current_coverage) >= m:\n            return total_cost\n    \n    # Return the total cost if all positions are not covered\n    return total_cost + max(m - len(current_coverage), 0)\n\n# Read input\ninput_data = input().split()\nn, m = int(input_data[0]), int(input_data[1])\n\n# Solve the problem\nresult = solve(n, m)\nprint(result)",
    "def solve(n, m, x, s):\n    # Sort antennas based on their start positions\n    antennas = sorted(zip(x, s))\n    \n    # Initialize variables for coverage and cost\n    coverage = set()\n    cost = 0\n    \n    # Iterate through each antenna\n    for i, (start, end) in enumerate(antennas):\n        # Update coverage for this antenna\n        coverage.update(range(start - end, start + end + 1))\n        \n        # If current coverage covers more than half of the range [1, m]\n        if len(coverage) > m // 2:\n            break\n    \n    # Calculate the minimum cost to cover the remaining positions\n    remaining_positions = range(m + 1)\n    for pos in remaining_positions:\n        if pos not in coverage:\n            cost += 1\n    \n    return cost\n\n# Read input\ninput_data = input().split()\nn = int(input_data[0])\nm = int(input_data[1])\nx = list(map(int, input_data[2:n+2]))\ns = list(map(int, input_data[n+2:]))\n\n# Solve the problem\nresult = solve(n, m, x, s)\n\n# Print the result\nprint(result)",
    "def solve(n, m, x, s):\n    # Initialize a list to keep track of the coverage of each position\n    coverage = [False] * (m + 1)\n    \n    # Iterate through each antenna\n    for i in range(n):\n        start = max(1, x[i] - s[i])\n        end = min(m, x[i] + s[i])\n        \n        # Mark the positions covered by the current antenna\n        for j in range(start, end + 1):\n            coverage[j] = True\n    \n    # Count the number of uncovered positions\n    uncovered_positions = sum(not c for c in coverage)\n    \n    # Return the minimum number of coins required to cover all positions\n    return uncovered_positions\n\n# Read input\nn, m = map(int, input().split())\nx = list(map(int, input().split()))\ns = list(map(int, input().split()))\n\n# Solve the problem\nprint(solve(n, m, x, s))",
    "def solve(n, m, antennas):\n    # Initialize the set of covered positions\n    covered_positions = set()\n    \n    # Iterate over each antenna\n    for i in range(n):\n        # Calculate the start and end of the current antenna's coverage\n        start = max(1, antennas[i][0] - antennas[i][1])\n        end = min(m, antennas[i][0] + antennas[i][1])\n        \n        # Add the uncovered positions within the current antenna's coverage to the set\n        covered_positions.update(range(start, end + 1))\n    \n    # Return the number of uncovered positions\n    return len(set(range(1, m + 1)) - covered_positions)\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Print the result\nprint(solve(n, m, antennas))",
    "def solve(n, m, antennas):\n    # Sort antennas based on their starting points\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_covered = set()\n    \n    # Iterate through each antenna\n    for i, (x, s) in enumerate(antennas):\n        # Calculate the new coverage range after adding the antenna's scope\n        new_start = max(x - s, 1)\n        new_end = min(x + s, m)\n        \n        # Add the uncovered part of the new range to the current covered set\n        uncovered_part = {j for j in range(new_start, new_end + 1) if j not in current_covered}\n        current_covered.update(uncovered_part)\n        \n        # If the current covered set is now equal to the entire range [1, m], return the total cost\n        if len(current_covered) == m:\n            return total_cost\n    \n    # Return the total cost if no complete range is covered\n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(solve(n, m, antennas))",
    "def solve(n, m, x, s):\n    covered = set()\n    for i in range(n):\n        left = max(1, x[i] - s[i])\n        right = min(m, x[i] + s[i])\n        for j in range(left, right + 1):\n            covered.add(j)\n    \n    return len(covered) * 1\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn, m = map(int, data[:2])\nx = list(map(int, data[2:2+n]))\ns = list(map(int, data[2+n:]))\n\n# Solve the problem\nprint(solve(n, m, x, s))",
    "def solve(n, m, antennas):\n    # Sort antennas based on their starting positions\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    current_covered = set()\n    total_cost = 0\n    \n    # Iterate over each antenna\n    for i, (x, s) in enumerate(antennas):\n        # Calculate the new coverage range after increasing the scope\n        new_start = max(x - s, 1)\n        new_end = min(x + s, m)\n        \n        # Update the current covered positions\n        current_covered.update(range(new_start, new_end + 1))\n        \n        # If the current covered range is larger than the previous one,\n        # update the total cost and reset the current covered range\n        if len(current_covered) > len(current_covered):\n            total_cost += len(current_covered) - len(current_covered)\n            current_covered = set(range(new_start, new_end + 1))\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nresult = solve(n, m, antennas)\n\n# Print the result\nprint(result)",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i*2], data[i*2+1]) for i in range(n)]\n    \n    def can_cover(position):\n        for x, s in antennas:\n            if x <= position <= x + s:\n                return True\n        return False\n    \n    min_coins = 0\n    for i in range(1, m+1):\n        if not can_cover(i):\n            min_coins += 1\n    \n    print(min_coins)\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by their start position\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    # Iterate through each position from 1 to m\n    for i in range(1, m + 1):\n        # Find the nearest antenna that covers the current position\n        nearest_antenna = None\n        for antenna in antennas:\n            if antenna[0] <= i <= antenna[0] + antenna[1]:\n                nearest_antenna = antenna\n                break\n        \n        # If no antenna covers the current position, increase the scope of the nearest antenna\n        if nearest_antenna is None:\n            total_cost += 1\n            current_scope += 1\n            if current_scope > nearest_antenna[1]:\n                current_scope = nearest_antenna[1]\n        \n        # Update the current scope\n        current_scope += 1\n    \n    # Print the total cost\n    print(total_cost)\n\n# Check function with provided data points\ndef check_solution():\n    assert solve() == 281\n    assert solve() == 0\n    assert solve() == 30\n    assert solve() == 26\n\ncheck_solution()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas based on their leftmost position\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_coverage = set()\n    \n    # Iterate through each antenna\n    for x, s in antennas:\n        # Calculate new coverage after adding the antenna\n        new_coverage = set(range(x - s, x + s + 1))\n        \n        # Update the current coverage\n        current_coverage |= new_coverage\n        \n        # If current coverage includes all positions up to m, return total_cost\n        if max(current_coverage) >= m:\n            return total_cost\n    \n        # Otherwise, add the cost of increasing the scope of the antenna\n        total_cost += 1\n    \n    # Return total_cost if no coverage is found within m\n    return total_cost\n\n# Main function to handle input and call solve()\nif True:\n    solve()",
    "def solve(n, m, antennas):\n    # Sort the antennas based on their starting points\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_coverage = set()\n    \n    for x, s in antennas:\n        # Update the current coverage with the new antenna\n        current_coverage.update(range(x - s, x + s + 1))\n        \n        # Check if all positions from 1 to m are covered\n        if len(current_coverage) >= m:\n            break\n    \n    # Calculate the minimum cost\n    min_cost = sum(1 for _ in range(len(antennas)) if x - s < 1)\n    \n    return min_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nmin_cost = solve(n, m, antennas)\n\n# Print the result\nprint(min_cost)",
    "def solve(n, m, x, s):\n    # Sort antennas based on their start positions\n    antennas = sorted(zip(x, s), key=lambda a: a[0])\n    \n    total_cost = 0\n    \n    for i in range(n):\n        # Calculate the maximum scope needed to cover the current position\n        max_scope = max(0, m - antennas[i][0] + antennas[i][1])\n        \n        # Increment the scope until it reaches the maximum needed\n        while antennas[i][1] < max_scope:\n            total_cost += 1\n            antennas[i][1] += 1\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nx = list(map(int, input().split()))\ns = list(map(int, input().split()))\n\n# Solve the problem\nprint(solve(n, m, x, s))",
    "def solve(n, m):\n    positions = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        positions.append((x, s))\n    \n    # Sort positions by their start points\n    positions.sort(key=lambda p: p[0])\n    \n    total_cost = 0\n    \n    current_end = 0\n    \n    for pos, scope in positions:\n        if pos > current_end:\n            total_cost += scope\n            current_end = pos + scope\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\n\n# Solve the problem\nprint(solve(n, m))",
    "def solve(n, m, antennas):\n    # Sort antennas by their start positions\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables for the current position and the number of coins used\n    current_pos = 0\n    coins_used = 0\n    \n    # Iterate through each antenna\n    for x, s in antennas:\n        # If the current position is less than the start position of the current antenna,\n        # move the current position to the start position of the current antenna\n        if current_pos < x:\n            current_pos = x\n        \n        # Increment the scope of the current antenna until it covers the current position\n        while current_pos <= x + s:\n            coins_used += 1\n            current_pos += 1\n    \n    return coins_used\n\n# Read input\nn, m = map(int, input().split())\nantennas = []\nfor _ in range(n):\n    x, s = map(int, input().split())\n    antennas.append((x, s))\n\n# Solve the problem\nprint(solve(n, m, antennas))",
    "def solve(n, m):\n    # Sort the antennas based on their starting points\n    antennas = sorted([(x, s) for x, s in zip(map(int, input().split()), map(int, input().split()))], key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = [0] * m\n    \n    # Process each antenna\n    for x, s in antennas:\n        # Update the current scope with the new antenna\n        for i in range(x - s, x + s + 1):\n            current_scope[i - 1] = max(current_scope[i - 1], s)\n        \n        # If the current scope covers all positions, break\n        if all(scope == s for scope in current_scope):\n            break\n    \n    # Return the total cost\n    return total_cost\n\n# Read input and call the solve function\nn, m = map(int, input().split())\nprint(solve(n, m))",
    "def solve(n, m):\n    # Initialize a list to store the current scope of each antenna\n    scopes = [0] * n\n    \n    # Sort the antennas based on their initial scope\n    scopes.sort()\n    \n    # Initialize the total cost to 0\n    total_cost = 0\n    \n    # Iterate over the sorted antennas\n    for i in range(n):\n        # If the current scope of the antenna is less than or equal to m,\n        # add the scope to the total cost and update the current scope of the antenna\n        if scopes[i] <= m:\n            total_cost += scopes[i]\n            scopes[i] += 1\n            \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = []\nfor _ in range(n):\n    x, s = map(int, input().split())\n    antennas.append((x, s))\n\n# Solve the problem\nprint(solve(n, m))",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by their starting position\n    antennas.sort(key=lambda x: x[0])\n    \n    total_cost = 0\n    current_end = 0\n    \n    for _, s in antennas:\n        # Extend the current coverage to include the new antenna\n        current_end = max(current_end, x + s)\n        \n        # Calculate the cost for the new antenna\n        cost = current_end - x\n        \n        # Update the total cost\n        total_cost += cost\n    \n    print(total_cost)\n\nif True:\n    solve()",
    "def solve(n, m):\n    positions = sorted([int(input().split()[0]) for _ in range(n)])\n    scopes = [int(input().split()[1]) for _ in range(n)]\n    \n    total_cost = 0\n    \n    for i in range(1, m + 1):\n        found = False\n        \n        for j in range(n):\n            if positions[j] <= i <= positions[j] + scopes[j]:\n                found = True\n                break\n        \n        if not found:\n            total_cost += 1\n    \n    return total_cost\n\n# Main function to handle multiple test cases\nif True:\n    t = int(input())\n    for _ in range(t):\n        n, m = map(int, input().split())\n        print(solve(n, m))",
    "def solve(n, m):\n    antennas = sorted([(x, s) for x, s in zip(range(1, m+1), range(1, m+1))], key=lambda x: x[1])\n    \n    covered_positions = set()\n    total_cost = 0\n    \n    for x, s in antennas:\n        new_covered_positions = {pos for pos in range(x-s, x+s+1) if pos not in covered_positions}\n        covered_positions.update(new_covered_positions)\n        total_cost += len(new_covered_positions)\n        \n        if len(covered_positions) >= m:\n            break\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Solve and print the output\nprint(solve(n, m))",
    "def solve(n, m):\n    # Sort the antennas based on their starting points\n    antennas = sorted([(x, s) for x, s in zip(range(1, m+1), [int(input()) for _ in range(n)])])\n    \n    total_cost = 0\n    \n    # Iterate through each antenna\n    for i in range(n):\n        x, s = antennas[i]\n        \n        # Calculate the maximum scope of the current antenna\n        max_scope = x + s\n        \n        # If the current scope is less than or equal to the last covered position,\n        # we need to increase the scope of the current antenna\n        if max_scope <= m:\n            total_cost += max_scope - m\n            m = max_scope\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(solve(n, m))",
    "def solve(n, m, antennas):\n    # Sort the antennas based on their x coordinates\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize the coverage status for each position\n    coverage = [False] * (m + 1)\n    \n    # Iterate through each antenna\n    for x, s in antennas:\n        # Update the coverage status for the current antenna's range\n        for i in range(max(1, x - s), min(m + 1, x + s) + 1):\n            coverage[i] = True\n    \n    # Calculate the total number of uncovered positions\n    uncovered_positions = sum(not pos for pos in coverage)\n    \n    # Return the minimum number of coins needed\n    return uncovered_positions\n\n# Read input\ninput_data = input().split()\nn = int(input_data[0])\nm = int(input_data[1])\nantennas = []\nfor _ in range(n):\n    x, s = map(int, input().split())\n    antennas.append((x, s))\n\n# Solve the problem\nresult = solve(n, m, antennas)\n\n# Print the result\nprint(result)",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [data[i:i+2] for i in range(2, 2*n, 2)]\n    \n    def update_antenna(antenna):\n        left, right = antenna[0], antenna[1]\n        for i in range(left, right+1):\n            if i < 1 or i > m:\n                continue\n            if i == left:\n                left += 1\n            elif i == right:\n                right -= 1\n        return left, right\n    \n    total_cost = 0\n    while True:\n        max_left = float('-inf')\n        max_right = float('inf')\n        for antenna in antennas:\n            left, right = update_antenna(antenna)\n            max_left = max(max_left, left)\n            max_right = min(max_right, right)\n        \n        if max_left >= max_right:\n            break\n        \n        total_cost += max_right - max_left + 1\n        for antenna in antennas:\n            left, right = update_antenna(antenna)\n            if left > max_left:\n                left = max_left\n            if right < max_right:\n                right = max_right\n            if left != right:\n                antennas.remove(antenna)\n    \n    print(total_cost)\n\nif True:\n    solve()",
    "def solve(n, m, antennas):\n    # Sort antennas by their start position\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = [0] * (m + 1)\n    \n    # Process each antenna\n    for i in range(n):\n        x, s = antennas[i]\n        \n        # Update the current scope\n        for j in range(max(1, x - s), min(m + 1, x + s + 1)):\n            current_scope[j] = max(current_scope[j], s)\n    \n    # Calculate the minimum cost\n    for i in range(1, m + 1):\n        total_cost += max(0, current_scope[i] - 1)\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = []\nfor _ in range(n):\n    x, s = map(int, input().split())\n    antennas.append((x, s))\n\n# Solve and print the output\nprint(solve(n, m, antennas))",
    "def solve(n, m):\n    positions = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        positions.append((x, s))\n    \n    positions.sort()\n    \n    total_cost = 0\n    current_scope = 0\n    \n    for pos, scope in positions:\n        if pos > current_scope:\n            total_cost += pos - current_scope\n            current_scope = pos\n        current_scope += scope\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\n\n# Solve the problem\nprint(solve(n, m))",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by their starting position\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    current_scope = 0\n    total_coins = 0\n    \n    # Iterate over each position from 1 to m\n    for pos in range(1, m+1):\n        # Check if the current position is within the coverage of any antenna\n        found = False\n        for x, s in antennas:\n            if x - s <= pos <= x + s:\n                current_scope = max(current_scope, x + s)\n                found = True\n                break\n        \n        # If the current position is not covered, increment the scope of the nearest antenna\n        if not found:\n            min_x = float('inf')\n            for x, s in antennas:\n                if x < min_x:\n                    min_x = x\n            current_scope = max(current_scope, min_x + s)\n            total_coins += 1\n    \n    return total_coins\n\n# Call the solve function\nprint(solve())",
    "def solve(n, m, x_s):\n    # Sort antennas based on their start points\n    x_s.sort()\n    \n    # Initialize variables for coverage and coin count\n    covered_positions = set(range(1, m+1))\n    coin_count = 0\n    \n    # Iterate through each antenna\n    for x, s in x_s:\n        # Update the covered positions with the current antenna's range\n        covered_positions.update(range(x-s, x+s+1))\n        \n        # If all positions are covered, return the coin count\n        if len(covered_positions) == m:\n            return coin_count\n    \n    # If not all positions are covered, calculate the minimum number of coins needed\n    min_coins = sum(s for _, s in x_s)\n    for i in range(n):\n        min_coins += max(0, s - (m - len(covered_positions)))\n    \n    return min_coins\n\n# Read input\nn, m = map(int, input().split())\nx_s = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(solve(n, m, x_s))",
    "def solve(n, m):\n    positions = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        positions.append((x, s))\n    \n    positions.sort()\n    \n    total_cost = 0\n    \n    for i in range(n):\n        x, s = positions[i]\n        \n        if x <= 1:\n            total_cost += max(1, m - x)\n            continue\n        \n        left = x - s\n        right = x + s\n        \n        if left > 1:\n            total_cost += max(1, left - 1)\n        \n        if right < m:\n            total_cost += max(1, m - right)\n        \n        total_cost += s\n    \n    return total_cost\n\nif True:\n    n, m = map(int, input().split())\n    print(solve(n, m))",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    covered_positions = set()\n    total_cost = 0\n    \n    for i in range(1, m+1):\n        if i not in covered_positions:\n            found_antenna = False\n            for x, s in antennas:\n                if x <= i <= x + s:\n                    covered_positions.add(i)\n                    found_antenna = True\n                    break\n            if not found_antenna:\n                total_cost += 1\n    \n    print(total_cost)\n\nsolve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = []\n    for i in range(n):\n        x, s = data[i*2+2:i*2+4]\n        antennas.append((x, s))\n    \n    # Sort antennas by their start position\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = set()\n    \n    # Iterate through each position\n    for pos in range(1, m+1):\n        # Check if current scope already covers the current position\n        if pos in current_scope:\n            continue\n        \n        # Find the antenna that covers the current position\n        found_antenna = None\n        for antenna in antennas:\n            if antenna[0] <= pos <= antenna[0] + antenna[1]:\n                found_antenna = antenna\n                break\n        \n        # If no antenna covers the current position, return infinity\n        if found_antenna is None:\n            return float('inf')\n        \n        # Increment the scope of the found antenna\n        total_cost += 1\n        current_scope.add(pos)\n    \n    return total_cost\n\n# Call the solve function\nprint(solve())",
    "def solve(n, m):\n    # Initialize a list to store the current coverage of each antenna\n    coverage = [False] * m\n    \n    # Iterate through each antenna\n    for i in range(n):\n        x, s = map(int, input().split())\n        \n        # Update the coverage of the current antenna\n        for j in range(x - s, x + s + 1):\n            coverage[j - 1] = True\n    \n    # Count the number of uncovered positions\n    uncovered_positions = sum(not c for c in coverage)\n    \n    # Calculate the minimum number of coins needed\n    min_coins = uncovered_positions\n    \n    return min_coins\n\n# Read input\nn, m = map(int, input().split())\n\n# Solve the problem\nmin_coins = solve(n, m)\n\n# Print the result\nprint(min_coins)",
    "def solve(n, m):\n    positions = [0] * m\n    for _ in range(n):\n        x, s = map(int, input().split())\n        positions[x - s:x + s + 1] = [1] * len(positions[x - s:x + s + 1])\n    \n    return sum(positions)\n\nif True:\n    n, m = map(int, input().split())\n    print(solve(n, m))",
    "def solve(n, m):\n    positions = [0] * (m + 1)\n    \n    for i in range(1, n + 1):\n        x, s = map(int, input().split())\n        positions[x - s] += 1\n        positions[x + s + 1] -= 1\n    \n    prefix_sum = [0] * (m + 2)\n    for i in range(1, m + 2):\n        prefix_sum[i] = prefix_sum[i - 1] + positions[i]\n    \n    min_coins = float('inf')\n    for i in range(1, m + 1):\n        if prefix_sum[i] >= 1:\n            min_coins = min(min_coins, i - 1)\n    \n    return min_coins\n\n# Read input\nn, m = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, m)\n\n# Print the result\nprint(result)",
    "def solve(n, m):\n    positions = sorted([(x, s) for x, s in zip(range(1, m+1), range(s, m+s+1))])\n    covered = set()\n    cost = 0\n    \n    for pos, scope in positions:\n        if pos not in covered:\n            covered.add(pos)\n            cost += scope\n            \n    return cost\n\n# Read input\nn, m = map(int, input().split())\npositions = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(solve(n, m))",
    "def solve(n, m):\n    # Initialize a list to store the current scope of each antenna\n    scopes = [0] * n\n    \n    # Iterate through each antenna\n    for i in range(n):\n        x, s = map(int, input().split())\n        # Update the scope of the antenna\n        scopes[i] = max(0, min(x + s, m))\n    \n    # Calculate the total number of coins needed\n    total_coins = sum(scopes)\n    \n    # Print the result\n    print(total_coins)\n\n# Read input\nn, m = map(int, input().split())\n\n# Solve the problem\nsolve(n, m)",
    "def solve(n, m):\n    # Sort the antennas based on their starting points\n    antennas = sorted([(x, s) for x, s in zip(map(int, input().split()), map(int, input().split()))], key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_scope = 0\n    \n    # Iterate over each antenna\n    for x, s in antennas:\n        # Calculate the new scope after adding the antenna's scope\n        new_scope = max(current_scope + s, x)\n        \n        # If the new scope covers more than half of the range [1, m]\n        if new_scope > m // 2:\n            # Calculate the number of coins needed to increase the scope of the antenna\n            coins_needed = new_scope - m // 2\n            total_cost += coins_needed\n        \n        # Update the current scope\n        current_scope = new_scope\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\n\n# Solve the problem\nprint(solve(n, m))",
    "def solve(n, m, antennas):\n    # Sort antennas based on their start positions\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    current_scope = 0\n    total_cost = 0\n    \n    # Iterate through each antenna\n    for x, s in antennas:\n        # Update current scope\n        current_scope += s\n        \n        # If current scope exceeds the desired range, add coins\n        while current_scope > m:\n            current_scope -= antennas.pop(0)[1]\n            total_cost += 1\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nprint(solve(n, m, antennas))",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = []\n    for i in range(n):\n        x, s = data[i*2+2:i*2+4]\n        antennas.append((x, s))\n    # Sort antennas by their leftmost position\n    antennas.sort(key=lambda x: x[0])\n    # Initialize the current coverage\n    current_coverage = set()\n    # Initialize the total cost\n    total_cost = 0\n    # Iterate through each position from 1 to m\n    for i in range(1, m+1):\n        # Check if the current position is already covered by any antenna\n        if i in current_coverage:\n            continue\n        # Find the nearest antenna that covers the current position\n        nearest_antenna = None\n        for antenna in antennas:\n            if antenna[0] <= i <= antenna[0] + antenna[1]:\n                nearest_antenna = antenna\n                break\n        # If no antenna covers the current position, add it\n        if nearest_antenna is None:\n            total_cost += 1\n            current_coverage.add(i)\n        else:\n            # Update the current coverage\n            current_coverage.update(range(nearest_antenna[0], nearest_antenna[0] + nearest_antenna[1] + 1))\n    print(total_cost)\n\nif True:\n    solve()",
    "def solve(n, m):\n    # Initialize a list to keep track of the current scope of each antenna\n    scopes = [0] * n\n    \n    # Iterate over each antenna\n    for i in range(n):\n        # Calculate the new scope by adding 1 to the current scope\n        scopes[i] += 1\n        \n        # Update the scope of the previous antennas\n        for j in range(i):\n            # If the new scope of the current antenna overlaps with the old scope of another antenna, update its scope\n            if scopes[j] > scopes[i]:\n                scopes[j] = scopes[i]\n    \n    # Calculate the total cost by summing up the scopes of all antennas\n    total_cost = sum(scopes)\n    \n    return total_cost\n\n# Read input values\nn, m = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, m)\n\n# Print the result\nprint(result)"
  ],
  "rewards": [
    0.0,
    0.06818181818181818,
    0.0,
    0.0,
    0.0,
    0.06818181818181818,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.06818181818181818,
    0.045454545454545456,
    0.0,
    0.045454545454545456,
    0.0,
    0.0,
    0.0,
    0.022727272727272728,
    0.0,
    0.0,
    0.0,
    0.022727272727272728,
    0.045454545454545456,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.045454545454545456,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.022727272727272728,
    0.0,
    0.0
  ],
  "train rewards": [
    0.0,
    0.11363636363636363,
    0.0,
    0.0,
    0.0,
    0.1590909090909091,
    0.022727272727272728,
    0.0,
    0.06818181818181818,
    0.045454545454545456,
    0.045454545454545456,
    0.09090909090909091,
    0.0,
    0.0,
    0.0,
    0.1590909090909091,
    0.045454545454545456,
    0.0,
    0.045454545454545456,
    0.022727272727272728,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.045454545454545456,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.022727272727272728,
    0.0,
    0.0,
    0.0,
    0.045454545454545456,
    0.09090909090909091,
    0.0,
    0.09090909090909091,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.022727272727272728,
    0.09090909090909091,
    0.0
  ],
  "time": 315.2561674118042,
  "sample times": 50
}