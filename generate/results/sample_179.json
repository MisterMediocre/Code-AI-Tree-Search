{
  "prompt": "\nQUESTION:\nAndrey thinks he is truly a successful developer, but in reality he didn't know about the binary search algorithm until recently. After reading some literature Andrey understood that this algorithm allows to quickly find a certain number $x$ in an array. For an array $a$ indexed from zero, and an integer $x$ the pseudocode of the algorithm is as follows:\n\nBinarySearch(a, x)\n  left = 0\n  right = a.size()\n  while left < right\n    middle = (left + right) / 2\n    if a[middle] <= x then\n      left = middle + 1\n    else\n      right = middle\n  \n  if left > 0 and a[left - 1] == x then\n    return true\n  else\n    return false\n\nNote that the elements of the array are indexed from zero, and the division is done in integers (rounding down).\n\nAndrey read that the algorithm only works if the array is sorted. However, he found this statement untrue, because there certainly exist unsorted arrays for which the algorithm find $x$!\n\nAndrey wants to write a letter to the book authors, but before doing that he must consider the permutations of size $n$ such that the algorithm finds $x$ in them. A permutation of size $n$ is an array consisting of $n$ distinct integers between $1$ and $n$ in arbitrary order.\n\nHelp Andrey and find the number of permutations of size $n$ which contain $x$ at position $pos$ and for which the given implementation of the binary search algorithm finds $x$ (returns true). As the result may be extremely large, print the remainder of its division by $10^9+7$.\n\n\n-----Input-----\n\nThe only line of input contains integers $n$, $x$ and $pos$ ($1 \\le x \\le n \\le 1000$, $0 \\le pos \\le n - 1$) \u2014 the required length of the permutation, the number to search, and the required position of that number, respectively.\n\n\n-----Output-----\n\nPrint a single number\u00a0\u2014 the remainder of the division of the number of valid permutations by $10^9+7$.\n\n\n-----Examples-----\nInput\n4 1 2\n\nOutput\n6\n\nInput\n123 42 24\n\nOutput\n824071958\n\n\n\n-----Note-----\n\nAll possible permutations in the first test case: $(2, 3, 1, 4)$, $(2, 4, 1, 3)$, $(3, 2, 1, 4)$, $(3, 4, 1, 2)$, $(4, 2, 1, 3)$, $(4, 3, 1, 2)$.\n\nInstructions:\n\n\nYou are a Python3 code generator.  Output **only** valid Python code. No explanations, no commentary, no filenames, no Markdown formatting. You will spit out a code block that can be pasted into any script. It must read the input, execute the logic and then print the output. Ensure that you invoke the main() or solve() function at the end if you're writing your code inside them.\nANSWER:\n",
  "codes": [
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    # Calculate the number of ways to choose positions for x\n    ways_to_choose_positions = (n - pos) * (n - pos - 1) // 2\n    \n    # Calculate the number of ways to arrange the remaining numbers\n    remaining_numbers = n - 1\n    ways_to_arrange_remaining = remaining_numbers ** (remaining_numbers - 1)\n    \n    # Total number of valid permutations\n    total_valid_permutations = (ways_to_choose_positions * ways_to_arrange_remaining) % mod\n    \n    return total_valid_permutations\n\n# Read input\ninput_data = list(map(int, input().split()))\nn, x, pos = input_data\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    dp = [[0] * (n + 1) for _ in range(2)]\n    \n    # Base case: empty array\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            if j == 0:\n                dp[i % 2][j] = dp[(i - 1) % 2][j]\n            elif j == i:\n                dp[i % 2][j] = dp[(i - 1) % 2][j - 1]\n            else:\n                dp[i % 2][j] = (dp[(i - 1) % 2][j - 1] + dp[(i - 1) % 2][j]) % mod\n    \n    return dp[n % 2][pos]\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Print output\nprint(solve(n, x, pos))",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        if i >= pos + 1:\n            dp[i] += dp[i - 1]\n        if i >= pos + 2:\n            dp[i] += dp[i - 2]\n        dp[i] %= MOD\n    return dp[n]\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve and print the result\nprint(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of ways to place x at position pos\n    ways_at_pos = (n - pos) * (mod - 1) % mod\n    \n    # Calculate the number of ways to arrange the remaining elements\n    arrangements = factorial(n - 1) % mod\n    \n    # The total number of valid permutations\n    total_permutations = (ways_at_pos * arrangements) % mod\n    \n    return total_permutations\n\ndef factorial(num):\n    if num == 0:\n        return 1\n    result = 1\n    for i in range(1, num + 1):\n        result = (result * i) % mod\n    return result\n\n# Read input\ninput_data = list(map(int, input().split()))\nn, x, pos = input_data\n\n# Solve the problem\noutput = solve(n, x, pos)\n\n# Print the output\nprint(output)",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of ways to choose positions for x\n    ways_to_choose_pos = n - pos\n    \n    # Calculate the number of ways to arrange the remaining elements\n    ways_to_arrange_remaining = factorial(n - 1)\n    \n    # Calculate the total number of permutations with x at position pos\n    total_permutations = ways_to_choose_pos * ways_to_arrange_remaining % MOD\n    \n    return total_permutations\n\n\ndef factorial(num):\n    if num == 0:\n        return 1\n    else:\n        return num * factorial(num - 1)\n\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of ways to choose the remaining positions for the other numbers\n    total_ways = (n - 1) * (n - 2) // 2\n    \n    # Calculate the number of ways to place the target number at the specified position\n    if pos == 0:\n        ways_to_place_x = (n - 1) * (n - 2) // 2\n    elif pos == n - 1:\n        ways_to_place_x = (n - 1) * (n - 2) // 2\n    else:\n        ways_to_place_x = (n - 1) * (n - 2) // 2 - (n - pos - 1) * (n - pos - 2) // 2\n    \n    # Calculate the number of valid permutations\n    valid_permutations = (total_ways * ways_to_place_x) % mod\n    \n    return valid_permutations\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "from typing import *\nimport math\nfrom collections import *\n\ndef solve(n: int, x: int, pos: int) -> int:\n    MOD = 10**9 + 7\n    \n    # Calculate the number of valid permutations\n    # The number of ways to choose positions for x\n    # is C(pos, x), and the number of ways to arrange the remaining numbers\n    # is (n - x)!\n    count = comb(pos, x) * factorial(n - x) % MOD\n    \n    return count\n\nif True:\n    main()",
    "from math import comb\n\ndef solve(n, x, pos):\n    # Calculate the number of ways to choose positions for the remaining elements\n    total_positions = comb(n-1, pos)\n    \n    # Calculate the number of valid permutations for each choice of positions\n    valid_permutations = 0\n    \n    for i in range(1, n+1):\n        if i != x:\n            valid_permutations += comb(total_positions, i)\n            \n    # Return the result modulo 10^9 + 7\n    return valid_permutations % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    if pos == 0:\n        return 0 if x != 1 else 1\n    if pos == n-1:\n        return 0 if x != n else 1\n    \n    # Calculate the number of ways to choose the remaining elements\n    total_ways = pow(2, n-1, mod)\n    \n    # Calculate the number of ways to place the element at the specified position\n    if x == pos+1:\n        return total_ways\n    elif x == pos-1:\n        return total_ways * 2 % mod\n    else:\n        return total_ways * 3 % mod\n    \nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    dp = [[0]*mod for _ in range(n)]\n    \n    # Base case: one way to have the element at the desired position\n    dp[pos][1] = 1\n    \n    # Fill the DP table\n    for i in range(n-1, pos-1, -1):\n        dp[i][0] = (dp[i+1][0] + dp[i+1][1]) % mod\n        dp[i][1] = (dp[i+1][0] + dp[i+1][1] * (i+1)) % mod\n    \n    # The answer is the sum of ways to place the element at the desired position\n    return sum(dp[pos]) % mod\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of ways to choose positions for x\n    ways_to_choose_positions = (n - pos) * (n - pos - 1) // 2 % mod\n    \n    # Calculate the number of ways to arrange the remaining elements\n    ways_to_arrange_remaining = pow(2, n - pos - 2, mod)\n    \n    # Calculate the total number of valid permutations\n    total_valid_permutations = ways_to_choose_positions * ways_to_arrange_remaining % mod\n    \n    return total_valid_permutations\n\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of ways to choose the remaining positions for the other numbers\n    ways = (mod * (n - 1)) % mod\n    \n    # Calculate the number of ways to arrange the chosen numbers\n    arrangements = (mod * (n - pos)) % mod\n    \n    # Calculate the total number of valid permutations\n    total_permutations = (ways * arrangements) % mod\n    \n    return total_permutations\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    dp = [[0]*mod for _ in range(n+1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n+1):\n        for j in range(mod):\n            dp[i][j] = (dp[i-1][(j-x)%mod] + dp[i-1][(j+x)%mod]) % mod\n            \n    return dp[n][pos]\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    \n    def count_permutations(i, used):\n        if i == n:\n            return 1\n        \n        total_count = 0\n        for j in range(1, n + 1):\n            if not used[j-1]:\n                used[j-1] = True\n                if j == x:\n                    total_count += count_permutations(i + 1, used) % MOD\n                else:\n                    total_count += count_permutations(i + 1, used) % MOD\n                used[j-1] = False\n                \n        return total_count\n    \n    used = [False] * n\n    used[pos] = True\n    return count_permutations(1, used)\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of ways to choose the remaining positions for the other numbers\n    total_ways = pow(2, n-1, mod)\n    \n    # Calculate the number of ways to choose the position of x\n    x_position_ways = pow(2, pos, mod)\n    \n    # Calculate the number of ways to choose the remaining positions for the other numbers\n    remaining_positions_ways = pow(2, n-pos-1, mod)\n    \n    # Calculate the number of ways to arrange the remaining numbers\n    remaining_numbers_ways = pow(n, n-pos-1, mod)\n    \n    # Calculate the number of valid permutations\n    valid_permutations = (total_ways * x_position_ways * remaining_positions_ways * remaining_numbers_ways) % mod\n    \n    return valid_permutations\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of valid permutations\n    count = 0\n    for i in range(1, n + 1):\n        if i == x:\n            continue\n        count += (i * (n - i)) % MOD\n    \n    # Adjust for the position of x\n    if pos == 0:\n        count -= (n - x) % MOD\n    elif pos == n - 1:\n        count -= x % MOD\n    else:\n        count -= (x * (n - x - 1)) % MOD\n    \n    return count % MOD\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Base case: empty permutation\n    dp[0][0] = 1\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i >= j:\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD\n                \n    # Calculate the number of valid permutations\n    total_permutations = dp[n][x]\n    \n    # Adjust for the specific position requirement\n    if pos < x:\n        total_permutations = (total_permutations * (n - x)) % MOD\n    \n    # Print the result\n    print(total_permutations)\n\n# Main function\nif True:\n    n, x, pos = map(int, input().split())\n    solve(n, x, pos)",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    if x == pos:\n        return 1\n    if x > pos:\n        return 0\n    if x < pos:\n        return (mod - solve(n-1, x, pos)) % mod\n    \nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "def bin_search_permutations(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the total number of permutations of length n\n    total_permutations = n * (n - 1) // 2\n    \n    # If x is not present in the first pos positions, we need to subtract the number of invalid permutations\n    if pos > 0:\n        invalid_permutations = (pos - 1) * (pos - 2) // 2\n    else:\n        invalid_permutations = 0\n    \n    # Calculate the number of valid permutations\n    valid_permutations = total_permutations - invalid_permutations\n    \n    # Return the remainder of the division of the number of valid permutations by 10^9+7\n    return valid_permutations % mod\n\n# Read input\ninput_data = list(map(int, input().split()))\n\n# Call the function with the input data\nresult = bin_search_permutations(*input_data)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Base case: There's one way to arrange all numbers except the target\n    for i in range(1, n + 1):\n        dp[i][i] = 1\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if i == j:\n                dp[i][j] = 1\n            elif i < j:\n                dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod\n    \n    # Calculate the number of valid permutations\n    total_permutations = dp[n][n]\n    if pos != 0:\n        total_permutations -= dp[pos][pos - 1] % mod\n    if pos != n - 1:\n        total_permutations -= dp[n - 1][pos + 1] % mod\n    \n    return total_permutations % mod\n\n# Main function to handle input and call the solution function\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    x = int(data[1])\n    pos = int(data[2])\n    result = solve(n, x, pos)\n    print(result)\n\nif True:\n    main()",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of ways to choose positions for x\n    ways_to_choose_positions = (n - pos) * (n - pos - 1) // 2 % mod\n    \n    # Calculate the number of ways to arrange the remaining elements\n    ways_to_arrange_remaining = pow(n - 1, n - pos - 2, mod)\n    \n    # Total number of valid permutations\n    total_valid_permutations = ways_to_choose_positions * ways_to_arrange_remaining % mod\n    \n    return total_valid_permutations\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of ways to choose positions for x\n    # The remaining positions can be filled with any other numbers\n    # We use comb(n, pos) for choosing positions for x\n    # and (n - pos)! for filling the remaining positions\n    num_ways = comb(n, pos) * factorial(n - pos) % mod\n    \n    return num_ways\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, x, pos = data\n    print(solve(n, x, pos))\n\nif True:\n    main()",
    "def bin_search_permutations(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of ways to choose positions for x\n    ways_to_choose_pos = (n - pos) * (n - pos - 1) // 2 % MOD\n    \n    # Calculate the number of ways to arrange the remaining numbers\n    ways_to_arrange_remaining = factorial(n - pos - 1) % MOD\n    \n    # Calculate the total number of valid permutations\n    total_valid_permutations = ways_to_choose_pos * ways_to_arrange_remaining % MOD\n    \n    return total_valid_permutations\n\n\n# Main function to handle input and call the solution function\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    pos = int(data[2])\n    \n    result = bin_search_permutations(n, x, pos)\n    print(result)\n\n\n# Function to calculate factorial using recursion\ndef factorial(num):\n    if num == 0:\n        return 1\n    else:\n        return num * factorial(num - 1)\n\n\nif True:\n    main()",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            if j != pos and a[j] <= x:\n                dp[i] = (dp[i] + dp[j]) % mod\n    \n    return dp[n]\n\nif True:\n    n, x, pos = map(int, input().split())\n    a = list(range(1, n + 1))\n    print(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    if x < pos:\n        return 0\n    if x == pos:\n        return 1\n    if n == 1:\n        return 0\n    \n    # Calculate the number of ways to place x in the first pos positions\n    count = 0\n    for i in range(pos):\n        count += (i + 1) * (n - i)\n    \n    # Calculate the number of ways to place x in the last n-pos positions\n    for i in range(n - pos + 1):\n        count += (i + 1) * (n - i)\n    \n    # Subtract the overlapping cases where x is placed in both first pos and last n-pos positions\n    count -= pos * (n - pos)\n    \n    # Return the result modulo 10^9 + 7\n    return count % mod\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Print the result\nprint(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of valid permutations\n    count = (n - 1) * (mod - 1) // (n - pos - 1)\n    \n    return count % mod\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Print the result\nprint(solve(n, x, pos))",
    "from math import comb\n\ndef solve(n, x, pos):\n    # Calculate the number of ways to choose the remaining positions\n    remaining_positions = comb(n-1, pos)\n    \n    # Calculate the number of ways to arrange the remaining numbers\n    remaining_numbers = comb(x-1, x-pos-1) * comb(n-x, x-pos-1)\n    \n    # The total number of valid permutations\n    total_permutations = remaining_positions * remaining_numbers\n    \n    # Return the result modulo 10^9 + 7\n    return total_permutations % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of ways to choose positions for x\n    ways_to_choose_pos = (n - pos) * (n - pos - 1) // 2 % MOD\n    \n    # Calculate the number of ways to arrange the remaining numbers\n    ways_to_arrange_remaining = factorial(n - pos - 1) % MOD\n    \n    # Calculate the total number of valid permutations\n    total_valid_permutations = (ways_to_choose_pos * ways_to_arrange_remaining) % MOD\n    \n    return total_valid_permutations\n\n\ndef factorial(num):\n    if num == 0:\n        return 1\n    result = 1\n    for i in range(1, num + 1):\n        result = (result * i) % MOD\n    return result\n\n\nif True:\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n, x, pos = map(int, data)\n    print(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    if pos == 0:\n        return (n - 1) * pow(x, n - 1, mod) % mod\n    elif pos == n - 1:\n        return (n - 1) * pow(1 - x, n - 1, mod) % mod\n    else:\n        return pow(x, pos, mod) * pow(1 - x, n - pos - 1, mod) % mod\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    # Calculate the number of ways to choose positions for x\n    ways_to_choose_positions = (n - pos) * (n - pos - 1) // 2 % MOD\n    # Calculate the number of ways to arrange the remaining numbers\n    ways_to_arrange_remaining = factorial(n - pos - 1) % MOD\n    # Calculate the total number of valid permutations\n    total_permutations = (ways_to_choose_positions * ways_to_arrange_remaining) % MOD\n    return total_permutations\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Print the result\nprint(solve(n, x, pos))",
    "def bin_search_permutations(n, x, pos):\n    mod = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        if i == x:\n            dp[i] = (dp[i] + dp[pos]) % mod\n        else:\n            dp[i] = (dp[i] + dp[i - 1]) % mod\n    \n    return dp[n]\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Print the result\nprint(bin_search_permutations(n, x, pos))",
    "def bin_search_permutations(n, x, pos):\n    mod = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            if j + 1 <= pos and a[j] <= x:\n                dp[i] += dp[j]\n                dp[i] %= mod\n    \n    return dp[n]\n\nif True:\n    n, x, pos = map(int, input().split())\n    a = list(range(1, n + 1))\n    print(bin_search_permutations(n, x, pos))",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of ways to choose positions for x\n    ways_to_choose_positions = n - pos\n    \n    # Calculate the number of valid permutations\n    valid_permutations = pow(ways_to_choose_positions, x - 1, MOD) * pow(x - 1, n - x - 1, MOD) % MOD\n    \n    return valid_permutations\n\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def bin_search_permutations(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of ways to choose positions for x\n    ways_to_choose_pos = n - pos\n    \n    # Calculate the number of ways to arrange the remaining elements\n    ways_to_arrange_remaining = factorial(n - pos)\n    \n    # Calculate the total number of valid permutations\n    total_valid_permutations = (ways_to_choose_pos * ways_to_arrange_remaining) % MOD\n    \n    return total_valid_permutations\n\n# Example usage:\nprint(bin_search_permutations(4, 1, 2))  # Output: 6\nprint(bin_search_permutations(123, 42, 24))  # Output: 824071958",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    \n    def count_permutations(i, used, target_pos):\n        if i == n:\n            return 1 if target_pos == pos else 0\n        \n        ans = 0\n        for j in range(1, n + 1):\n            if j not in used and j != target_pos:\n                new_used = used | {j}\n                ans += count_permutations(i + 1, new_used, target_pos)\n        \n        return ans % MOD\n    \n    return count_permutations(0, set(), x)\n\nif True:\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    x = int(data[1])\n    pos = int(data[2])\n    print(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    # Calculate the number of ways to choose the remaining positions for the other numbers\n    total_ways = (n - 1) * (n - 2) // 2 % mod\n    \n    # Calculate the number of ways to place the target number at the specified position\n    target_position_ways = 1\n    \n    # Calculate the number of ways to arrange the remaining numbers\n    remaining_numbers_ways = 1\n    \n    # If the target number is not at the specified position, we need to calculate the number of ways to place it there\n    if pos != 0:\n        target_position_ways = n - pos % n\n    \n    # Calculate the number of ways to arrange the remaining numbers\n    remaining_numbers_ways = factorial(n - pos - 1) % mod\n    \n    # Calculate the final answer\n    final_answer = (total_ways * target_position_ways * remaining_numbers_ways) % mod\n    \n    return final_answer\n\ndef factorial(num):\n    if num == 0:\n        return 1\n    else:\n        return num * factorial(num - 1)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    # Calculate the number of valid permutations\n    # The number of ways to choose the positions of x and the other elements\n    # is C(n-1, pos-1) * C(n-1-pos, n-1-pos-1)\n    # The remaining elements can be arranged in any order\n    count = ((n-1)*(n-2)//2) % MOD\n    for i in range(pos):\n        count *= (i+1) % MOD\n    for i in range(n-1-pos):\n        count *= (n-i) % MOD\n    # Multiply by the number of ways to arrange the remaining elements\n    count *= factorial(n-1-pos)\n    # Return the remainder of the division by MOD\n    return count % MOD\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "from math import comb\n\ndef solve(n, x, pos):\n    # Calculate the number of ways to choose the remaining elements\n    remaining_elements = comb(n - 1, x - 1)\n    \n    # Calculate the number of valid permutations\n    valid_permutations = remaining_elements * comb(n - pos - 1, x - 1)\n    \n    # Return the remainder of the division by 10^9+7\n    return valid_permutations % (10**9 + 7)\n\n# Read input\ninput_data = list(map(int, input().split()))\n\n# Solve the problem\nresult = solve(*input_data)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of ways to choose the remaining positions for the other numbers\n    ways_to_choose_remaining_positions = (n - 1) * (n - 2) // 2\n    \n    # If x is at the correct position, we need to choose the remaining positions for the other numbers\n    # We also need to ensure that the remaining positions do not include the position where x is already placed\n    if pos == x:\n        ways_to_choose_remaining_positions -= (n - pos - 1) * (n - pos - 2) // 2\n    \n    # The total number of valid permutations is the product of the number of ways to choose the remaining positions\n    # and the number of ways to place x at the correct position\n    result = (ways_to_choose_remaining_positions * (n - pos)) % MOD\n    \n    return result\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    if x == pos:\n        return 1\n    elif x < pos:\n        return (solve(n-1, x, pos) * (n - pos)) % mod\n    else:\n        return (solve(n-1, x, pos-1) * pos) % mod\n\ndef main():\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))\n\nif True:\n    main()",
    "from math import comb\n\ndef solve(n, x, pos):\n    # Calculate the total number of ways to choose 'pos' positions out of 'n'\n    total_ways = comb(n, pos)\n    \n    # Calculate the number of ways to place 'x' in the chosen positions\n    ways_to_place_x = comb(pos, x)\n    \n    # The final answer is the product of these two values modulo 10^9 + 7\n    return (total_ways * ways_to_place_x) % (10**9 + 7)\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    if pos == 0:\n        return 1\n    if pos == n-1:\n        return n-1\n    if x == pos:\n        return 1\n    if x == pos-1:\n        return n-2\n    if x == pos+1:\n        return n-2\n    if x < pos:\n        return solve(pos, x, pos-1) * (n-1-x) % mod\n    if x > pos:\n        return solve(pos, x, pos+1) * (x-1) % mod",
    "from math import comb, pow\n\ndef solve(n, x, pos):\n    # Calculate the number of ways to choose positions for x excluding the specified position\n    ways_to_choose_positions = comb(n-1, pos-1)\n    \n    # Calculate the number of valid permutations for each chosen position of x\n    valid_permutations = pow(ways_to_choose_positions, x, 10**9+7)\n    \n    # Return the total number of valid permutations modulo 10^9+7\n    return valid_permutations\n\n# Read input\ninput_data = list(map(int, input().split()))\n\n# Solve the problem\nresult = solve(*input_data)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of ways to choose the remaining positions\n    total_ways = (n - 1) * (n - 2) // 2 % MOD\n    \n    # Calculate the number of ways to place x at the required position\n    if pos == 0:\n        ways_to_place_x = 1\n    elif pos == n - 1:\n        ways_to_place_x = 1\n    else:\n        ways_to_place_x = (n - 2) % MOD\n    \n    # Calculate the final number of valid permutations\n    final_ways = (total_ways * ways_to_place_x) % MOD\n    \n    return final_ways\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of ways to place x at pos\n    ways_at_pos = (n - pos) * (mod - 1) % mod\n    \n    # Calculate the number of ways to arrange the remaining elements\n    arrangements = (n - 1) * (mod - 1) % mod\n    \n    # Total number of valid permutations\n    total_permutations = ways_at_pos * arrangements % mod\n    \n    return total_permutations\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve and print the result\nprint(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of ways to place x at pos\n    ways_to_place_x = 1\n    for i in range(pos):\n        ways_to_place_x *= i\n        ways_to_place_x %= mod\n    \n    # Calculate the number of ways to arrange the remaining numbers\n    remaining_numbers = n - pos - 1\n    ways_to_arrange_remaining = 1\n    for i in range(remaining_numbers):\n        ways_to_arrange_remaining *= i\n        ways_to_arrange_remaining %= mod\n    \n    # Total number of valid permutations\n    total_permutations = ways_to_place_x * ways_to_arrange_remaining\n    total_permutations %= mod\n    \n    return total_permutations\n\n# Read input\ninput_data = input().split()\nn = int(input_data[0])\nx = int(input_data[1])\npos = int(input_data[2])\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "from math import comb\n\ndef solve(n, x, pos):\n    # Calculate the number of ways to choose the remaining positions for the other numbers\n    ways = comb(n-1, pos)\n    \n    # Calculate the number of valid permutations\n    valid_permutations = ways * comb(1, x-pos)\n    \n    # Return the result modulo 10^9+7\n    return valid_permutations % (10**9+7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def bin_search_permutations(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of valid permutations\n    count = 0\n    for i in range(1, n + 1):\n        if i == x:\n            continue\n        count += binomial_coefficient(n - 1, pos - 1)\n    \n    return count % mod\n\ndef binomial_coefficient(n, k):\n    if k > n // 2:\n        k = n - k\n    result = 1\n    for i in range(1, k + 1):\n        result *= (n - i + 1)\n        result //= i\n    return result\n\ndef main():\n    input_values = list(map(int, input().split()))\n    n, x, pos = input_values\n    result = bin_search_permutations(n, x, pos)\n    print(result)\n\nif True:\n    main()",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    # Calculate the number of ways to choose the positions of x before pos\n    ways_before_pos = (n - pos) * (n - pos - 1) // 2 % MOD\n    # Calculate the number of ways to choose the positions of x after pos\n    ways_after_pos = (n - pos - 1) * (n - pos - 2) // 2 % MOD\n    # Calculate the total number of valid permutations\n    total_ways = (ways_before_pos + ways_after_pos) % MOD\n    return total_ways\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of ways to choose the remaining elements\n    ways = pow(2, n-1, MOD)\n    \n    # Calculate the number of ways to place the element at the specified position\n    if pos == 0:\n        ways *= n\n    elif pos == n-1:\n        ways *= n\n    else:\n        ways *= n * (n-1)\n    \n    # Calculate the number of ways to arrange the remaining elements\n    arrangements = pow(n, n-1, MOD)\n    \n    # Calculate the total number of valid permutations\n    total = (ways * arrangements) % MOD\n    \n    return total\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)"
  ],
  "rewards": [
    0.0,
    0.0,
    0.05,
    0.0,
    0.0,
    0.025,
    0.0,
    0.0,
    0.0,
    0.0,
    0.025,
    0.05,
    0.0,
    0.0,
    0.0,
    0.0,
    0.05,
    0.025,
    0.0,
    0.0,
    0.025,
    0.0,
    0.025,
    0.025,
    0.025,
    0.0,
    0.025,
    0.0,
    0.025,
    0.0,
    0.05,
    0.025,
    0.025,
    0.0,
    0.0,
    0.025,
    0.0,
    0.025,
    0.0,
    0.0,
    0.025,
    0.0,
    0.0,
    0.025,
    0.0,
    0.05,
    0.025,
    0.0,
    0.025,
    0.0
  ],
  "train rewards": [
    0.025,
    0.05,
    0.2,
    0.0,
    0.15,
    0.05,
    0.0,
    0.05,
    0.075,
    0.0,
    0.025,
    0.2,
    0.0,
    0.0,
    0.025,
    0.025,
    0.2,
    0.175,
    0.05,
    0.15,
    0.025,
    0.0,
    0.025,
    0.075,
    0.125,
    0.0,
    0.175,
    0.025,
    0.075,
    0.0,
    0.1,
    0.075,
    0.125,
    0.0,
    0.0,
    0.075,
    0.025,
    0.15,
    0.075,
    0.05,
    0.125,
    0.0,
    0.0,
    0.075,
    0.05,
    0.225,
    0.2,
    0.05,
    0.025,
    0.025
  ],
  "time": 276.6733295917511,
  "sample times": 50
}