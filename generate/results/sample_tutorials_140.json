{
  "prompt": "\nQUESTION:\nThe mayor of the Central Town wants to modernize Central Street, represented in this problem by the $(Ox)$ axis.\n\nOn this street, there are $n$ antennas, numbered from $1$ to $n$. The $i$-th antenna lies on the position $x_i$ and has an initial scope of $s_i$: it covers all integer positions inside the interval $[x_i - s_i; x_i + s_i]$.\n\nIt is possible to increment the scope of any antenna by $1$, this operation costs $1$ coin. We can do this operation as much as we want (multiple times on the same antenna if we want).\n\nTo modernize the street, we need to make all integer positions from $1$ to $m$ inclusive covered by at least one antenna. Note that it is authorized to cover positions outside $[1; m]$, even if it's not required.\n\nWhat is the minimum amount of coins needed to achieve this modernization?\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\le 80$ and $n \\le m \\le 100\\ 000$).\n\nThe $i$-th of the next $n$ lines contains two integers $x_i$ and $s_i$ ($1 \\le x_i \\le m$ and $0 \\le s_i \\le m$).\n\nOn each position, there is at most one antenna (values $x_i$ are pairwise distinct).\n\n\n-----Output-----\n\nYou have to output a single integer: the minimum amount of coins required to make all integer positions from $1$ to $m$ inclusive covered by at least one antenna.\n\n\n-----Examples-----\nInput\n3 595\n43 2\n300 4\n554 10\n\nOutput\n281\n\nInput\n1 1\n1 1\n\nOutput\n0\n\nInput\n2 50\n20 0\n3 1\n\nOutput\n30\n\nInput\n5 240\n13 0\n50 25\n60 5\n155 70\n165 70\n\nOutput\n26\n\n\n\n-----Note-----\n\nIn the first example, here is a possible strategy:\n\n  Increase the scope of the first antenna by $40$, so that it becomes $2 + 40 = 42$. This antenna will cover interval $[43 - 42; 43 + 42]$ which is $[1; 85]$  Increase the scope of the second antenna by $210$, so that it becomes $4 + 210 = 214$. This antenna will cover interval $[300 - 214; 300 + 214]$, which is $[86; 514]$  Increase the scope of the third antenna by $31$, so that it becomes $10 + 31 = 41$. This antenna will cover interval $[554 - 41; 554 + 41]$, which is $[513; 595]$ \n\nTotal cost is $40 + 210 + 31 = 281$. We can prove that it's the minimum cost required to make all positions from $1$ to $595$ covered by at least one antenna.\n\nNote that positions $513$ and $514$ are in this solution covered by two different antennas, but it's not important.\n\n\u2014\n\nIn the second example, the first antenna already covers an interval $[0; 2]$ so we have nothing to do.\n\nNote that the only position that we needed to cover was position $1$; positions $0$ and $2$ are covered, but it's not important.\n\nTUTORIAL:\nWe can add an antenna (x = 0, s = 0). It will not modify the answer, because it would be non-optimal to increase the scope of this antenna.\n\nLet dp\u2093 be the minimum cost to cover all positions from x to m inclusive, knowing that position x is covered. We compute dp in decreasing order of x.\n\nBase case is dp\u2098 := 0.\n\nThe default transition is dp\u2093 := (m \u2212 x).\n\nIf position x + 1 is initially covered, dp\u2093 := dp\u2093\u208a\u2081\n\nOtherwise, let's consider all antennas and their initial intervals [l\u1d62; r\u1d62]. If x < l\u1d62, let  \nu = (l\u1d62 \u2212 x \u2212 1), then a possible transition is dp\u2093 := u + dp\u2098\u1d62\u2099(m, r\u1d62 + u).\n\nWe take the minimum of all these transitions. Note that we always extend intervals as less as possible, but it's optimal because:\n\n\u2022 If after using this interval i, we use another interval j (at the right of i), the time spent to extend i could have been used to extend j instead, which will be more optimal.\n\u2022 If i was the last interval used, we don't care because the default transition will take care of this case.\n\nThe final answer will be dp\u2080.\n\nThere are O(m) states and O(n) transitions, hence final complexity is O(nm) with very low constant. O(n\u00b2 \u00b7 m) can also get AC because of very low constant.\n\n\nInstructions:\n\n\nYou are a Python3 code generator.  Output **only** valid Python code. No explanations, no commentary, no filenames, no Markdown formatting. You will spit out a code block that can be pasted into any script. It must read the input, execute the logic and then print the output. Ensure that you invoke the main() or solve() function at the end if you're writing your code inside them.\nANSWER:\n",
  "codes": [
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    data = data[2:]\n    antennas = []\n    for i in range(n):\n        antennas.append((data[i * 2], data[i * 2 + 1]))\n    antennas.sort(key=lambda x: x[0])\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x >= s:\n                dp[x] = min(dp[x], dp[x + s] + 1)\n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Add an antenna at position 0 with scope 0\n    antennas.insert(0, (0, 0))\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m, -1, -1):\n        # Default transition\n        dp[x] = m - x\n        \n        # Check all antennas and their intervals\n        for _, s in antennas:\n            if x + s <= m:\n                dp[x] = min(dp[x], dp[x + s])\n            else:\n                # Extend intervals as less as possible\n                u = max(x - s, 0)\n                dp[x] = min(dp[x], u + dp[m - s])\n    \n    # Print the minimum cost\n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Add an antenna (x = 0, s = 0)\n    antennas.insert(0, (0, 0))\n    \n    # DP table: dp[x] is the minimum cost to cover all positions from x to m inclusive\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp in decreasing order of x\n    for x in range(m, -1, -1):\n        if x == m:\n            continue\n        \n        # Default transition\n        dp[x] = m - x\n        \n        # Consider all antennas and their initial intervals [l_i; r_i]\n        for _, s in antennas:\n            if x < s:\n                u = s - x - 1\n                dp[x] = min(dp[x], u + dp[m - s])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i], data[i+1]) for i in range(2*n)]\n    \n    def dp(x):\n        if x == m:\n            return 0\n        res = m - x\n        for l, r in antennas:\n            if x < l:\n                u = l - x - 1\n                res = min(res, u + dp(m, r + u))\n            elif x >= l and x <= r:\n                res = min(res, dp(l, r))\n        return res\n    \n    print(dp(0))\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by increasing x value\n    antennas.sort()\n    \n    # Initialize DP array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x + s > m:\n                continue\n            dp[x] = min(dp[x], dp[x + s])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    data = data[2:]\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m - 1, -1, -1):\n        dp[x] = min(dp[x], m - x)\n        \n        for i in range(len(data)):\n            x_i, s_i = data[i]\n            if x <= x_i - s_i:\n                dp[x] = min(dp[x], dp[x + 1])\n            elif x >= x_i + s_i:\n                dp[x] = min(dp[x], dp[x - 1])\n            else:\n                for l_i in range(x_i - s_i, x_i + s_i + 1):\n                    for r_i in range(l_i + 1, x_i + s_i + 1):\n                        if l_i <= x <= r_i:\n                            dp[x] = min(dp[x], dp[l_i] + dp[r_i] - (r_i - l_i))\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Add an antenna (x = 0, s = 0)\n    antennas.insert(0, (0, 0))\n    \n    # DP array to store the minimum cost to cover all positions from x to m inclusive\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp in decreasing order of x\n    for x in range(m, -1, -1):\n        # Default transition\n        dp[x] = min(dp[x], m - x)\n        \n        # Consider all antennas and their initial intervals [l\u1d62; r\u1d62]\n        for _, s in antennas:\n            if x < s:\n                u = s - x - 1\n                dp[x] = min(dp[x], u + dp[m - s])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    data = data[2:]\n    antennas = [(data[i], data[i+1]) for i in range(0, len(data), 2)]\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Iterate over positions in reverse order\n    for x in range(m-1, -1, -1):\n        # Update dp[x] with the default transition\n        dp[x] = min(dp[x], m - x)\n        \n        # Check if position x+1 is initially covered\n        if dp[x+1] != float('inf'):\n            continue\n        \n        # Consider all antennas\n        for l, r in antennas:\n            if x < l:\n                u = l - x - 1\n                dp[x] = min(dp[x], u + dp[m-l])\n    \n    # Print the result\n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    data = data[2:]\n    positions = [(data[i], data[i+1]) for i in range(0, len(data), 2)]\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Add a dummy antenna at position 0 with scope 0\n    positions.append((0, 0))\n    \n    # Sort positions by x-coordinate\n    positions.sort()\n    \n    # Process positions\n    for x, s in positions:\n        for i in range(x, m + 1):\n            dp[i] = min(dp[i], dp[x - 1] + max(0, s - (i - x)))\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    data = data[2:]\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Add an antenna at position 0 with scope 0\n    for i in range(n):\n        x, s = data[i * 2], data[i * 2 + 1]\n        dp[x] = min(dp[x], dp[m])\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m - 1, -1, -1):\n        if dp[x] == float('inf'):\n            continue\n        \n        for i in range(n):\n            y, s = data[i * 2], data[i * 2 + 1]\n            if x < y:\n                u = y - x - 1\n                dp[x] = min(dp[x], u + dp[m - s])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i*2], data[i*2+1]) for i in range(n)]\n    \n    def dp(x):\n        if x == m:\n            return 0\n        min_cost = m - x\n        for _, s in antennas:\n            if x + s <= m:\n                min_cost = min(min_cost, dp(x + s))\n        return min_cost\n    \n    print(dp(0))\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i*2], data[i*2+1]) for i in range(n)]\n    \n    def dp(x):\n        if x == m:\n            return 0\n        min_cost = m - x\n        for l, r in antennas:\n            if x < l:\n                u = l - x - 1\n                min_cost = min(min_cost, u + dp(m, r + u))\n            else:\n                for i in range(n):\n                    l, r = antennas[i]\n                    if x < l:\n                        break\n                    if x >= r:\n                        continue\n                    min_cost = min(min_cost, dp(x, r))\n        return min_cost\n    \n    print(dp(0))\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = []\n    for _ in range(n):\n        x, s = data[_ * 2:_ * 2 + 2]\n        antennas.append((x, s))\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x < s:\n                continue\n            u = max(0, x - s - 1)\n            dp[x] = min(dp[x], u + dp[m - s])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i], data[i+1]) for i in range(2, 2*n, 2)]\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m - 1, -1, -1):\n        if x == 0:\n            continue\n        \n        dp[x] = min(dp[x], m - x)\n        \n        for l, r in antennas:\n            if l <= x:\n                u = max(l - x - 1, 0)\n                dp[x] = min(dp[x], u + dp[m - r])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    data = data[2:]\n    antennas = []\n    for i in range(n):\n        x, s = data[i*2:i*2+2]\n        antennas.append((x, s))\n    \n    def dp(x):\n        if x == m:\n            return 0\n        res = m - x\n        for _, s in antennas:\n            if x < s:\n                res = min(res, s - x)\n            elif x >= s and x <= m - s:\n                res = min(res, dp(m - s))\n        return res\n    \n    print(dp(0))\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by their start positions in descending order\n    antennas.sort(key=lambda x: x[0], reverse=True)\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Iterate through each antenna\n    for _, s in antennas:\n        # Update dp array for positions covered by current antenna\n        for x in range(s, m + 1):\n            dp[x] = min(dp[x], dp[x - s])\n        \n        # Update dp array for positions not covered by current antenna\n        for x in range(1, s + 1):\n            dp[x] = min(dp[x], dp[x + s])\n    \n    # Print the minimum number of coins needed\n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i], data[i+1]) for i in range(2, 2*n, 2)]\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        for l, r in antennas:\n            if x < l:\n                u = l - x - 1\n                dp[x] = min(dp[x], u + dp[m-l])\n            else:\n                for i in range(len(dp)):\n                    if i >= x:\n                        break\n                    if i + r <= m:\n                        dp[x] = min(dp[x], dp[i] + (r - i))\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Add an antenna at position 0 with scope 0\n    antennas.insert(0, (0, 0))\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        if dp[x] == float('inf'):\n            continue\n        \n        for _, s in antennas:\n            if x + s > m:\n                break\n            if x + s >= x:\n                dp[x] = min(dp[x], dp[x + s])\n            else:\n                u = x + s - x - 1\n                dp[x] = min(dp[x], u + dp[m - (r + u)])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by their starting point\n    antennas.sort(key=lambda x: x[0])\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x + s <= m:\n                dp[x] = min(dp[x], dp[x + s] + s)\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    data = data[2:]\n    positions = []\n    scopes = []\n    for i in range(n):\n        positions.append(data[i * 2])\n        scopes.append(data[i * 2 + 1])\n    \n    # Add an antenna at position 0 with scope 0\n    positions.insert(0, 0)\n    scopes.insert(0, 0)\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        for i in range(len(positions)):\n            if x >= positions[i]:\n                u = max(x - positions[i] - 1, 0)\n                dp[x] = min(dp[x], u + dp[m - scopes[i]])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i], data[i+1]) for i in range(2, 2*n, 2)]\n    \n    def dp(x):\n        if x == m:\n            return 0\n        min_cost = m - x\n        for _, s in antennas:\n            if x + s <= m:\n                min_cost = min(min_cost, dp(x + s))\n        return min_cost\n    \n    print(dp(0))\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Add an antenna at position 0 with scope 0\n    antennas.insert(0, (0, 0))\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x < s:\n                continue\n            u = max(0, x - s - 1)\n            dp[x] = min(dp[x], u + dp[m - s])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = []\n    for _ in range(n):\n        x, s = data[_*2+2:]\n        antennas.append((x, s))\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        if x == m:\n            continue\n        \n        # Default transition\n        dp[x] = min(dp[x], m - x)\n        \n        # Consider all antennas\n        for _, s in antennas:\n            if x + 1 <= s:\n                u = s - x - 1\n                dp[x] = min(dp[x], u + dp[m - s])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    data = data[2:]\n    positions = [(data[i], data[i+1]) for i in range(0, len(data), 2)]\n    \n    def dp(x):\n        if x == m:\n            return 0\n        result = m - x\n        for pos, scope in positions:\n            if x < pos:\n                u = pos - x - 1\n                result = min(result, u + dp(m - pos))\n        return result\n    \n    print(dp(0))\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Add an antenna (x = 0, s = 0)\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x >= s:\n                u = x - s - 1\n                if u >= 0:\n                    dp[x] = min(dp[x], u + dp[m - s])\n                else:\n                    dp[x] = min(dp[x], dp[m])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i], data[i+1]) for i in range(2, 2*n, 2)]\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Iterate over positions in reverse order\n    for x in range(m, -1, -1):\n        # Base case\n        if dp[x] == float('inf'):\n            continue\n        \n        # Default transition\n        dp[x] += m - x\n        \n        # Consider all antennas\n        for l, r in antennas:\n            if l <= x < r:\n                # Calculate the number of positions to extend\n                u = (l - x - 1) if l > x else 0\n                # Update dp[x]\n                dp[x] = min(dp[x], u + dp[m - r])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    data = data[2:]\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Add a dummy antenna at x = 0 with s = 0\n    for i in range(n):\n        x, s = data[i*2], data[i*2+1]\n        dp[x] = min(dp[x], dp[x+s])\n    \n    # Compute dp values in decreasing order of x\n    for x in range(m-1, -1, -1):\n        if dp[x] == float('inf'):\n            continue\n        \n        for i in range(n):\n            l, r = data[i*2], data[i*2+1]\n            if x < l:\n                u = l - x - 1\n                dp[x] = min(dp[x], u + dp[m-l])\n            else:\n                dp[x] = min(dp[x], dp[m-r])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        if x == m:\n            continue\n        for _, s in antennas:\n            if x + 1 <= s + x:\n                dp[x] = min(dp[x], dp[x + 1])\n        \n        for i in range(len(antennas)):\n            x, s = antennas[i]\n            if x + 1 > s + x:\n                continue\n            u = max(x - s - 1, 0)\n            dp[x] = min(dp[x], u + dp[m - s - u])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Add an antenna at x=0, s=0\n    antennas.append((0, 0))\n    \n    # Sort antennas by their leftmost point in increasing order\n    antennas.sort(key=lambda x: x[0])\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        if x == m:\n            continue\n        \n        for _, s in antennas:\n            if x + s <= m:\n                dp[x] = min(dp[x], dp[x + s] + s)\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i], data[i+1]) for i in range(2*n)]\n    \n    # Sort antennas by their start points\n    antennas.sort(key=lambda x: x[0])\n    \n    # DP array where dp[x] represents the minimum cost to cover all positions from x to m\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x >= s:\n                dp[x] = min(dp[x], dp[x-s] + 1)\n                \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    data = data[2:]\n    positions = []\n    for i in range(n):\n        positions.append((data[i*2], data[i*2+1]))\n    positions.sort()\n    \n    dp = [float('inf')] * (m+1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        for pos, s in positions:\n            if x < pos:\n                continue\n            if pos + s > m:\n                break\n            if x == pos:\n                dp[x] = min(dp[x], dp[pos+s])\n            else:\n                u = pos - x - 1\n                if u >= 0:\n                    dp[x] = min(dp[x], u + dp[m-s])\n                for i in range(pos+1, pos+s+1):\n                    dp[x] = min(dp[x], dp[i])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i], data[i+1]) for i in range(2*n, 2*n+2*n)]\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x + s <= m:\n                dp[x] = min(dp[x], dp[x+s] + 1)\n            else:\n                for l, r in antennas:\n                    if x < l:\n                        u = (l - x - 1)\n                        dp[x] = min(dp[x], u + dp[m-r])\n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Add an antenna at position 0 with scope 0\n    antennas.append((0, 0))\n    \n    # Sort antennas by their leftmost position\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize DP table\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Fill DP table\n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x + s <= m:\n                dp[x] = min(dp[x], dp[x + s] + 1)\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by x in descending order\n    antennas.sort(key=lambda x: x[0], reverse=True)\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x + s > m:\n                continue\n            \n            # Default transition\n            dp[x] = min(dp[x], m - x)\n            \n            # Transition if position x + 1 is initially covered\n            if x + 1 <= m:\n                dp[x] = min(dp[x], dp[x + 1])\n            \n            # Transition for other antennas\n            for l, r in antennas:\n                if x < l:\n                    u = l - x - 1\n                    dp[x] = min(dp[x], u + dp[m - r])\n                \n                elif x >= l and x <= r:\n                    dp[x] = min(dp[x], dp[m - r])\n                    \n                elif x > r:\n                    dp[x] = min(dp[x], dp[x - s])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Add an antenna at position 0 with scope 0\n    antennas.insert(0, (0, 0))\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        if x == 0:\n            continue\n        \n        # Default transition\n        dp[x] = min(dp[x], m - x)\n        \n        # Consider all antennas and their initial intervals\n        for _, s in antennas:\n            if x + 1 <= s:\n                u = s - x - 1\n                dp[x] = min(dp[x], u + dp[m - s])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = []\n    for _ in range(n):\n        x, s = data[_ * 2 + 2:]\n        antennas.append((x, s))\n    \n    def dp(x):\n        if x == m:\n            return 0\n        min_cost = m - x\n        for _, s in antennas:\n            if x < s:\n                continue\n            left, right = max(0, x - s), min(m, x + s)\n            if left <= right:\n                cost = left + dp(right - left)\n                if cost < min_cost:\n                    min_cost = cost\n        return min_cost\n    \n    print(dp(0))\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = []\n    for i in range(n):\n        x, s = data[i * 2:i * 2 + 2]\n        antennas.append((x, s))\n    \n    def dp(x, m):\n        if x > m:\n            return 0\n        if dp[x][m] != float('inf'):\n            return dp[x][m]\n        \n        min_cost = m - x\n        \n        for _, s in antennas:\n            if x < s:\n                u = s - x - 1\n                min_cost = min(min_cost, u + dp[m - s, m])\n        \n        dp[x][m] = min_cost\n        return dp[x][m]\n    \n    dp = [[float('inf')] * (m + 1) for _ in range(m + 1)]\n    dp[m][m] = 0\n    \n    for x in range(m, -1, -1):\n        for m in range(x, m + 1):\n            dp[x][m] = dp[x][m - 1]\n            for _, s in antennas:\n                if x < s:\n                    u = s - x - 1\n                    dp[x][m] = min(dp[x][m], u + dp[m - s, m])\n    \n    print(dp[0][m])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i], data[i+1]) for i in range(2, 2*n, 2)]\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Iterate over positions in reverse order\n    for x in range(m - 1, -1, -1):\n        # Base case: if x is already covered, no cost\n        if dp[x] == float('inf'):\n            continue\n        \n        # Default transition: cover x to m\n        dp[x] += m - x\n        \n        # Check each antenna\n        for x_i, s_i in antennas:\n            if x <= x_i <= m + s_i:\n                u = max(x_i - x - 1, 0)\n                dp[x] = min(dp[x], u + dp[m - i])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Add an antenna (x = 0, s = 0)\n    antennas.insert(0, (0, 0))\n    \n    # DP table where dp[x] is the minimum cost to cover all positions from x to m inclusive, knowing that position x is covered\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Compute DP in decreasing order of x\n    for x in range(m, -1, -1):\n        # Default transition\n        dp[x] = m - x\n        \n        # Consider all antennas and their initial intervals [l_i; r_i]\n        for _, s in antennas:\n            if x < s:\n                u = s - x - 1\n                dp[x] = min(dp[x], u + dp[m - s])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by x in descending order\n    antennas.sort(key=lambda x: x[0], reverse=True)\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x < s:\n                continue\n            dp[x] = min(dp[x], dp[x + s])\n        \n        if x == 0:\n            dp[0] = 0\n    \n    return dp[0]\n\nif True:\n    print(solve())",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m - 1, -1, -1):\n        if x + 1 <= m and dp[x + 1] == 0:\n            dp[x] = 0\n        else:\n            for x1, s1 in antennas:\n                if x < x1:\n                    u = x1 - x - 1\n                    dp[x] = min(dp[x], u + dp[m - s1])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        for _, s in antennas:\n            if x >= s and x + s <= m:\n                dp[x] = min(dp[x], dp[x + s])\n        \n        for i in range(x + 1, m + 1):\n            u = max(0, i - x - 1)\n            dp[i] = min(dp[i], u + dp[m - i + 1])\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by their starting points in descending order\n    antennas.sort(key=lambda x: x[0], reverse=True)\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        if x == m:\n            continue\n        \n        for _, s in antennas:\n            if x < s:\n                u = (s - x - 1)\n                dp[x] = min(dp[x], u + dp[m - s])\n            else:\n                for i in range(len(antennas)):\n                    if x < antennas[i][0]:\n                        break\n                    l, r = antennas[i]\n                    if x >= l and x <= r:\n                        dp[x] = min(dp[x], dp[r + 1] - (r - x + 1))\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    n, m = map(int, input().split())\n    antennas = []\n    for _ in range(n):\n        x, s = map(int, input().split())\n        antennas.append((x, s))\n    \n    # Sort antennas by x in descending order\n    antennas.sort(key=lambda x: x[0], reverse=True)\n    \n    # Initialize dp array\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    # Iterate over sorted antennas\n    for _, s in antennas:\n        # Update dp values based on current antenna\n        for i in range(s, m + 1):\n            dp[i] = min(dp[i], dp[i - s] + s)\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = []\n    for _ in range(n):\n        x, s = data[_ * 2 + 2:]\n        antennas.append((x, s))\n    \n    def dp(x, m):\n        if x == m:\n            return 0\n        min_cost = m - x\n        for x1, s1 in antennas:\n            if x1 <= x < x1 + s1:\n                if x1 > x:\n                    min_cost = min(min_cost, dp(x1 + 1, m))\n                else:\n                    min_cost = min(min_cost, dp(x + s1, m))\n        return min_cost\n    \n    print(dp(0, m))\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = []\n    for i in range(2, len(data), 2):\n        antennas.append((data[i], data[i+1]))\n    \n    def dp(x):\n        if x == m:\n            return 0\n        res = m - x\n        for _, s in antennas:\n            if x < s:\n                u = s - x - 1\n                res = min(res, u + dp(m - s))\n        return res\n    \n    print(dp(0))\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = []\n    for _ in range(n):\n        x, s = data[_ * 2 + 2:_ * 2 + 4]\n        antennas.append((x, s))\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    for x in range(m - 1, -1, -1):\n        if any(x >= l and x <= r for l, r in antennas):\n            dp[x] = min(dp[x], dp[x + 1])\n        else:\n            for l, r in antennas:\n                if x < l:\n                    u = (l - x - 1)\n                    dp[x] = min(dp[x], u + dp[m - r + u])\n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = [(data[i+2], data[i+3]) for i in range(2*n)]\n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    for x in range(m, -1, -1):\n        if x == m:\n            continue\n        if x + 1 <= m:\n            dp[x] = min(dp[x], dp[x + 1])\n        for _, s in antennas:\n            if x < s:\n                u = s - x - 1\n                if x + u <= m:\n                    dp[x] = min(dp[x], u + dp[m - s + u])\n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    antennas = []\n    for i in range(2, len(data), 2):\n        antennas.append((data[i], data[i+1]))\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m, -1, -1):\n        if dp[x] != float('inf'):\n            for l, r in antennas:\n                if x < l:\n                    u = (l - x - 1)\n                    dp[x] = min(dp[x], u + dp[m - r])\n                else:\n                    for i in range(x, r + 1):\n                        if dp[i] == float('inf'):\n                            continue\n                        dp[x] = min(dp[x], dp[i] + m - r)\n    \n    print(dp[0])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, m = data[:2]\n    data = data[2:]\n    positions = [(data[i], data[i+1]) for i in range(0, len(data), 2)]\n    \n    dp = [float('inf')] * (m + 1)\n    dp[m] = 0\n    \n    for x in range(m - 1, -1, -1):\n        if x + 1 in positions:\n            dp[x] = dp[x + 1]\n        \n        else:\n            min_cost = float('inf')\n            for pos, scope in positions:\n                if x < pos:\n                    u = pos - x - 1\n                    min_cost = min(min_cost, u + dp[m - scope])\n            dp[x] = min_cost\n    \n    print(dp[0])\n\nif True:\n    solve()"
  ],
  "rewards": [
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.045454545454545456,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0
  ],
  "train rewards": [
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.045454545454545456,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0
  ],
  "time": 317.62525177001953,
  "sample times": 50
}