{
  "prompt": "\nQUESTION:\nYou have a set of items, each having some integer weight not greater than $8$. You denote that a subset of items is good if total weight of items in the subset does not exceed $W$.\n\nYou want to calculate the maximum possible weight of a good subset of items. Note that you have to consider the empty set and the original set when calculating the answer.\n\n\n-----Input-----\n\nThe first line contains one integer $W$ ($0 \\le W \\le 10^{18}$) \u2014 the maximum total weight of a good subset.\n\nThe second line denotes the set of items you have. It contains $8$ integers $cnt_1$, $cnt_2$, ..., $cnt_8$ ($0 \\le cnt_i \\le 10^{16}$), where $cnt_i$ is the number of items having weight $i$ in the set.\n\n\n-----Output-----\n\nPrint one integer \u2014 the maximum possible weight of a good subset of items.\n\n\n-----Examples-----\nInput\n10\n1 2 3 4 5 6 7 8\n\nOutput\n10\n\nInput\n0\n0 0 0 0 0 0 0 0\n\nOutput\n0\n\nInput\n3\n0 4 1 0 0 9 8 3\n\nOutput\n3\n\nTUTORIAL:\n1132E - Knapsack\n\nLet's consider the optimal answer. Suppose we take c\u1d62 items of weight i.\n\nLet L be the least common multiple of all weights (that is 840). Then we may represent c\u1d62 as c\u1d62 = \u230aL / i\u230b\u00b7p\u1d62 + q\u1d62, where 0 \u2264 q < \u230aL / i\u230b. Let\u2019s do the following trick: we will take q\u1d62 items of weight i, and all the remaining items of this weight can be merged into some items of weight L.\n\nThen we can write a brute force solution that picks less than \u230aL / i\u230b items of each weight, transforms the remaining ones into items of weight L as much as possible, and when we fix the whole subset, adds maximum possible number of items of weight L to the answer.\n\nThis works in something like \u220f\u208d\u1d62\u208c\u2081 \u209c\u2092 \u2088\u208e \u230aL / i\u230b = L\u2078 / 8! operations, which is too much.\n\nHow can we speed it up? Rewrite it using dynamic programming! When we have fixed the number of items we take from x first sets, the only two things that matter now are the current total weight of taken items and the number of items of weight L we can use; and it\u2019s obvious that the more items of weight L we can use, the better. So let\u2019s write the following dynamic programming solution: dp[x][y] \u2014 maximum number of items of weight L we can have, if we processed first x types of items, and current total weight is y. Note that the second dimension should have size 8L.\n\n\nInstructions:\n\n\nYou are a Python3 code generator.  Output **only** valid Python code. No explanations, no commentary, no filenames, no Markdown formatting. You will spit out a code block that can be pasted into any script. It must read the input, execute the logic and then print the output. Ensure that you invoke the main() or solve() function at the end if you're writing your code inside them.\nANSWER:\n",
  "codes": [
    "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    W = data[0]\n    cnt = data[1:]\n    \n    dp = [[0 for _ in range(8 * W)] for _ in range(len(cnt))]\n    \n    for i in range(len(cnt)):\n        for j in range(W):\n            if j >= cnt[i]:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - cnt[i]] + cnt[i])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    print(max(dp[-1]))\n\nif True:\n    main()",
    "def solve():\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    \n    def dp(x, y):\n        if x == 0:\n            return 0\n        \n        if dp[x-1][y] >= dp[x][y]:\n            return dp[x-1][y]\n        \n        res = 0\n        for i in range(1, 9):\n            if y >= i * cnts[i-1]:\n                res = max(res, dp[x-1][y-i*cnts[i-1]] + cnts[i-1])\n        \n        return res\n    \n    print(dp(len(cnts), W))\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    W = data[0]\n    cnts = data[1:]\n    \n    def dp(x, y):\n        if x == 0:\n            return 0\n        if dp[x-1][y] >= 0:\n            return dp[x-1][y]\n        \n        ans = dp(x-1, y)\n        for i in range(1, 9):\n            if y - i * cnts[i-1] >= 0:\n                ans = max(ans, dp(x-1, y - i * cnts[i-1]) + cnts[i-1])\n        dp[x][y] = ans\n        return ans\n    \n    print(dp(len(cnts), W))\n\nif True:\n    solve()",
    "import sys\n\ndef solve():\n    W = int(sys.stdin.readline())\n    cnt = list(map(int, sys.stdin.readline().split()))\n    \n    # Calculate the least common multiple of all weights\n    L = 1\n    for c in cnt:\n        L *= c\n    \n    # Initialize the DP table\n    dp = [[0] * (L // 8 + 1) for _ in range(9)]\n    \n    # Base case: dp[0][0] = 1\n    dp[0][0] = 1\n    \n    # Fill the DP table\n    for i in range(1, 9):\n        for j in range(L // 8 + 1):\n            if j >= cnt[i - 1]:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - cnt[i - 1]] + 1)\n    \n    # Print the result\n    print(max(dp[8]))\n\nif True:\n    solve()",
    "import sys\n\ndef solve(W, cnt):\n    MOD = 10**9 + 7\n    N = len(cnt)\n    L = 8 * max(cnt)\n    \n    dp = [[0 for _ in range(L+1)] for _ in range(N+1)]\n    \n    for i in range(1, N+1):\n        for j in range(1, L+1):\n            dp[i][j] = dp[i-1][j]\n            \n            if cnt[i-1] > 0:\n                dp[i][j] = max(dp[i][j], dp[i-1][j - cnt[i-1]] + cnt[i-1])\n                \n                if cnt[i-1] <= j // L:\n                    dp[i][j] = max(dp[i][j], dp[i-1][(j // L) * L] + (j % L))\n    \n    return dp[N][W]\n\nif True:\n    W = int(sys.stdin.readline().strip())\n    cnt = list(map(int, sys.stdin.readline().strip().split()))\n    print(solve(W, cnt))",
    "def solve(W, cnts):\n    L = 840\n    n = len(cnts)\n    \n    # dp[i][j] is the maximum number of items of weight L we can have,\n    # if we processed first i types of items, and current total weight is j.\n    dp = [[0 for _ in range(8 * L + 1)] for _ in range(n + 1)]\n    \n    # Base case: dp[0][0] = 0\n    for j in range(8 * L + 1):\n        dp[0][j] = 0\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        for j in range(8 * L + 1):\n            if j >= cnts[i - 1]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j])\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - cnts[i - 1]] + cnts[i - 1] // L)\n    \n    # The answer is dp[n][W]\n    return dp[n][W]\n\n# Read input\nW = int(input())\ncnts = list(map(int, input().split()))\n\n# Solve the problem\nprint(solve(W, cnts))",
    "def solve(W, cnts):\n    MOD = 10**9 + 7\n    L = 840\n    n = len(cnts)\n    \n    # Initialize DP table\n    dp = [[0 for _ in range(L+1)] for _ in range(n+1)]\n    \n    # Base case: no items, total weight is 0\n    dp[0][0] = 1\n    \n    # Fill DP table\n    for i in range(1, n+1):\n        for j in range(L+1):\n            if j >= cnts[i-1]:\n                dp[i][j] = (dp[i-1][j] + dp[i-1][j-cnts[i-1]]) % MOD\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    # Find the maximum weight of a good subset\n    max_weight = 0\n    for j in range(L+1):\n        max_weight = (max_weight + dp[n][j]) % MOD\n    \n    return max_weight\n\n# Read input\nW = int(input())\ncnts = list(map(int, input().split()))\n\n# Solve and print output\nprint(solve(W, cnts))",
    "def solve():\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    \n    # Calculate the greatest common divisor (GCD) of all weights\n    gcd = cnts[0]\n    for cnt in cnts[1:]:\n        gcd = math.gcd(gcd, cnt)\n    \n    # Calculate the least common multiple (LCM) of all weights\n    lcm = gcd * cnts[0]\n    for cnt in cnts[1:]:\n        lcm //= cnt\n    \n    # Initialize the DP table\n    dp = [[0] * (lcm + 1) for _ in range(len(cnts))]\n    \n    # Fill the DP table\n    for i in range(1, len(cnts)):\n        for j in range(lcm + 1):\n            dp[i][j] = dp[i - 1][j]\n            for k in range(min(j // cnts[i], cnts[i])):\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - k * cnts[i]] + k)\n    \n    # Print the result\n    print(max(dp[-1]))\n\nif True:\n    solve()",
    "import sys\n\ndef main():\n    W = int(sys.stdin.readline())\n    cnts = list(map(int, sys.stdin.readline().split()))\n    \n    def knapsack(W, cnts):\n        n = len(cnts)\n        dp = [[0 for _ in range(8 * W + 1)] for _ in range(n + 1)]\n        \n        for i in range(n + 1):\n            for j in range(8 * W + 1):\n                if i == 0 or j == 0:\n                    continue\n                dp[i][j] = max(dp[i][j], dp[i - 1][j])\n                if cnts[i - 1] <= j // 8:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][(j - cnts[i - 1]) % 8] + cnts[i - 1])\n        \n        return dp[n][8 * W]\n    \n    print(knapsack(W, cnts))\n\nif True:\n    main()",
    "def solve(W, cnt):\n    import math\n    MOD = 10**9 + 7\n    L = int(math.lcm(1, 2, 3, 4, 5, 6, 7, 8))\n    \n    dp = [[0] * (L + 1) for _ in range(len(cnt))]\n    \n    for i in range(len(cnt)):\n        dp[i][0] = 1\n    \n    for i in range(1, len(cnt)):\n        for j in range(L + 1):\n            dp[i][j] = dp[i-1][j]\n            if j >= cnt[i]:\n                dp[i][j] = (dp[i][j] + dp[i-1][j-cnt[i]]) % MOD\n    \n    ans = 0\n    for j in range(L + 1):\n        ans = (ans + dp[len(cnt)-1][j]) % MOD\n    \n    return ans\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve(W, cnt):\n    MOD = 10**9 + 7\n    N = len(cnt)\n    L = 8 * N\n    \n    # dp[i][j] - max number of items of weight L we can have, if processed first i types of items, and current total weight is j\n    dp = [[0 for _ in range(L + 1)] for _ in range(N + 1)]\n    \n    for i in range(1, N + 1):\n        for j in range(L + 1):\n            dp[i][j] = dp[i - 1][j]\n            \n            if j >= cnt[i - 1]:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - cnt[i - 1]]) % MOD\n    \n    return dp[N][L]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve(W, cnt):\n    MOD = 10**9 + 7\n    N = 8\n    L = 840\n    \n    # Initialize DP table\n    dp = [[0 for _ in range(L+1)] for _ in range(N+1)]\n    \n    # Base case: no items processed yet\n    for j in range(1, L+1):\n        dp[0][j] = 0\n    \n    # Fill DP table\n    for i in range(1, N+1):\n        for j in range(1, L+1):\n            if j >= cnt[i-1]:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-cnt[i-1]] + cnt[i-1])\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    # Calculate maximum weight of good subset\n    ans = 0\n    for i in range(N+1):\n        ans = max(ans, dp[i][W])\n    \n    return ans % MOD\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Solve the problem\nprint(solve(W, cnt))",
    "def solve():\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    \n    # Initialize DP table with zeros\n    dp = [[0] * (8 * W + 1) for _ in range(9)]\n    \n    # Base case: dp[0][0] = 1 (empty set)\n    dp[0][0] = 1\n    \n    # Fill DP table\n    for i in range(1, 9):\n        for j in range(W + 1):\n            for k in range(cnts[i - 1]):\n                if j >= i * k:\n                    dp[i][j] += dp[i - 1][j - i * k]\n                    \n    # Find the maximum value in the last row\n    max_value = max(dp[-1])\n    \n    return max_value\n\nif True:\n    solve()",
    "def solve():\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    \n    # Calculate the least common multiple of all weights\n    lcm = 1\n    for cnt in cnts:\n        lcm = lcm * cnt // gcd(lcm, cnt)\n    \n    # Initialize DP table\n    dp = [[0] * (lcm + 1) for _ in range(9)]\n    \n    # Fill DP table\n    for i in range(9):\n        for j in range(lcm + 1):\n            dp[i][j] = max(dp[i][j], dp[max(0, i - cnts[i])][j])\n            if i >= cnts[i]:\n                dp[i][j] = max(dp[i][j], dp[max(0, i - cnts[i])] + cnts[i])\n    \n    # Print the result\n    print(max(dp[8]))\n\nif True:\n    solve()",
    "def solve(W, cnt):\n    import math\n    MOD = 10**9 + 7\n    N = len(cnt)\n    \n    # Calculate the least common multiple of all weights\n    L = math.lcm(1, *cnt)\n    \n    # Initialize the DP table\n    dp = [[0] * (N * L + 1) for _ in range(N + 1)]\n    \n    # Base case: dp[0][0] = 1\n    dp[0][0] = 1\n    \n    # Fill the DP table\n    for i in range(1, N + 1):\n        for j in range(L * N + 1):\n            dp[i][j] = dp[i-1][j]\n            if j >= i * cnt[i-1]:\n                dp[i][j] = (dp[i][j] + dp[i-1][j-i*cnt[i-1]]) % MOD\n    \n    return dp[N][W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve(W, cnts):\n    MOD = 10**9 + 7\n    N = len(cnts)\n    L = 8 * max(cnts) // min(cnts)\n    \n    @cache\n    def dp(x, y):\n        if x == 0:\n            return 0\n        res = dp(x-1, y)\n        for i in range(1, L+1):\n            if y >= i:\n                res = max(res, dp(x-1, y-i) + cnts[i-1])\n        return res\n    \n    return dp(N, W)\n\n# Read input\nW = int(input())\ncnts = list(map(int, input().split()))\n\n# Solve and print the output\nprint(solve(W, cnts))",
    "def solve(W, cnt):\n    MOD = 10**9 + 7\n    N = 9\n    dp = [[0] * (N * W + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, N + 1):\n        for j in range(N * W + 1):\n            if j >= i * cnt[i - 1]:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - i * cnt[i - 1]]) % MOD\n    \n    return max(dp[N][i * W] for i in range(1, N + 1))\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve(W, cnt):\n    import math\n    L = math.lcm(8, 1)\n    \n    dp = [[0] * (L + 1) for _ in range(len(cnt))]\n    dp[0][0] = 1\n    \n    for i in range(len(cnt)):\n        for j in range(L + 1):\n            for k in range(min(j // cnt[i], L // cnt[i]) + 1):\n                dp[i + 1][j + k * cnt[i]] = max(dp[i + 1][j + k * cnt[i]], dp[i][j])\n    \n    return dp[len(cnt)][W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    W = data[0]\n    cnts = data[1:]\n    \n    def dp(x, y):\n        if x == 0:\n            return 0\n        if y >= W:\n            return W // cnts[x-1]\n        \n        if memo[x][y] != -1:\n            return memo[x][y]\n        \n        take = dp(x-1, y+cnts[x-1])\n        skip = dp(x-1, y)\n        \n        memo[x][y] = max(take, skip)\n        return memo[x][y]\n    \n    memo = [[-1]*((W//cnts[i]+1)*8) for i in range(9)]\n    print(dp(8, 0))\n\nif True:\n    solve()",
    "def solve(W, cnt):\n    L = 8 * 8 * 8 * 8 * 8 * 8 * 8 * 8\n    dp = [[0 for _ in range(L)] for _ in range(9)]\n    dp[0][0] = 1\n    \n    for i in range(1, 9):\n        for j in range(L):\n            dp[i][j] = dp[i-1][j]\n            if j >= i:\n                dp[i][j] += dp[i-1][(j-i)//i]\n    \n    ans = 0\n    for i in range(9):\n        for j in range(L):\n            if dp[i][j] <= W // i:\n                ans = max(ans, dp[i][j] * i)\n    \n    return ans\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve(W, cnt):\n    import math\n    MOD = 10**9 + 7\n    L = int(math.lcm(1, *cnt))\n    \n    @cache\n    def dp(x, y):\n        if x == 0:\n            return 0\n        if y >= L:\n            return min(y // L, x)\n        \n        res = dp(x - 1, y)\n        for i in range(1, 9):\n            if cnt[i - 1] > 0:\n                res = max(res, dp(x - 1, y + i) + cnt[i - 1])\n        \n        return res\n    \n    return dp(8, 0)\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Solve and print output\nprint(solve(W, cnt))",
    "def solve(W, cnt):\n    L = 840\n    dp = [[0 for _ in range(8 * L)] for _ in range(len(cnt) + 1)]\n    \n    for x in range(len(cnt) + 1):\n        for y in range(L):\n            for i in range(1, 9):\n                if y >= i * cnt[i - 1]:\n                    dp[x][y] = max(dp[x][y], dp[x - 1][y - i * cnt[i - 1]] + min(cnt[i - 1], (y // i) * cnt[i - 1]))\n    \n    return dp[-1][-1]\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Solve and print the result\nprint(solve(W, cnt))",
    "def solve(W, cnt):\n    L = 840\n    dp = [[0 for _ in range(8 * L)] for _ in range(len(cnt) + 1)]\n    \n    for x in range(1, len(cnt) + 1):\n        for y in range(L):\n            for z in range(min(x, cnt[x - 1]), 8 * L + 1):\n                dp[x][z] = max(dp[x][z], dp[x - 1][y])\n                if y + cnt[x - 1] <= L:\n                    dp[x][z] = max(dp[x][z], dp[x - 1][y + cnt[x - 1]] + min(x, cnt[x - 1]))\n    \n    return dp[len(cnt)][W]\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Print output\nprint(solve(W, cnt))",
    "def solve(W, cnt):\n    MOD = 10**9 + 7\n    N = len(cnt)\n    L = 8 * max(cnt)\n    \n    dp = [[0 for _ in range(L + 1)] for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(L + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= cnt[i - 1]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - cnt[i - 1]] + min(j // cnt[i - 1], 8))\n    \n    return dp[N][W]\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Solve and print output\nprint(solve(W, cnt))",
    "def solve():\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    \n    # Calculate the least common multiple of all weights\n    lcm = 1\n    for cnt in cnts:\n        lcm *= cnt\n    \n    # Initialize DP table\n    dp = [[0] * (lcm // 8) for _ in range(9)]\n    \n    # Base case: no items taken\n    dp[0][0] = 0\n    \n    # Fill DP table\n    for i in range(1, 9):\n        for j in range(lcm // 8):\n            dp[i][j] = max(dp[i][j], dp[i-1][j])\n            if cnts[i-1] > 0:\n                dp[i][j] = max(dp[i][j], dp[i-1][j + cnts[i-1]] + min(cnts[i-1], lcm // 8 - j))\n    \n    # The answer is the maximum value in the last row\n    return max(dp[-1])\n\nif True:\n    solve()",
    "def solve(W, cnts):\n    L = 8 * 8 * 8 * 8 * 8 * 8 * 8\n    dp = [[0 for _ in range(L + 1)] for _ in range(9)]\n    \n    for i in range(9):\n        for j in range(L + 1):\n            if j == 0 or i == 0:\n                continue\n            \n            if cnts[i - 1] >= j // L:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][(j - L) % L] + cnts[i - 1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    return dp[9][W]\n\n# Read input\nW = int(input())\ncnts = list(map(int, input().split()))\n\n# Print output\nprint(solve(W, cnts))",
    "def solve(W, cnt):\n    MOD = 10**9 + 7\n    N = len(cnt)\n    \n    # Calculate the greatest common divisor of all weights\n    GCD = cnt[0]\n    for i in range(1, N):\n        GCD = gcd(GCD, cnt[i])\n        \n    # Initialize the DP table\n    dp = [[0] * (N * GCD) for _ in range(N + 1)]\n    \n    # Base case: dp[0][0] = 1\n    dp[0][0] = 1\n    \n    # Fill the DP table\n    for i in range(1, N + 1):\n        for j in range(N * GCD):\n            dp[i][j] = dp[i - 1][j]\n            if j >= cnt[i - 1]:\n                dp[i][j] += dp[i - 1][(j - cnt[i - 1]) // GCD] * (GCD // cnt[i - 1])\n                dp[i][j] %= MOD\n    \n    # The answer is the maximum number of items of weight L we can have\n    return max(dp[N])\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Print the output\nprint(solve(W, cnt))",
    "def solve(W, cnt):\n    MOD = 10**9 + 7\n    L = 840\n    dp = [[0] * (L + 1) for _ in range(9)]\n    for i in range(1, 9):\n        for j in range(L + 1):\n            if j >= i:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - i] + cnt[i - 1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[8][W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "import sys\nfrom typing import List\n\ndef solve(W: int, cnts: List[int]) -> int:\n    L = 840\n    dp = [[0] * (L + 1) for _ in range(9)]\n    \n    for i in range(1, 9):\n        for j in range(L + 1):\n            if j >= cnts[i - 1]:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - cnts[i - 1]] + cnts[i - 1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    return dp[8][W]\n\nif True:\n    W = int(sys.stdin.readline().strip())\n    cnts = list(map(int, sys.stdin.readline().strip().split()))\n    print(solve(W, cnts))",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    W = data[0]\n    cnts = data[1:]\n    \n    # Calculate L\n    L = 1\n    for cnt in cnts:\n        L *= cnt\n    \n    # Initialize dp table\n    dp = [[0] * (8 * L + 1) for _ in range(9)]\n    \n    # Fill dp table\n    for x in range(1, 9):\n        for y in range(L + 1):\n            dp[x][y] = dp[x-1][y]\n            if y >= cnts[x-1]:\n                dp[x][y] = max(dp[x][y], dp[x-1][y-cnts[x-1]] + cnts[x-1])\n    \n    # Print the result\n    print(dp[8][W])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    W = int(data[0])\n    cnts = list(map(int, data[1:]))\n\n    # Calculate the least common multiple of all weights\n    lcm = 1\n    for cnt in cnts:\n        lcm = lcm * cnt // gcd(lcm, cnt)\n\n    # Initialize the DP table\n    dp = [[0] * (lcm + 1) for _ in range(9)]\n\n    # Fill the DP table\n    for i in range(9):\n        for j in range(lcm + 1):\n            if j >= cnts[i]:\n                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j - cnts[i]] + cnts[i])\n            else:\n                dp[i + 1][j] = dp[i][j]\n\n    # Print the result\n    print(max(dp[-1]))\n\nif True:\n    solve()",
    "def solve(W, cnt):\n    L = 840\n    dp = [[0] * (L + 1) for _ in range(9)]\n    \n    for i in range(1, 9):\n        for j in range(L + 1):\n            dp[i][j] = max(dp[i][j], dp[i - 1][j])\n            \n            if j >= i * cnt[i]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - i * cnt[i]] + cnt[i])\n    \n    return dp[8][W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve(W, cnts):\n    L = 840\n    n = len(cnts)\n    \n    # Initialize DP table with zeros\n    dp = [[0] * (W // L + 1) for _ in range(n + 1)]\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        for j in range(1, W // L + 1):\n            dp[i][j] = max(dp[i][j], dp[i - 1][j])\n            if cnts[i - 1] >= j * L:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - cnts[i - 1] // L] + cnts[i - 1] % L)\n    \n    return dp[n][W // L]\n\n# Read input\nW = int(input())\ncnts = list(map(int, input().split()))\n\n# Print output\nprint(solve(W, cnts))",
    "import sys\nfrom collections import defaultdict\n\ndef solve(W, cnts):\n    mod = 10**9 + 7\n    N = len(cnts)\n    \n    # Initialize DP table\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if cnts[i-1] == 0:\n                continue\n            dp[j][i] = max(dp[j][i], dp[j-1][i])\n            if cnts[i-1] >= j:\n                dp[j][i] = max(dp[j][i], dp[j-cnts[i-1]][i-1] + j)\n\n    return dp[N][N]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nW = int(data[0])\ncnts = [int(x) for x in data[1:]]\n\n# Solve problem\nprint(solve(W, cnts))",
    "def solve(W, cnt):\n    L = 840\n    dp = [[0 for _ in range(L + 1)] for _ in range(9)]\n    \n    for i in range(1, 9):\n        for j in range(L + 1):\n            if cnt[i - 1] == 0:\n                continue\n            \n            p = min(cnt[i - 1], j // L)\n            q = j % L\n            dp[i][j] = max(dp[i][j], dp[i - 1][j - p * L] + p)\n            if q > 0:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - q])\n    \n    return dp[8][W]",
    "def solve(W, cnts):\n    MOD = 10**9 + 7\n    N = len(cnts)\n    L = 8 * max(cnts)\n    \n    dp = [[0] * (L + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, N + 1):\n        for j in range(L + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= cnts[i - 1]:\n                dp[i][j] = (dp[i][j] + dp[i - 1][(j - cnts[i - 1]) // L]) % MOD\n    \n    return dp[N][L]\n\n# Read input\nW = int(input())\ncnts = list(map(int, input().split()))\n\n# Solve problem\nprint(solve(W, cnts))",
    "def solve(W, cnt):\n    L = 840\n    dp = [[0 for _ in range(L)] for _ in range(9)]\n    for i in range(1, 9):\n        for j in range(L):\n            if j >= i * cnt[i]:\n                dp[i][j] = max(dp[i][j], dp[i-1][j-i*cnt[i]] + cnt[i])\n            else:\n                dp[i][j] = dp[i-1][j]\n    return dp[8][W]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "import sys\nfrom typing import List\n\ndef solve(W: int, cnts: List[int]) -> int:\n    MOD = 10**9 + 7\n    N = len(cnts)\n    \n    # Calculate LCM of all weights\n    LCM = 1\n    for cnt in cnts:\n        LCM *= cnt\n        LCM //= gcd(LCM, cnt)\n    \n    # Initialize DP table\n    dp = [[0] * (N + 1) for _ in range(8 * LCM + 1)]\n    \n    # Base case: dp[0][0] = 1\n    dp[0][0] = 1\n    \n    # Fill DP table\n    for i in range(N):\n        for j in range(8 * LCM + 1):\n            for k in range(min(j // cnts[i], MOD)):\n                dp[j][k + 1] += dp[j - cnts[i]][k]\n                dp[j][k + 1] %= MOD\n    \n    # Result is the maximum value of dp[W][x] for all x\n    return max(dp[W])\n\n# Main function to handle input and call solve()\ndef main():\n    input_data = sys.stdin.read().split()\n    W = int(input_data[0])\n    cnts = list(map(int, input_data[1:]))\n    result = solve(W, cnts)\n    print(result)\n\nif True:\n    main()",
    "def solve(W, cnt):\n    MOD = 10**9 + 7\n    L = 840\n    n = len(cnt)\n    \n    # dp[i][j] - max number of items of weight L we can have, if processed first i types of items, and current total weight is j\n    dp = [[0] * (L // i + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(L // i + 1):\n            dp[i][j] = dp[i - 1][j]\n            \n            if j > 0:\n                dp[i][j] = max(dp[i][j], dp[i - 1][(j - 1) * (L // i) + 1] + cnt[i - 1])\n                \n    return (dp[n][W] + W) % MOD\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Print output\nprint(solve(W, cnt))",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    W = int(data[0])\n    cnt = list(map(int, data[1:]))\n    \n    def lcm(a, b):\n        return abs(a * b) // gcd(a, b)\n    \n    L = lcm(1, 2, 3, 4, 5, 6, 7, 8)\n    \n    dp = [[0 for _ in range(L + 1)] for _ in range(9)]\n    \n    for i in range(1, 9):\n        for j in range(L + 1):\n            if j >= cnt[i - 1]:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - cnt[i - 1]] + cnt[i - 1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    print(max(dp[8]))\n\nif True:\n    solve()",
    "def solve(W, cnt):\n    L = 840\n    dp = [[0] * (W // L + 1) for _ in range(9)]\n    for i in range(1, 9):\n        for j in range(W // L + 1):\n            dp[i][j] = max(dp[i][j], dp[i - 1][j])\n            if cnt[i - 1] > 0:\n                dp[i][j] = max(dp[i][j], dp[i - 1][(j - cnt[i - 1]) % (W // L)] + cnt[i - 1])\n    return dp[8][W // L]\n\nif True:\n    W = int(input())\n    cnt = list(map(int, input().split()))\n    print(solve(W, cnt))",
    "def solve(W, cnt):\n    MOD = 10**9 + 7\n    L = 840\n    n = len(cnt)\n    \n    dp = [[0 for _ in range(8 * L)] for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(L):\n            dp[i][j] = dp[i - 1][j]\n            \n            for k in range(1, cnt[i - 1] + 1):\n                if j + k * L <= L:\n                    dp[i][j + k * L] = max(dp[i][j + k * L], dp[i - 1][j] + k)\n    \n    return dp[n][W]\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Print output\nprint(solve(W, cnt))",
    "def solve():\n    W = int(input())\n    cnts = list(map(int, input().split()))\n    \n    def dp(x, y):\n        if x == 0:\n            return 0\n        if dp[x-1][y] >= y // 8:\n            return dp[x-1][y]\n        \n        res = dp[x-1][y % 8]\n        for i in range(1, 9):\n            if y // i >= 8:\n                res = max(res, dp[x-1][(y//i)%8] + min(y//i, 8))\n        \n        return res\n    \n    print(dp(len(cnts), W))\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    W = data[0]\n    cnt = data[1:]\n    n = len(cnt)\n    \n    # Calculate L\n    L = 1\n    for i in range(1, 9):\n        L *= i\n    \n    # Initialize DP table\n    dp = [[0] * (L + 1) for _ in range(n + 1)]\n    \n    # Fill DP table\n    for i in range(1, n + 1):\n        for j in range(L + 1):\n            if j >= cnt[i - 1]:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - cnt[i - 1]] + cnt[i - 1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    # Find the maximum weight of a good subset\n    max_weight = 0\n    for j in range(L + 1):\n        if dp[n][j] <= W:\n            max_weight = max(max_weight, j)\n    \n    print(max_weight)\n\nif True:\n    solve()",
    "def solve(W, cnts):\n    MOD = 10**9 + 7\n    N = len(cnts)\n    \n    # Calculate LCM of all weights\n    LCM = 1\n    for cnt in cnts:\n        LCM = (LCM * cnt) // gcd(LCM, cnt)\n    \n    # Initialize DP table\n    dp = [[0] * (N + 1) for _ in range(8 * LCM + 1)]\n    \n    # Base case: dp[0][0] = 1 (empty set)\n    dp[0][0] = 1\n    \n    # Fill DP table\n    for x in range(N + 1):\n        for y in range(8 * LCM + 1):\n            if y >= cnts[x - 1]:\n                dp[y][x] = (dp[y][x] + dp[y - cnts[x - 1]][x - 1]) % MOD\n    \n    # Find the maximum possible weight of a good subset\n    max_weight = 0\n    for y in range(8 * LCM + 1):\n        if y <= W:\n            max_weight = max(max_weight, dp[W - y][N])\n    \n    return max_weight\n\n# Read input\nW = int(input())\ncnts = list(map(int, input().split()))\n\n# Solve and print the result\nprint(solve(W, cnts))",
    "def solve(W, cnt):\n    L = 840\n    n = len(cnt)\n    \n    dp = [[0 for _ in range(L)] for _ in range(n+1)]\n    \n    for i in range(1, n+1):\n        for j in range(L):\n            if j >= cnt[i-1]:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-cnt[i-1]] + cnt[i-1])\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    return dp[n][W]\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Solve and print the result\nprint(solve(W, cnt))",
    "def solve(W, cnt):\n    MOD = 10**9 + 7\n    L = 840\n    dp = [[0] * (L + 1) for _ in range(9)]\n    \n    for i in range(1, 9):\n        for j in range(L + 1):\n            if j >= i:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j])\n                if j >= i * cnt[i]:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - i * cnt[i]] + min(j // i * cnt[i], cnt[i]))\n    \n    return dp[8][W]\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Solve and print the result\nprint(solve(W, cnt))",
    "def solve(W, cnt):\n    import math\n    L = int(math.lcm(1, *cnt))\n    \n    dp = [[0] * (W + 1) for _ in range(L + 1)]\n    dp[0][0] = 1\n    \n    for i in range(L + 1):\n        for j in range(W + 1):\n            if j >= i:\n                dp[i][j] = max(dp[i][j], dp[i - j][j] + 1)\n            else:\n                break\n                \n    return dp[L][W]\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Print output\nprint(solve(W, cnt))",
    "import sys\nfrom typing import *\ninput = sys.stdin.read\ndata = input().split()\ndef solve():\n    W = int(data[0])\n    cnts = list(map(int, data[1:]))\n    \n    def dp(x, y):\n        if x == 0:\n            return 0\n        if y == 0:\n            return 0\n        \n        if memo[x][y] != -1:\n            return memo[x][y]\n        \n        res = 0\n        for i in range(1, 9):\n            if y >= i * cnts[i-1]:\n                res = max(res, dp(x-1, y-i*cnts[i-1]) + cnts[i-1])\n        \n        memo[x][y] = res\n        return res\n    \n    memo = [[-1]*8*L for _ in range(9)]\n    print(dp(8, W))\nsolve()",
    "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    W = data[0]\n    cnts = data[1:]\n\n    def knapsack(L, cnts):\n        n = len(cnts)\n        dp = [[0] * (L + 1) for _ in range(n + 1)]\n        \n        for i in range(1, n + 1):\n            for j in range(1, L + 1):\n                if cnts[i - 1] <= j:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - cnts[i - 1]] + cnts[i - 1])\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[n][L]\n\n    ans = 0\n    for L in range(1, 8 * W + 1):\n        ans = max(ans, knapsack(L, cnts))\n    \n    print(ans)\n\nif True:\n    main()"
  ],
  "rewards": [
    0.0,
    0.0,
    0.0,
    0.06818181818181818,
    0.0,
    0.06818181818181818,
    0.0,
    0.0,
    0.0,
    0.0,
    0.06818181818181818,
    0.11363636363636363,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.06818181818181818,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.06818181818181818,
    0.4090909090909091,
    0.022727272727272728,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.06818181818181818,
    0.0,
    0.11363636363636363,
    0.0,
    0.0,
    0.0,
    0.0
  ],
  "train rewards": [
    0.0,
    0.0,
    0.0,
    0.022727272727272728,
    0.0,
    0.11363636363636363,
    0.0,
    0.0,
    0.0,
    0.0,
    0.11363636363636363,
    0.18181818181818182,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.11363636363636363,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.13636363636363635,
    0.4090909090909091,
    0.13636363636363635,
    0.0,
    0.0,
    0.0,
    0.06818181818181818,
    0.0,
    0.022727272727272728,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.09090909090909091,
    0.0,
    0.18181818181818182,
    0.0,
    0.022727272727272728,
    0.0,
    0.0
  ],
  "time": 390.8763086795807,
  "sample times": 50
}