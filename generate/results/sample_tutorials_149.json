{
  "prompt": "\nQUESTION:\nUnlucky year in Berland is such a year that its number n can be represented as n = x^{a} + y^{b}, where a and b are non-negative integer numbers. \n\nFor example, if x = 2 and y = 3 then the years 4 and 17 are unlucky (4 = 2^0 + 3^1, 17 = 2^3 + 3^2 = 2^4 + 3^0) and year 18 isn't unlucky as there is no such representation for it.\n\nSuch interval of years that there are no unlucky years in it is called The Golden Age.\n\nYou should write a program which will find maximum length of The Golden Age which starts no earlier than the year l and ends no later than the year r. If all years in the interval [l, r] are unlucky then the answer is 0.\n\n\n-----Input-----\n\nThe first line contains four integer numbers x, y, l and r (2 \u2264 x, y \u2264 10^18, 1 \u2264 l \u2264 r \u2264 10^18).\n\n\n-----Output-----\n\nPrint the maximum length of The Golden Age within the interval [l, r].\n\nIf all years in the interval [l, r] are unlucky then print 0.\n\n\n-----Examples-----\nInput\n2 3 1 10\n\nOutput\n1\n\nInput\n3 5 10 22\n\nOutput\n8\n\nInput\n2 3 3 5\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example the unlucky years are 2, 3, 4, 5, 7, 9 and 10. So maximum length of The Golden Age is achived in the intervals [1, 1], [6, 6] and [8, 8].\n\nIn the second example the longest Golden Age is the interval [15, 22].\n\nTUTORIAL:\nNotice that x\u1d43 for x \u2265 2 has no more than 60 powers which give numbers no greater than 10\u00b9\u2078.\n\nSo let's store all possible sums of all powers of x and y. Now the answer to the query can be obtained in linear time by checking difference between neighbouring unlucky years in sorted order.\n\nDon't forget that you should handle multiplying of such big numbers very carefully. For example, instead of writing\n\nwhile (num <= 1e18)\n    num = num * x\n\nor\n\nwhile (num * x <= 1e18)\n    num = num * x\n\nyou should write\n\nwhile (num <= 1e18 / x)\n    num = num * x\n\nto avoid getting overflow errors of 64-bit type.\n\nInteger division will work fine in that case because num \u00b7 x will never exceed 10\u00b9\u2078 if num doesn\u2019t exceed \u230a10\u00b9\u2078 / x\u230b.\n\nOverall complexity: O(n \u00b7 log n).\n\n\nInstructions:\n\n\nYou are a Python3 code generator.  Output **only** valid Python code. No explanations, no commentary, no filenames, no Markdown formatting. You will spit out a code block that can be pasted into any script. It must read the input, execute the logic and then print the output. Ensure that you invoke the main() or solve() function at the end if you're writing your code inside them.\nANSWER:\n",
  "codes": [
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    x, y, l, r = data\n    max_length = 0\n    \n    # Store all possible sums of all powers of x and y\n    power_sums = []\n    for i in range(61):\n        for j in range(61):\n            power_sums.append(x**i + y**j)\n    \n    # Sort the power sums\n    power_sums.sort()\n    \n    # Find the maximum length of The Golden Age\n    for i in range(len(power_sums)):\n        while i+1 < len(power_sums) and power_sums[i+1] - power_sums[i] <= r-l:\n            i += 1\n        max_length = max(max_length, i-l+1)\n    \n    print(max_length)\n\nif True:\n    solve()",
    "def solve():\n    x, y, l, r = map(int, input().split())\n    \n    # Store all possible sums of all powers of x and y\n    power_sums = set()\n    current_sum = 0\n    \n    while True:\n        current_sum += x ** len(power_sums)\n        power_sums.add(current_sum)\n        \n        if current_sum > r:\n            break\n        \n        if current_sum >= l:\n            power_sums.add(current_sum)\n            \n        current_sum -= y ** len(power_sums)\n        power_sums.add(current_sum)\n        \n        if current_sum > r:\n            break\n        \n        if current_sum >= l:\n            power_sums.add(current_sum)\n    \n    # Find the maximum length of The Golden Age\n    max_length = 0\n    for i in range(len(power_sums)):\n        if power_sums[i] < l:\n            continue\n        \n        j = i + 1\n        while j < len(power_sums):\n            if power_sums[j] > r:\n                break\n            \n            if power_sums[j] - power_sums[i] >= l and power_sums[j] - power_sums[i] <= r:\n                max_length = max(max_length, j - i)\n                \n            j += 1\n    \n    print(max_length)\n\nif True:\n    solve()",
    "def solve():\n    x, y, l, r = map(int, input().split())\n    \n    # Generate all possible sums of x^a and y^b for a, b >= 0\n    sums = set()\n    for i in range(61):\n        for j in range(61):\n            sums.add(x**i + y**j)\n    \n    # Sort the sums\n    sums = sorted(sums)\n    \n    # Find the maximum length of The Golden Age\n    max_length = 0\n    for i in range(len(sums)):\n        while i < len(sums) - 1 and sums[i+1] - sums[i] > r - l + 1:\n            i += 1\n        max_length = max(max_length, i - l + 1)\n    \n    print(max_length)\n\nif True:\n    solve()",
    "def main():\n    x, y, l, r = map(int, input().split())\n    \n    # Store all possible sums of all powers of x and y\n    power_sums = set()\n    for i in range(60):\n        for j in range(60):\n            power_sums.add(x**i + y**j)\n    \n    # Sort the list of power sums\n    power_sums = sorted(power_sums)\n    \n    # Initialize variables to keep track of the longest golden age\n    max_length = 0\n    current_length = 1\n    \n    # Iterate through the sorted list of power sums\n    for i in range(1, len(power_sums)):\n        if power_sums[i] - power_sums[i-1] > r - l:\n            break\n        \n        if power_sums[i] - power_sums[i-1] >= l:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n    \n    # Check if all years in the interval [l, r] are unlucky\n    if max_length == 0:\n        print(0)\n    else:\n        print(max_length)\n\nif True:\n    main()",
    "def solve(x, y, l, r):\n    # Store all possible sums of all powers of x and y\n    sums_x = set()\n    sums_y = set()\n    for i in range(60):\n        sums_x.add(x**i)\n    for j in range(60):\n        sums_y.add(y**j)\n    \n    # Sort the sums of x and y\n    sums_x = sorted(sums_x)\n    sums_y = sorted(sums_y)\n    \n    # Initialize variables\n    max_length = 0\n    current_sum = 0\n    \n    # Iterate over the sums of x and y\n    for i in range(len(sums_x)):\n        for j in range(len(sums_y)):\n            current_sum = sums_x[i] + sums_y[j]\n            \n            # Check if the current sum is within the given range\n            if l <= current_sum <= r:\n                max_length = max(max_length, i + j + 1)\n                \n            # If the current sum exceeds the upper bound, break the loop\n            if current_sum > r:\n                break\n                \n    return max_length\n\n# Read input\nx, y, l, r = map(int, input().split())\n\n# Print the result\nprint(solve(x, y, l, r))",
    "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    x, y, l, r = data\n    \n    def generate_powers(x, y):\n        powers = []\n        for i in range(60):\n            power = x ** i\n            for j in range(i + 1):\n                sum_of_powers = power + y ** j\n                powers.append(sum_of_powers)\n        return powers\n    \n    def find_unlucky_years(powers, l, r):\n        lucky_years = []\n        for power in powers:\n            while power <= r:\n                lucky_years.append(power)\n                power *= x\n        lucky_years.sort()\n        return lucky_years\n    \n    def find_golden_age(lucky_years, l, r):\n        left, right = 0, len(lucky_years) - 1\n        max_length = 0\n        while left <= right:\n            mid = (left + right) // 2\n            if lucky_years[mid] >= l and lucky_years[mid] <= r:\n                left = mid + 1\n                max_length = max(max_length, mid - left + 1)\n            else:\n                right = mid - 1\n        return max_length\n    \n    powers = generate_powers(x, y)\n    lucky_years = find_unlucky_years(powers, l, r)\n    result = find_golden_age(lucky_years, l, r)\n    print(result)\n\nif True:\n    main()",
    "import sys\nfrom typing import *\ninput = sys.stdin.read\nread = lambda: int(input())\nreadline = lambda: input().strip()\n\ndef solve():\n    x, y, l, r = map(int, readline().split())\n    \n    def get_sum_of_powers(x, y, power):\n        return sum([x**i + y**j for i in range(power+1) for j in range(power+1)])\n    \n    # Store all possible sums of powers of x and y\n    sums = set()\n    for i in range(61):  # Maximum number of powers of x\n        for j in range(61):  # Maximum number of powers of y\n            sums.add(get_sum_of_powers(x, y, i+j))\n    \n    # Sort the sums\n    sums = sorted(sums)\n    \n    max_length = 0\n    for i in range(len(sums)):\n        if sums[i] > r:\n            break\n        if sums[i] >= l:\n            max_length = max(max_length, i+1)\n    \n    print(max_length)\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    x, y, l, r = data\n    \n    # Generate all possible sums of x^a and y^b\n    sums = set()\n    for i in range(61):\n        for j in range(61):\n            sum = x**i + y**j\n            sums.add(sum)\n    \n    # Sort the sums\n    sums = sorted(sums)\n    \n    # Find the maximum length of The Golden Age\n    max_length = 0\n    for i in range(len(sums) - 1):\n        if sums[i+1] > r:\n            break\n        if sums[i] >= l:\n            max_length = max(max_length, sums[i+1] - sums[i])\n    \n    print(max_length)\n\nif True:\n    solve()",
    "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    x, y, l, r = data\n    result = solve(x, y, l, r)\n    print(result)\n\ndef solve(x, y, l, r):\n    powers_x = set()\n    powers_y = set()\n    \n    # Store all possible sums of all powers of x and y\n    power_x = 1\n    while power_x <= 60 * max(x, y):\n        powers_x.add(power_x)\n        power_x *= x\n    \n    power_y = 1\n    while power_y <= 60 * max(x, y):\n        powers_y.add(power_y)\n        power_y *= y\n    \n    # Sort the sets\n    powers_x = sorted(powers_x)\n    powers_y = sorted(powers_y)\n    \n    # Find the longest subarray with no elements from powers_x or powers_y\n    max_length = 0\n    current_length = 0\n    i = j = 0\n    \n    while i < len(powers_x) and j < len(powers_y):\n        if powers_x[i] > powers_y[j]:\n            current_length += 1\n            j += 1\n        else:\n            current_length += 1\n            i += 1\n        \n        if current_length > max_length:\n            max_length = current_length\n    \n    return max_length\n\nif True:\n    main()",
    "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    x, y, l, r = data\n    max_length = solve(x, y, l, r)\n    print(max_length)\n\ndef solve(x, y, l, r):\n    power_x = []\n    power_y = []\n    for i in range(61):\n        power_x.append(x ** i)\n        power_y.append(y ** i)\n    \n    power_x.sort()\n    power_y.sort()\n    \n    unlucky_years = []\n    current_sum = 0\n    \n    for i in range(len(power_x)):\n        while current_sum < power_x[i]:\n            current_sum += power_y[-1]\n            unlucky_years.append(current_sum)\n        \n        if current_sum == power_x[i]:\n            current_sum -= power_y[-1]\n            unlucky_years.append(current_sum)\n    \n    unlucky_years.sort()\n    \n    max_length = 0\n    for i in range(len(unluckily_years) - 1):\n        if unlucky_years[i + 1] - unlucky_years[i] > max_length:\n            max_length = unlucky_years[i + 1] - unlucky_years[i]\n    \n    return max_length\n\nif True:\n    main()",
    "import sys\nfrom typing import *\nfrom collections import *\n\ndef main():\n    x, y, l, r = map(int, sys.stdin.read().split())\n    if not x % y:\n        return 0\n    dp = [[0] * (r - l + 1) for _ in range(2)]\n    for i in range(x):\n        for j in range(y):\n            for k in range(l, r + 1):\n                dp[i & 1][k - l] += (i == x - 1) + (j == y - 1)\n    ans = 0\n    for i in range(1, 2):\n        for j in range(r - l + 1):\n            if dp[i][j]:\n                ans = max(ans, j)\n    print(ans)\n\nif True:\n    main()",
    "def solve():\n    x, y, l, r = map(int, input().split())\n    \n    # Generate all possible sums of x^a + y^b\n    sums = set()\n    for i in range(61):\n        for j in range(61):\n            sums.add(x**i + y**j)\n    \n    # Sort the sums\n    sums = sorted(sums)\n    \n    # Find the longest golden age\n    max_length = 0\n    for i in range(len(sums)):\n        while i+1 < len(sums) and sums[i+1] - sums[i] > 10**18 // x:\n            i += 1\n        if i+1 < len(sums):\n            max_length = max(max_length, i+1 - l + 1)\n    \n    print(max_length)\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    x, y, l, r = data\n    # Store all possible sums of all powers of x and y\n    powers_of_x = set()\n    powers_of_y = set()\n    for i in range(61):\n        powers_of_x.add(x**i)\n        powers_of_y.add(y**i)\n    \n    # Sort the sets\n    powers_of_x = sorted(powers_of_x)\n    powers_of_y = sorted(powers_of_y)\n    \n    # Find the maximum length of The Golden Age\n    max_length = 0\n    for i in range(len(powers_of_x)):\n        for j in range(len(powers_of_y)):\n            if powers_of_x[i] > r or powers_of_y[j] > r:\n                break\n            if powers_of_x[i] + powers_of_y[j] >= l:\n                max_length = max(max_length, i + j + 1)\n    \n    # Print the result\n    print(max_length)\n\nif True:\n    solve()",
    "import sys\nfrom typing import *\ninput = sys.stdin.read\ndata = input().split()\nx, y, l, r = map(int, data)\n\ndef is_unlucky(n):\n    return n == x**0 + y**1 or n == x**1 + y**0 or n == x**2 + y**2 or n == x**3 + y**3 or n == x**4 + y**4 or n == x**5 + y**5 or n == x**6 + y**6\n\ndef get_golden_age_length(l, r):\n    if not is_unlucky(l):\n        return 0\n    if not is_unlucky(r):\n        return 0\n    \n    unlucky_years = set()\n    while l <= r:\n        if is_unlucky(l):\n            unlucky_years.add(l)\n        l += 1\n    \n    max_length = 0\n    current_length = 0\n    for i in range(len(unlucky_years)):\n        current_length += 1\n        if i < len(unlucky_years) - 1 and unlucky_years[i+1] - unlucky_years[i] > 1:\n            max_length = max(max_length, current_length)\n            current_length = 0\n    \n    return max(max_length, current_length)\n\nprint(get_golden_age_length(l, r))",
    "def solve():\n    x, y, l, r = map(int, input().split())\n    \n    # Generate all possible sums of powers of x and y\n    powers_x = set()\n    powers_y = set()\n    current_sum = 0\n    \n    while True:\n        current_sum += x ** len(powers_x)\n        if current_sum > r:\n            break\n        powers_x.add(current_sum)\n        \n        current_sum += y ** len(powers_y)\n        if current_sum > r:\n            break\n        powers_y.add(current_sum)\n    \n    # Sort the list of unlucky years\n    unlucky_years = sorted(list(powers_x.union(powers_y)))\n    \n    max_length = 0\n    start_index = 0\n    \n    for i in range(1, len(unluckily_years)):\n        if unlucky_years[i] - unlucky_years[start_index] > 1:\n            max_length = max(max_length, i - start_index)\n            start_index = i\n    \n    if start_index == len(unluckily_years):\n        max_length = 0\n    \n    print(max_length)\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    x, y, l, r = data\n    \n    # Store all possible sums of all powers of x and y\n    powers_x = set()\n    powers_y = set()\n    current_sum = 0\n    for i in range(61):\n        current_sum += x**i\n        powers_x.add(current_sum)\n        \n        current_sum -= x**i\n        current_sum += y**i\n        powers_y.add(current_sum)\n    \n    # Sort the sets of powers\n    powers_x = sorted(powers_x)\n    powers_y = sorted(powers_y)\n    \n    # Find the longest subarray with no elements from either set\n    max_length = 0\n    for i in range(len(powers_x)):\n        for j in range(len(powers_y)):\n            if powers_x[i] > powers_y[j]:\n                break\n            if powers_x[i] == powers_y[j]:\n                continue\n            left = i\n            right = j\n            while left < len(powers_x) and powers_x[left] <= powers_y[right]:\n                left += 1\n            while right < len(powers_y) and powers_y[right] <= powers_x[left]:\n                right += 1\n            max_length = max(max_length, right - left)\n    \n    # Print the result\n    print(max_length)\n\nif True:\n    solve()",
    "def solve():\n    x, y, l, r = map(int, input().split())\n    dp = [[0] * (r + 1) for _ in range(r + 1)]\n    for i in range(1, r + 1):\n        for j in range(1, r + 1):\n            if i == 1 and j == 1:\n                dp[i][j] = 1\n            elif i == 1:\n                dp[i][j] = dp[i][j - 1]\n            elif j == 1:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n    res = 0\n    for i in range(l, r + 1):\n        if dp[i][i] == 0:\n            break\n        res += 1\n    print(res)\n\nif True:\n    solve()",
    "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    x, y, l, r = data\n    max_length = solve(x, y, l, r)\n    print(max_length)\n\ndef solve(x, y, l, r):\n    # Store all possible sums of all powers of x and y\n    power_sums = set()\n    for i in range(61):\n        power_sum_x = sum([x**i for _ in range(i+1)])\n        power_sum_y = sum([y**j for _ in range(j+1)])\n        power_sums.add(power_sum_x + power_sum_y)\n    \n    # Sort the power sums\n    power_sums = sorted(list(power_sums))\n    \n    # Binary search to find the maximum length of The Golden Age\n    left, right = l, r\n    while left < right:\n        mid = (left + right + 1) // 2\n        if check_golden_age(mid, power_sums, x, y):\n            left = mid\n        else:\n            right = mid - 1\n    \n    return left - l + 1\n\ndef check_golden_age(year, power_sums, x, y):\n    # Check if the year is not unlucky\n    for i in range(61):\n        power_sum_x = sum([x**i for _ in range(i+1)])\n        power_sum_y = sum([y**j for _ in range(j+1)])\n        if power_sum_x + power_sum_y == year:\n            return False\n    return True\n\nif True:\n    main()",
    "def solve(x, y, l, r):\n    def generate_sums(limit):\n        sums = set()\n        current_sum = 0\n        power = 0\n        while True:\n            current_sum += x ** power\n            if current_sum > limit:\n                break\n            sums.add(current_sum)\n            power += 1\n        return sums\n    \n    sums_x = generate_sums(10**18)\n    sums_y = generate_sums(10**18)\n    \n    unlucky_years = []\n    for i in range(l, r + 1):\n        if i in sums_x:\n            unlucky_years.append(i)\n        elif i in sums_y:\n            unlucky_years.append(i)\n    \n    if len(unlucky_years) == 0:\n        print(0)\n        return\n    \n    unlucky_years.sort()\n    max_length = 1\n    current_length = 1\n    \n    for i in range(1, len(unlucky_years)):\n        if unlucky_years[i] - unlucky_years[i-1] == 1:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n    \n    max_length = max(max_length, current_length)\n    print(max_length)\n\n# Read input from stdin\nx, y, l, r = map(int, input().split())\n\n# Call the solve function with the input values\nsolve(x, y, l, r)",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    x, y, l, r = data\n    \n    def power(x, y):\n        if y == 0:\n            return 1\n        elif y % 2 == 0:\n            return power(x, y // 2) ** 2\n        else:\n            return x * power(x, y - 1)\n    \n    def get_unlucky_years():\n        unlucky_years = set()\n        for i in range(1, x ** 60 + 1):\n            for j in range(1, y ** 60 + 1):\n                unlucky_years.add(i + j)\n        return unlucky_years\n    \n    unlucky_years = get_unlucky_years()\n    \n    max_length = 0\n    current_length = 0\n    \n    for i in range(l, r + 1):\n        if i not in unlucky_years:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 0\n    \n    print(max_length)\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    x, y, l, r = data\n    \n    # Generate all possible sums of powers of x and y\n    powers_x = []\n    powers_y = []\n    \n    def generate_powers(x, y):\n        power = 1\n        while power <= 60 * max(x, y):\n            powers_x.append(power)\n            powers_y.append(power)\n            power *= y\n    \n    generate_powers(x, y)\n    \n    # Sort all generated sums\n    powers_x.sort()\n    powers_y.sort()\n    \n    # Find the longest sequence of consecutive numbers that are not in powers_x or powers_y\n    current_length = 0\n    max_length = 0\n    \n    for i in range(len(powers_x)):\n        for j in range(i, len(powers_y)):\n            start = powers_x[i]\n            end = powers_y[j]\n            \n            while start <= end:\n                if start >= l and start <= r:\n                    current_length += 1\n                else:\n                    break\n                \n                start += powers_y[j]\n                \n            if current_length > max_length:\n                max_length = current_length\n            \n            current_length = 0\n    \n    if max_length == 0:\n        print(0)\n    else:\n        print(max_length)\n\nif True:\n    solve()",
    "def solve():\n    x, y, l, r = map(int, input().split())\n    \n    # Generate all possible sums of powers of x and y\n    sums_x = []\n    sums_y = []\n    for i in range(61):\n        sum_x = x**i\n        sums_x.append(sum_x)\n        sum_y = y**i\n        sums_y.append(sum_y)\n    \n    # Sort the sums of powers of x and y\n    sums_x.sort()\n    sums_y.sort()\n    \n    # Initialize variables to keep track of the maximum length of The Golden Age\n    max_length = 0\n    \n    # Iterate through all possible starting points in the interval [l, r]\n    for start in range(l, r+1):\n        # Check if the current year is unlucky\n        if start not in sums_x and start not in sums_y:\n            continue\n        \n        # Find the ending point of The Golden Age\n        end = start\n        while end <= r and (end not in sums_x or end not in sums_y):\n            end += 1\n        \n        # Update the maximum length of The Golden Age\n        max_length = max(max_length, end - start)\n    \n    # Print the result\n    print(max_length)\n\nif True:\n    solve()",
    "def solve(x, y, l, r):\n    from math import pow, floor\n    from collections import defaultdict\n    \n    # Store all possible sums of all powers of x and y\n    power_sums = defaultdict(int)\n    \n    def compute_power_sum(x, y, n):\n        if n == 0:\n            return 0\n        elif n == 1:\n            return x\n        else:\n            half_n = floor(n / 2)\n            return power_sums[x ** half_n] + power_sums[y ** half_n]\n    \n    for i in range(1, int(pow(r, 1/x)) + 1):\n        power_sums[i ** x] += i ** x\n    \n    for i in range(1, int(pow(r, 1/y)) + 1):\n        power_sums[i ** y] += i ** y\n    \n    # Sort the list of power sums\n    power_sums_sorted = sorted(power_sums.values())\n    \n    # Initialize variables\n    max_length = 0\n    current_length = 0\n    start_index = 0\n    \n    for i in range(len(power_sums_sorted)):\n        if power_sums_sorted[i] > r:\n            break\n        current_length += 1\n        while start_index < len(power_sums_sorted) and power_sums_sorted[start_index] <= power_sums_sorted[i]:\n            start_index += 1\n        max_length = max(max_length, current_length)\n        current_length = 0\n    \n    return max_length\n\n# Read input\nx, y, l, r = map(int, input().split())\n\n# Solve the problem\nresult = solve(x, y, l, r)\n\n# Print the result\nprint(result)",
    "def main():\n    x, y, l, r = map(int, input().split())\n    \n    def power_sum(x, y):\n        sums = []\n        for i in range(61):\n            current_sum = 0\n            for j in range(i+1):\n                current_sum += pow(x, j)\n            sums.append(current_sum)\n        \n        return sums\n    \n    sums_x = power_sum(x, y)\n    sums_y = power_sum(y, x)\n    \n    def binary_search(sums, left, right):\n        while left < right:\n            mid = (left + right) // 2\n            if sums[mid] >= l and sums[mid+1] < l:\n                return mid\n            elif sums[mid] >= l:\n                right = mid\n            else:\n                left = mid + 1\n        \n        return -1\n    \n    max_length = 0\n    for i in range(len(sums_x)):\n        index = binary_search(sums_y, i, len(sums_y)-1)\n        if index != -1:\n            max_length = max(max_length, index-i-1)\n    \n    print(max_length)\n\nif True:\n    main()",
    "import sys\nfrom typing import *\nfrom collections import *\n\ndef solve():\n    x, y, l, r = map(int, sys.stdin.readline().split())\n    \n    # Generate all possible sums of powers of x and y\n    powers_x = [x**i for i in range(61)]\n    powers_y = [y**j for j in range(61)]\n    \n    # Store these sums in a set for efficient lookup\n    sums = set()\n    for p in powers_x:\n        for q in powers_y:\n            sums.add(p + q)\n    \n    # Sort the sums for binary search\n    sums.sort()\n    \n    # Perform binary search to find the longest golden age\n    left, right = 0, r - l + 1\n    while left < right:\n        mid = (left + right + 1) // 2\n        found = False\n        current_sum = l\n        for i in range(mid):\n            if current_sum + sums[i] > r:\n                break\n            current_sum += sums[i]\n            found = True\n        if found:\n            left = mid\n        else:\n            right = mid - 1\n    \n    # Print the result\n    print(left)\n\nif True:\n    solve()",
    "def solve(x, y, l, r):\n    # Store all possible sums of all powers of x and y\n    sums = set()\n    for i in range(61):\n        for j in range(61):\n            sums.add(x**i + y**j)\n\n    # Sort the sums in ascending order\n    sums = sorted(sums)\n\n    # Initialize variables to keep track of the current sum and the length of the golden age\n    cur_sum = 0\n    max_len = 0\n\n    # Iterate through the sorted sums\n    for i in range(len(sums)):\n        # Update the current sum\n        cur_sum += sums[i]\n\n        # Check if the current sum is within the given range\n        if l <= cur_sum <= r:\n            # Calculate the length of the current golden age\n            len_golden_age = i + 1\n            # Update the maximum length of the golden age\n            max_len = max(max_len, len_golden_age)\n\n    # Return the maximum length of the golden age\n    return max_len\n\n# Read input from stdin\nx, y, l, r = map(int, input().split())\n\n# Print the result\nprint(solve(x, y, l, r))",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    x, y, l, r = map(int, data)\n\n    # Store all possible sums of all powers of x and y\n    sums_x = set()\n    sums_y = set()\n    current_sum = 0\n    for i in range(61):\n        current_sum += x ** i\n        sums_x.add(current_sum)\n        current_sum -= x ** i\n\n    current_sum = 0\n    for i in range(61):\n        current_sum += y ** i\n        sums_y.add(current_sum)\n        current_sum -= y ** i\n\n    # Sort the sums\n    sums_x = sorted(sums_x)\n    sums_y = sorted(sums_y)\n\n    # Find the maximum length of The Golden Age\n    max_length = 0\n    for i in range(len(sums_x)):\n        for j in range(len(sums_y)):\n            if sums_x[i] < l or sums_y[j] > r:\n                break\n            if sums_x[i] == l and sums_y[j] == r:\n                return max_length\n            if sums_x[i] == l:\n                max_length = max(max_length, j)\n            if sums_y[j] == r:\n                max_length = max(max_length, i)\n            if sums_x[i] < l and sums_y[j] < r:\n                break\n\n    return 0\n\nif True:\n    solve()",
    "import sys\nfrom typing import *\ninput = sys.stdin.read\ndata = input().split()\nx, y, l, r = map(int, data)\n\ndef generate_sums(x, y):\n    sums = []\n    for i in range(61):\n        for j in range(61):\n            power_x = x ** i\n            power_y = y ** j\n            total = power_x + power_y\n            sums.append(total)\n    return sorted(sums)\n\ndef check_unlucky(years, l, r):\n    for i in range(len(years)):\n        if years[i] >= l and years[i] <= r:\n            return True\n    return False\n\ndef solve():\n    sums = generate_sums(x, y)\n    max_length = 0\n    current_sum = 0\n    start_index = 0\n    \n    for i in range(len(sums)):\n        current_sum += sums[i]\n        \n        while current_sum > r:\n            current_sum -= sums[start_index]\n            start_index += 1\n        \n        if not check_unlucky(sums[start_index:i+1], l, r):\n            max_length = max(max_length, i - start_index + 1)\n    \n    return max_length\n\nif True:\n    result = solve()\n    print(result)",
    "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    x, y, l, r = data\n    ans = solve(x, y, l, r)\n    print(ans)\n\ndef solve(x, y, l, r):\n    max_len = 0\n    for i in range(l, r+1):\n        if is_unlucky(i, x, y):\n            continue\n        for j in range(i+1, r+1):\n            if is_unlucky(j, x, y):\n                break\n            if is_unlucky(i+j, x, y):\n                continue\n            max_len = max(max_len, j-i)\n    return max_len\n\ndef is_unlucky(num, x, y):\n    while num > 0:\n        if num % x == 0:\n            return True\n        if num % y == 0:\n            return True\n        num //= x\n        num //= y\n    return False\n\nif True:\n    main()",
    "import sys\nfrom math import log\n\ndef solve():\n    x, y, l, r = map(int, sys.stdin.readline().split())\n    \n    # Store all possible sums of all powers of x and y\n    sums_x = []\n    sums_y = []\n    for i in range(61):\n        sum_x = x**i\n        sum_y = y**i\n        sums_x.append(sum_x)\n        sums_y.append(sum_y)\n\n    # Sort the sums of x and y\n    sums_x.sort()\n    sums_y.sort()\n\n    # Find the maximum length of The Golden Age\n    max_length = 0\n    for i in range(len(sums_x)):\n        for j in range(i+1, len(sums_y)):\n            if sums_x[i] + sums_y[j] >= l and sums_x[i] + sums_y[j] <= r:\n                max_length = max(max_length, j - i)\n\n    print(max_length)\n\nif True:\n    solve()",
    "def main():\n    x, y, l, r = map(int, input().split())\n    dp = [[0 for _ in range(r+1)] for _ in range(x+1)]\n    for i in range(1, x+1):\n        for j in range(1, y+1):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\n            dp[i][j] += i**j\n    ans = 0\n    for i in range(l, r+1):\n        if dp[x][y] >= i**x + i**y:\n            ans = max(ans, i-x)\n    print(ans)\n\nif True:\n    main()",
    "def solve(x, y, l, r):\n    # Generate all possible sums of powers of x and y\n    powers_x = set()\n    powers_y = set()\n    \n    current_power_x = 1\n    while current_power_x <= 1e18 // x:\n        powers_x.add(current_power_x)\n        current_power_x *= x\n    \n    current_power_y = 1\n    while current_power_y <= 1e18 // y:\n        powers_y.add(current_power_y)\n        current_power_y *= y\n    \n    # Sort the sets of powers\n    powers_x = sorted(powers_x)\n    powers_y = sorted(powers_y)\n    \n    # Initialize variables\n    max_length = 0\n    start = 0\n    \n    # Iterate through the sorted sets of powers\n    for i in range(len(powers_x)):\n        for j in range(len(powers_y)):\n            sum_xy = powers_x[i] + powers_y[j]\n            \n            # Check if the sum is within the given range\n            if sum_xy >= l and sum_xy <= r:\n                # Update the maximum length of the Golden Age\n                max_length = max(max_length, i + j)\n                \n                # Move the start pointer to the next possible unlucky year\n                while start < len(powers_x) and powers_x[start] + powers_y[j] > r:\n                    start += 1\n    \n    # Print the result\n    print(max_length)\n\n# Main function\nif True:\n    x, y, l, r = map(int, input().split())\n    solve(x, y, l, r)",
    "def solve():\n    x, y, l, r = map(int, input().split())\n    \n    # Store all possible sums of all powers of x and y\n    power_sums = []\n    current_sum = 0\n    \n    while True:\n        current_sum += x ** len(power_sums)\n        power_sums.append(current_sum)\n        \n        if current_sum > r:\n            break\n    \n    # Sort the power sums\n    power_sums.sort()\n    \n    # Find the maximum length of The Golden Age\n    max_length = 0\n    current_length = 0\n    \n    for i in range(len(power_sums)):\n        if power_sums[i] >= l:\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 0\n            \n    if max_length == 0:\n        print(0)\n    else:\n        print(max_length)\n\nif True:\n    solve()",
    "def solve(x, y, l, r):\n    # Store all possible sums of all powers of x and y\n    sums = set()\n    power = 1\n    while power < 60 * max(x, y):\n        sums.add(power)\n        power *= x\n    \n    # Sort the sums\n    sums = sorted(sums)\n    \n    # Find the longest Golden Age\n    max_length = 0\n    current_sum = 0\n    for i in range(len(sums)):\n        current_sum += sums[i]\n        while current_sum > r:\n            current_sum -= sums[i - len(sums) + 1]\n        if current_sum >= l:\n            max_length = max(max_length, i + 1)\n    \n    return max_length\n\n# Read input\nx, y, l, r = map(int, input().split())\n\n# Print output\nprint(solve(x, y, l, r))",
    "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    x, y, l, r = data\n    ans = solve(x, y, l, r)\n    print(ans)\n\ndef solve(x, y, l, r):\n    powers_x = set()\n    powers_y = set()\n    \n    power = 1\n    while power <= max(x, y):\n        powers_x.add(power)\n        powers_y.add(power)\n        \n        power *= x\n        if power > max(x, y):\n            break\n    \n    power = 1\n    while power <= max(x, y):\n        powers_y.add(power)\n        power *= y\n        if power > max(x, y):\n            break\n    \n    powers_x = sorted(powers_x)\n    powers_y = sorted(powers_y)\n    \n    i, j = 0, 0\n    res = 0\n    \n    while i < len(powers_x) and j < len(powers_y):\n        sum_x = sum(powers_x[i:])\n        sum_y = sum(powers_y[j:])\n        \n        if sum_x >= l and sum_x <= r:\n            res = max(res, len(powers_x[i:]) - 1)\n            \n        if sum_y >= l and sum_y <= r:\n            res = max(res, len(powers_y[j:]) - 1)\n        \n        if sum_x > sum_y:\n            i += 1\n        else:\n            j += 1\n    \n    return res\n\nif True:\n    main()",
    "import sys\nfrom typing import *\ninput = sys.stdin.read\ndata = input().split()\nx, y, l, r = map(int, data)\n\ndef is_unlucky(n):\n    return n not in [x**a + y**b for a in range(61) for b in range(61)]\n\ndef solve():\n    unlucky_years = []\n    for i in range(l, r+1):\n        if is_unlucky(i):\n            unlucky_years.append(i)\n    \n    if len(unlucky_years) == 0:\n        print(0)\n        return\n    \n    unlucky_years.sort()\n    max_length = 0\n    current_length = 1\n    \n    for i in range(1, len(unlucky_years)):\n        if unlucky_years[i] - unlucky_years[i-1] == 1:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n    \n    max_length = max(max_length, current_length)\n    print(max_length)\n\nsolve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    x, y, l, r = map(int, data)\n\n    def power_sum(x, y):\n        powers = set()\n        for i in range(61):\n            for j in range(61):\n                if i + j == 60:\n                    powers.add(x**i + y**j)\n        return sorted(powers)\n\n    powers_x = power_sum(x, y)\n    powers_y = power_sum(y, x)\n\n    powers = set(powers_x).union(set(powers_y))\n\n    max_length = 0\n    current_length = 0\n\n    for i in range(l, r + 1):\n        if i not in powers:\n            current_length = 0\n        else:\n            current_length += 1\n            max_length = max(max_length, current_length)\n\n    print(max_length if max_length > 0 else 0)\n\nif True:\n    solve()",
    "def solve(x, y, l, r):\n    from math import floor, ceil\n    from functools import reduce\n    from operator import mul\n    \n    def power_sum(x, y, max_power):\n        return sum(pow(x, i) + pow(y, j) for i in range(max_power + 1) for j in range(max_power + 1))\n    \n    def binary_search(start, end):\n        while start < end:\n            mid = (start + end) // 2\n            if power_sum(x, y, mid) > r:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return start\n    \n    left_unlucky = binary_search(0, l)\n    right_unlucky = binary_search(r + 1, 10 ** 18)\n    \n    if left_unlucky >= right_unlucky:\n        return 0\n    \n    max_length = 0\n    for i in range(left_unlucky, right_unlucky):\n        if power_sum(x, y, i) == i:\n            max_length = max(max_length, i - left_unlucky + 1)\n    \n    return max_length\n\n# Read input\nx, y, l, r = map(int, input().split())\n\n# Solve the problem\nprint(solve(x, y, l, r))",
    "import sys\n\ndef solve():\n    x, y, l, r = map(int, sys.stdin.readline().split())\n    \n    # Store all possible sums of all powers of x and y\n    power_x = []\n    power_y = []\n    for i in range(60):\n        power_x.append(x**i)\n        power_y.append(y**i)\n    \n    # Sort the lists\n    power_x.sort()\n    power_y.sort()\n    \n    # Binary search to find the maximum length of The Golden Age\n    max_length = 0\n    left, right = l, r\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # Check if mid is an unlucky year\n        found = False\n        for i in range(len(power_x)):\n            for j in range(len(power_y)):\n                if power_x[i] + power_y[j] == mid:\n                    found = True\n                    break\n            if found:\n                break\n        if not found:\n            right = mid - 1\n        else:\n            left = mid + 1\n            max_length = max(max_length, left - l)\n    \n    print(max_length)\n\nif True:\n    solve()",
    "import sys\nfrom typing import List\n\ndef main():\n    x, y, l, r = map(int, sys.stdin.readline().split())\n    \n    # Store all possible sums of all powers of x and y\n    power_sums_x = set()\n    power_sums_y = set()\n    \n    current_sum_x = 0\n    current_sum_y = 0\n    \n    while current_sum_x < 1e18:\n        power_sums_x.add(current_sum_x)\n        current_sum_x += x ** len(power_sums_x)\n    \n    while current_sum_y < 1e18:\n        power_sums_y.add(current_sum_y)\n        current_sum_y += y ** len(power_sums_y)\n    \n    # Sort the power sums\n    power_sums_x = sorted(power_sums_x)\n    power_sums_y = sorted(power_sums_y)\n    \n    # Find the maximum length of The Golden Age\n    max_length = 0\n    i = j = 0\n    \n    while i < len(power_sums_x) and j < len(power_sums_y):\n        if power_sums_x[i] > power_sums_y[j]:\n            j += 1\n        elif power_sums_x[i] < power_sums_y[j]:\n            i += 1\n        else:\n            max_length = max(max_length, j - i + 1)\n            i += 1\n            j += 1\n    \n    print(max_length)\n\nif True:\n    main()",
    "def solve(x, y, l, r):\n    from collections import defaultdict\n    from math import log\n\n    def power_sum(a, b):\n        return sum(pow(i, a) + pow(j, b) for i in range(x + 1) for j in range(y + 1))\n\n    prefix_sums = defaultdict(int)\n    current_sum = 0\n\n    # Calculate prefix sums of power sums\n    for i in range(1, int(log(r, x)) + 2):\n        current_sum += power_sum(i, 0)\n        prefix_sums[i] = current_sum\n\n    # Sort prefix sums\n    sorted_prefix_sums = sorted(prefix_sums.items())\n\n    # Find the longest golden age\n    max_length = 0\n    for i in range(len(sorted_prefix_sums)):\n        if sorted_prefix_sums[i][0] > r - l:\n            break\n        if i > 0:\n            max_length = max(max_length, sorted_prefix_sums[i][0] - sorted_prefix_sums[i - 1][0])\n        else:\n            max_length = max(max_length, sorted_prefix_sums[i][0])\n\n    return max_length\n\nif True:\n    x, y, l, r = map(int, input().split())\n    print(solve(x, y, l, r))",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    x, y, l, r = data\n    # Store all possible sums of all powers of x and y\n    powers_x = set()\n    powers_y = set()\n    for i in range(60):\n        powers_x.add(x**i)\n        powers_y.add(y**i)\n    # Sort the sets\n    powers_x = sorted(powers_x)\n    powers_y = sorted(powers_y)\n    # Find the longest sequence of consecutive numbers that are not in either set\n    max_length = 0\n    current_length = 0\n    for num in range(l, r+1):\n        if num not in powers_x and num not in powers_y:\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 0\n    print(max_length)\n\nif True:\n    solve()",
    "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    x, y, l, r = data\n    result = solve(x, y, l, r)\n    print(result)\n\ndef solve(x, y, l, r):\n    power_x = []\n    power_y = []\n    for i in range(61):\n        power_x.append(x**i)\n        power_y.append(y**i)\n    \n    power_x.sort()\n    power_y.sort()\n    \n    max_length = 0\n    \n    for i in range(len(power_x)):\n        for j in range(i, len(power_y)):\n            current_sum = power_x[i] + power_y[j]\n            while current_sum <= r:\n                if current_sum >= l:\n                    max_length = max(max_length, current_sum - l + 1)\n                current_sum *= x\n            \n            while current_sum > r:\n                current_sum //= x\n    \n    return max_length\n\nif True:\n    main()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    x, y, l, r = map(int, data)\n\n    def power_sum(x, y):\n        if x == 1:\n            return {y}\n        res = set()\n        for i in range(y + 1):\n            res |= power_sum(x, i)\n            res |= power_sum(i, y)\n        return res\n\n    power_set_x = power_sum(x, y)\n    power_set_y = power_sum(y, x)\n    power_set = power_set_x.union(power_set_y)\n\n    power_list = sorted(list(power_set))\n\n    max_length = 0\n    current_length = 0\n    last_unlucky_year = -1\n\n    for i in range(len(power_list)):\n        if power_list[i] > r:\n            break\n        if power_list[i] < l:\n            continue\n        if power_list[i] == last_unlucky_year:\n            continue\n        while i < len(power_list) - 1 and power_list[i + 1] - power_list[i] <= r - l:\n            i += 1\n        current_length = i - last_unlucky_year\n        if current_length > max_length:\n            max_length = current_length\n        last_unlucky_year = power_list[i]\n\n    print(max_length)\n\nif True:\n    solve()",
    "import sys\nfrom typing import *\nfrom collections import *\n\ndef solve():\n    x, y, l, r = map(int, sys.stdin.readline().split())\n    \n    # Store all possible sums of all powers of x and y\n    power_x = [x**i for i in range(60)]\n    power_y = [y**i for i in range(60)]\n    power_sum = set()\n    \n    for p in power_x:\n        for q in power_y:\n            power_sum.add(p + q)\n    \n    # Sort the list of unlucky years\n    power_sum = sorted(power_sum)\n    \n    # Check the difference between neighbouring unlucky years\n    max_length = 0\n    for i in range(len(power_sum)):\n        if i > 0 and power_sum[i] - power_sum[i-1] >= l:\n            max_length = max(max_length, i)\n    \n    print(max_length)\n\nif True:\n    solve()",
    "def solve(x, y, l, r):\n    def generate_sums(max_val):\n        sums = set()\n        for i in range(61):  # max power of x\n            for j in range(61):  # max power of y\n                val = x**i + y**j\n                if val <= max_val:\n                    sums.add(val)\n        return sorted(sums)\n\n    sums_x = generate_sums(r)\n    sums_y = generate_sums(r)\n    sums_xy = generate_sums(r)\n\n    def binary_search(target):\n        left, right = 0, len(sums_xy) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if sums_xy[mid] >= target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n\n    def count_unlucky_years(start, end):\n        count = 0\n        for i in range(start, end + 1):\n            if i in sums_xy:\n                count += 1\n        return count\n\n    result = 0\n    for i in range(l, r + 1):\n        if i not in sums_xy:\n            result = max(result, count_unlucky_years(i, r))\n    return result\n\nif True:\n    x, y, l, r = map(int, input().split())\n    print(solve(x, y, l, r))",
    "def main():\n    x, y, l, r = map(int, input().split())\n    \n    def power_sum(x, y):\n        sums = {0}\n        for i in range(1, 61):\n            new_sums = set()\n            for s in sums:\n                new_sums.add(s + x**i)\n                new_sums.add(s + y**i)\n            sums |= new_sums\n        return sorted(sums)\n    \n    sums_x = power_sum(x, y)\n    sums_y = power_sum(y, x)\n    \n    max_length = 0\n    for i in range(len(sums_x)):\n        for j in range(i, len(sums_y)):\n            if sums_x[i] <= l <= sums_x[j] <= r:\n                max_length = max(max_length, j - i + 1)\n                \n    if max_length == 0:\n        print(0)\n    else:\n        print(max_length)\n\nif True:\n    main()",
    "def solve(x, y, l, r):\n    # Generate all possible sums of x^a and y^b up to 10^18\n    power_sums = set()\n    for i in range(60):\n        for j in range(60):\n            power_sums.add((x**i) + (y**j))\n    \n    # Sort the power sums\n    power_sums = sorted(power_sums)\n    \n    # Initialize variables\n    max_length = 0\n    current_sum = 0\n    \n    # Iterate through the sorted power sums\n    for i in range(len(power_sums)):\n        while current_sum < l and i < len(power_sums):\n            current_sum += power_sums[i]\n            i += 1\n        \n        if current_sum > r:\n            break\n        \n        max_length = max(max_length, i - (current_sum - l) // power_sums[current_sum - l])\n    \n    return max_length\n\n# Read input\nx, y, l, r = map(int, input().split())\n\n# Print the result\nprint(solve(x, y, l, r))",
    "def solve(x, y, l, r):\n    # Store all possible sums of all powers of x and y\n    sums = set()\n    for i in range(61):\n        for j in range(61):\n            sums.add(x**i + y**j)\n    \n    # Sort the list of sums\n    sums = sorted(sums)\n    \n    # Initialize variables to keep track of the current sum and the maximum length of the Golden Age\n    current_sum = sums[0]\n    max_length = 0\n    \n    # Iterate through the sorted list of sums\n    for i in range(len(sums)):\n        if current_sum + sums[i] > r:\n            break\n        \n        current_sum += sums[i]\n        max_length = max(max_length, i - 1)\n    \n    return max_length\n\n# Read input from stdin\nx, y, l, r = map(int, input().split())\n\n# Print the result\nprint(solve(x, y, l, r))",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    x, y, l, r = map(int, data)\n\n    # Store all possible sums of all powers of x and y\n    power_x = [x ** i for i in range(61)]\n    power_y = [y ** i for i in range(61)]\n\n    # Generate all possible sums of x^a + y^b\n    sums = set()\n    for i in range(len(power_x)):\n        for j in range(len(power_y)):\n            sums.add(power_x[i] + power_y[j])\n\n    # Sort the sums and check differences between consecutive unlucky years\n    sums = sorted(sums)\n    max_length = 0\n    for i in range(len(sums) - 1):\n        if sums[i + 1] - sums[i] > 1:\n            max_length = max(max_length, sums[i + 1] - sums[i] - 1)\n\n    # Print the result\n    print(max_length if max_length != 0 else 0)\n\nif True:\n    solve()"
  ],
  "rewards": [
    0.023255813953488372,
    0.0,
    0.0,
    0.023255813953488372,
    0.0,
    0.023255813953488372,
    0.0,
    0.16279069767441862,
    0.023255813953488372,
    0.0,
    0.0,
    0.0,
    0.023255813953488372,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.06976744186046512,
    0.0,
    0.023255813953488372,
    0.023255813953488372,
    0.0,
    0.023255813953488372,
    0.0,
    0.023255813953488372,
    0.0,
    0.023255813953488372,
    0.0,
    0.046511627906976744,
    0.0,
    0.0,
    0.023255813953488372,
    0.0,
    0.0,
    0.0,
    0.0,
    0.046511627906976744,
    0.0,
    0.0,
    0.09302325581395349,
    0.0,
    0.0,
    0.0,
    0.0,
    0.023255813953488372,
    0.0,
    0.0
  ],
  "train rewards": [
    0.023809523809523808,
    0.0,
    0.0,
    0.047619047619047616,
    0.0,
    0.047619047619047616,
    0.0,
    0.09523809523809523,
    0.0,
    0.0,
    0.0,
    0.0,
    0.07142857142857142,
    0.047619047619047616,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.16666666666666666,
    0.0,
    0.0,
    0.047619047619047616,
    0.0,
    0.023809523809523808,
    0.0,
    0.047619047619047616,
    0.0,
    0.047619047619047616,
    0.0,
    0.023809523809523808,
    0.11904761904761904,
    0.0,
    0.047619047619047616,
    0.0,
    0.0,
    0.0,
    0.0,
    0.21428571428571427,
    0.0,
    0.0,
    0.023809523809523808,
    0.0,
    0.0,
    0.0,
    0.0,
    0.023809523809523808,
    0.023809523809523808,
    0.0
  ],
  "time": 458.110004901886,
  "sample times": 50
}