{
  "prompt": "\nQUESTION:\nTwo bored soldiers are playing card war. Their card deck consists of exactly n cards, numbered from 1 to n, all values are different. They divide cards between them in some manner, it's possible that they have different number of cards. Then they play a \"war\"-like card game. \n\nThe rules are following. On each turn a fight happens. Each of them picks card from the top of his stack and puts on the table. The one whose card value is bigger wins this fight and takes both cards from the table to the bottom of his stack. More precisely, he first takes his opponent's card and puts to the bottom of his stack, and then he puts his card to the bottom of his stack. If after some turn one of the player's stack becomes empty, he loses and the other one wins. \n\nYou have to calculate how many fights will happen and who will win the game, or state that game won't end.\n\n\n-----Input-----\n\nFirst line contains a single integer n (2 \u2264 n \u2264 10), the number of cards.\n\nSecond line contains integer k_1 (1 \u2264 k_1 \u2264 n - 1), the number of the first soldier's cards. Then follow k_1 integers that are the values on the first soldier's cards, from top to bottom of his stack.\n\nThird line contains integer k_2 (k_1 + k_2 = n), the number of the second soldier's cards. Then follow k_2 integers that are the values on the second soldier's cards, from top to bottom of his stack.\n\nAll card values are different.\n\n\n-----Output-----\n\nIf somebody wins in this game, print 2 integers where the first one stands for the number of fights before end of game and the second one is 1 or 2 showing which player has won.\n\nIf the game won't end and will continue forever output  - 1.\n\n\n-----Examples-----\nInput\n4\n2 1 3\n2 4 2\n\nOutput\n6 2\nInput\n3\n1 2\n2 1 3\n\nOutput\n-1\n\n\n-----Note-----\n\nFirst sample:  [Image] \n\nSecond sample:  [Image]\n\nTUTORIAL:\nIt's easy to count who wins and after how many \"fights\", but it's harder to say, that game won't end. How to do it?\n\nFirstly let's count a number of different states that we can have in the game. Cards can be arranged in any one of n! ways. In every of this combination, we must separate first soldier's cards from the second one's. We can separate it in n + 1 places (because we can count the before and after deck case too).\n\nSo war has (n + 1)! states. If we'd do (n + 1)! \"fights\" and we have not finished the game yes, then we'll be sure that there is a state, that we passed at least twice. That means that we have a cycle, and game won't end.\n\nAfter checking this game more accurately I can say that the longest path in the state-graph for n = 10 has length 106, so it is enough to do 106 fights, but solutions that did about 40 millions also passed.\n\nAlternative solution is to map states that we already passed. If we know, that the longest time needed to return to state is about 100, then we know that this solution is correct and fast.\n\n\nInstructions:\n\n\nYou are a Python3 code generator.  Output **only** valid Python code. No explanations, no commentary, no filenames, no Markdown formatting. You will spit out a code block that can be pasted into any script. It must read the input, execute the logic and then print the output. Ensure that you invoke the main() or solve() function at the end if you're writing your code inside them.\nANSWER:\n",
  "codes": [
    "def solve(n, k1, k2):\n    import sys\n    from collections import deque\n    \n    # Initialize the decks\n    deck1 = deque(range(1, k1 + 1))\n    deck2 = deque(range(k1 + 1, k1 + k2 + 1))\n    \n    # Initialize the state dictionary\n    states = {}\n    states[deck1, deck2] = 0\n    \n    # Initialize the queue with the initial state\n    queue = deque([(deck1, deck2)])\n    \n    # Initialize the number of fights\n    fights = 0\n    \n    while queue:\n        # Get the current state\n        deck1, deck2 = queue.popleft()\n        \n        # Check if we have reached a state we've seen before\n        if (deck1, deck2) in states:\n            break\n        \n        # Update the state dictionary\n        states[deck1, deck2] = fights\n        \n        # Generate new states by moving cards from one deck to the other\n        for i in range(len(deck1)):\n            for j in range(len(deck2)):\n                new_deck1 = deque(list(deck1))\n                new_deck1.remove(new_deck1[i])\n                new_deck2 = deque(list(deck2))\n                new_deck2.remove(new_deck2[j])\n                \n                # Add the new state to the queue\n                queue.append((new_deck1, new_deck2))\n        \n        # Increment the number of fights\n        fights += 1\n    \n    # Print the result\n    if len(states) == 1:\n        print(fights, 1)\n    else:\n        print(-1)\n\n# Read input\nn = int(sys.stdin.readline())\nk1 = int(sys.stdin.readline())\nk2 = int(sys.stdin.readline())\n\n# Solve the problem\nsolve(n, k1, k2)",
    "def solve(n, k1, k2, cards1, cards2):\n    import itertools\n    states = set()\n    \n    def dfs(state):\n        if state in states:\n            return True\n        states.add(state)\n        \n        # Check if either deck is empty\n        if not cards1 or not cards2:\n            return False\n        \n        # Get the current maximum value in the deck\n        max_val1 = max(cards1)\n        max_val2 = max(cards2)\n        \n        # Try to take the highest card from each deck\n        if max_val1 >= max_val2:\n            cards1.remove(max_val1)\n            cards2.append(max_val1)\n            return dfs(tuple(cards1) + tuple(cards2))\n        else:\n            cards2.remove(max_val2)\n            cards1.append(max_val2)\n            return dfs(tuple(cards1) + tuple(cards2))\n    \n    # Perform DFS starting from an arbitrary state\n    dfs(tuple(itertools.chain(cards1, cards2)))\n    \n    # Calculate the number of fights\n    num_fights = len(states) - 1\n    \n    # Determine the winner\n    if num_fights % 2 == 0:\n        winner = 2\n    else:\n        winner = 1\n    \n    print(num_fights, winner)\n\n# Main function to handle input and call solve()\nif True:\n    input_data = input().split()\n    n = int(input_data[0])\n    k1 = int(input_data[1])\n    k2 = int(input_data[2])\n    cards1 = list(map(int, input_data[3:k1+3]))\n    cards2 = list(map(int, input_data[k1+3:]))\n    \n    solve(n, k1, k2, cards1, cards2)",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n = data[0]\n    k1 = data[1]\n    k2 = data[2]\n    deck1 = data[3:k1+3]\n    deck2 = data[3+k1:]\n\n    def dfs(deck1, deck2):\n        if len(deck1) == 0 or len(deck2) == 0:\n            return True, 0\n        for i in range(len(deck1)):\n            for j in range(len(deck2)):\n                if deck1[i] > deck2[j]:\n                    new_deck1 = deck1[:i] + deck1[i+1:]\n                    new_deck2 = deck2[:j] + deck2[j+1:]\n                    if not dfs(new_deck1, new_deck2):\n                        return False, 1\n        return True, 0\n\n    result, _ = dfs(deck1, deck2)\n    if result:\n        print(10**6, 2)\n    else:\n        print(-1)\n\nsolve()",
    "import sys\nfrom collections import defaultdict\n\ndef solve():\n    n = int(sys.stdin.readline())\n    s1 = list(map(int, sys.stdin.readline().split()))\n    s2 = list(map(int, sys.stdin.readline().split()))\n\n    def dfs(s1, s2):\n        if len(s1) == 0:\n            return 0, 1\n        if len(s2) == 0:\n            return 0, 2\n        if (s1, s2) in memo:\n            return memo[(s1, s2)]\n        \n        f1, w1 = dfs(s1[1:], s2)\n        f2, w2 = dfs(s1, s2[1:])\n        \n        if s1[-1] > s2[-1]:\n            f1 += 1\n            w1 += 1\n        elif s1[-1] < s2[-1]:\n            f2 += 1\n            w2 += 1\n        \n        memo[(s1, s2)] = max(f1, f2), w1 + w2\n        return memo[(s1, s2)]\n\n    memo = defaultdict(lambda: (-1, 0))\n    result = dfs(s1, s2)\n    \n    if result[0] == -1:\n        print(-1)\n    else:\n        print(result[0], result[1])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k1 = int(data[1])\n    s1 = list(map(int, data[2:k1+2]))\n    k2 = int(data[2+k1])\n    s2 = list(map(int, data[2+k1+2:]))\n\n    # Calculate the number of different states that we can have in the game\n    states = (n + 1) * factorial(n)\n    \n    # If we do (n + 1)! \"fights\" and we have not finished the game yes, then we'll be sure that there is a state, that we passed at least twice. That means that we have a cycle, and game won't end.\n    if len(s1) == 0 or len(s2) == 0:\n        print(-1)\n        return\n    \n    # Map states that we already passed\n    visited = set()\n    visited.add(tuple(s1))\n    visited.add(tuple(s2))\n    \n    # Count the number of fights\n    fights = 0\n    while True:\n        fights += 1\n        \n        # Choose the next card to play\n        if len(s1) > 0 and len(s2) > 0:\n            if s1[-1] > s2[-1]:\n                s1.pop()\n                s2.pop()\n            elif s1[-1] < s2[-1]:\n                s1.pop()\n            else:\n                s1.pop()\n                s2.pop()\n        \n        # Check if we've reached a state we've already seen\n        if tuple(s1) in visited or tuple(s2) in visited:\n            break\n        \n        # Add the current state to the visited set\n        visited.add(tuple(s1))\n        visited.add(tuple(s2))\n    \n    print(fights, 1 if len(s1) > 0 else 2)\n\nif True:\n    solve()",
    "import sys\nfrom collections import deque\n\ndef solve():\n    n = int(sys.stdin.readline())\n    s1 = list(map(int, sys.stdin.readline().split()))\n    s2 = list(map(int, sys.stdin.readline().split()))\n\n    def dfs(s1, s2):\n        if not s1 or not s2:\n            return len(s1) + len(s2)\n        \n        visited = set()\n        queue = deque([(s1, s2)])\n        \n        while queue:\n            curr_s1, curr_s2 = queue.popleft()\n            \n            if tuple(curr_s1) in visited or tuple(curr_s2) in visited:\n                continue\n            \n            visited.add(tuple(curr_s1))\n            visited.add(tuple(curr_s2))\n            \n            new_s1 = [curr_s1[-1]] + curr_s1[:-1]\n            new_s2 = [curr_s2[-1]] + curr_s2[:-1]\n            \n            queue.append((new_s1, curr_s2))\n            queue.append((curr_s1, new_s2))\n        \n        return float('inf')\n\n    result = dfs(s1, s2)\n    if result == float('inf'):\n        print(-1)\n    else:\n        print(result // 2 + 1, 1 if result % 2 == 0 else 2)\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n = data[0]\n    k1 = data[1]\n    cards1 = data[2:k1+2]\n    k2 = data[k1+2]\n    cards2 = data[k1+2+k2:]\n    \n    def get_state(cards):\n        return tuple(cards)\n    \n    states = set()\n    states.add(get_state(cards1))\n    states.add(get_state(cards2))\n    \n    fights = 0\n    while True:\n        new_cards1 = []\n        new_cards2 = []\n        \n        # First soldier's turn\n        if cards1:\n            max_card1 = max(cards1)\n            index1 = cards1.index(max_card1)\n            new_cards1.append(max_card1)\n            new_cards1.append(cards1[index1])\n            del cards1[index1]\n            \n        # Second soldier's turn\n        if cards2:\n            max_card2 = max(cards2)\n            index2 = cards2.index(max_card2)\n            new_cards2.append(max_card2)\n            new_cards2.append(cards2[index2])\n            del cards2[index2]\n        \n        new_state1 = get_state(new_cards1)\n        new_state2 = get_state(new_cards2)\n        \n        if new_state1 in states:\n            print(fights, 1)\n            return\n        if new_state2 in states:\n            print(fights, 2)\n            return\n        \n        states.add(new_state1)\n        states.add(new_state2)\n        \n        fights += 1\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k1 = int(data[1])\n    cards1 = list(map(int, data[2:k1+2]))\n    k2 = int(data[2+k1])\n    cards2 = list(map(int, data[2+k1+2:]))\n    \n    def dfs(i, j):\n        nonlocal ans\n        if i == len(cards1) or j == len(cards2):\n            ans += 1\n            return\n        dfs(i+1, j)\n        dfs(i, j+1)\n    \n    ans = 0\n    dfs(0, 0)\n    print(ans)\n\nsolve()",
    "import sys\nfrom collections import defaultdict\n\ndef solve(n, k1, values1, k2, values2):\n    # Create a dictionary to store the number of times each state occurs\n    state_counts = defaultdict(int)\n    \n    # Initialize the current state with the initial positions of the cards\n    current_state = tuple(values1 + values2)\n    state_counts[current_state] += 1\n    \n    # Initialize the number of fights and the winner\n    fights = 0\n    winner = None\n    \n    # Perform the fights until we reach a cycle or determine a winner\n    while True:\n        # Find the next state by taking the top card from each player's stack\n        next_values1 = values1[1:] + values1[:1]\n        next_values2 = values2[1:] + values2[:1]\n        \n        # Update the current state\n        current_state = tuple(next_values1 + next_values2)\n        \n        # Increment the number of fights\n        fights += 1\n        \n        # Check if we've seen this state before\n        if state_counts[current_state] > 1:\n            # If we've seen this state before, we have a cycle\n            winner = 1\n            break\n        else:\n            # Otherwise, increment the count of this state\n            state_counts[current_state] += 1\n            \n        # Check if we've reached a state that we've seen before (cycle)\n        if current_state == (values1[0], values2[0]):\n            winner = 2\n            break\n    \n    # Print the result\n    print(fights, winner)\n\n# Read input\ninput_data = sys.stdin.read().strip()\ndata = input_data.split()\n\n# Parse the input data\nn = int(data[0])\nk1 = int(data[1])\nvalues1 = list(map(int, data[2:2+k1]))\nk2 = int(data[2+k1])\nvalues2 = list(map(int, data[2+k1+1:]))\n\n# Solve the problem\nsolve(n, k1, values1, k2, values2)",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n = data[0]\n    k1 = data[1]\n    cards1 = data[2:k1+2]\n    k2 = data[k1+2]\n    cards2 = data[k1+2:]\n    \n    def dfs(state):\n        nonlocal visited, result\n        if state in visited:\n            return\n        visited.add(state)\n        \n        if len(cards1) == 0:\n            result = (len(cards2), 2)\n            return\n        if len(cards2) == 0:\n            result = (len(cards1), 1)\n            return\n        \n        for i in range(k1):\n            for j in range(k2):\n                new_state = tuple(sorted(cards1[:i] + cards2[j:] + cards1[i+1:] + cards2[j+1:]))\n                dfs(new_state)\n                \n    visited = set()\n    result = None\n    dfs(tuple(cards1))\n    \n    if result is None:\n        print(-1)\n    else:\n        print(result[0], result[1])\n\nif True:\n    solve()",
    "import sys\nfrom collections import defaultdict\n\ndef solve(n, k1, cards1, k2, cards2):\n    def dfs(i, j):\n        nonlocal cnt\n        if i == len(cards1) or j == len(cards2):\n            cnt += 1\n            return\n        dfs(i + 1, j)\n        dfs(i, j + 1)\n    \n    cnt = 0\n    dfs(0, 0)\n    if cnt >= n * (n - 1) // 2:\n        print(-1)\n    else:\n        print(cnt, 1)\n\nif True:\n    input_data = sys.stdin.read().strip()\n    data = input_data.split('\\n')\n    n = int(data[0])\n    k1 = int(data[1])\n    cards1 = list(map(int, data[2].split()))\n    k2 = int(data[3])\n    cards2 = list(map(int, data[4].split()))\n    solve(n, k1, cards1, k2, cards2)",
    "def solve(n, k1, values1, k2, values2):\n    import math\n    \n    def get_state(cards1, cards2):\n        # Convert lists of card values to strings\n        s1 = ''.join(map(str, cards1))\n        s2 = ''.join(map(str, cards2))\n        \n        # Return a unique string representation of the state\n        return f\"{s1}:{s2}\"\n    \n    def dfs(state, visited):\n        # Base case: if the current state is already visited, return 0\n        if state in visited:\n            return 0\n        \n        # Mark the current state as visited\n        visited.add(state)\n        \n        # Initialize the number of fights\n        fights = 0\n        \n        # Try to find a better state by swapping two cards\n        for i in range(len(values1)):\n            for j in range(i+1, len(values1)):\n                new_cards1 = values1[:i] + values1[i:j+1][::-1] + values1[j+1:]\n                new_cards2 = values2[:j] + values2[j:i+1][::-1] + values2[i+1:]\n                \n                new_state = get_state(new_cards1, new_cards2)\n                \n                # Recursively call DFS for the new state\n                fights += dfs(new_state, visited)\n        \n        # Return the total number of fights for the current state\n        return fights + 1\n    \n    # Get initial state\n    initial_state = get_state(values1, values2)\n    \n    # Perform DFS to count the number of fights\n    visited = set()\n    result = dfs(initial_state, visited)\n    \n    # Check if the game ended with a cycle\n    if result == 0:\n        print(\"-1\")\n    else:\n        print(result, 2)\n\n# Read input\nn = int(input())\nk1 = int(input())\nvalues1 = list(map(int, input().split()))\nk2 = int(input())\nvalues2 = list(map(int, input().split()))\n\n# Solve the problem\nsolve(n, k1, values1, k2, values2)",
    "import sys\nfrom collections import defaultdict\n\ndef solve(n, k1, k2, values1, values2):\n    def dfs(state, depth):\n        if state in memo:\n            return memo[state]\n        if depth >= 100:\n            return True\n        memo[state] = False\n        for i in range(k1):\n            for j in range(k2):\n                if values1[i] > values2[j]:\n                    new_state = tuple(sorted(values1[:i] + values2[:j] + values1[i+1:] + values2[j+1:], reverse=True))\n                    if dfs(new_state, depth + 1):\n                        memo[state] = True\n                        break\n        return memo[state]\n    \n    memo = defaultdict(bool)\n    result = dfs(tuple(sorted(values1 + values2, reverse=True)), 0)\n    if result:\n        return len(memo) - 1, 1\n    else:\n        return -1, 2\n\nif True:\n    input_data = sys.stdin.read().split()\n    n = int(input_data[0])\n    k1 = int(input_data[1])\n    k2 = n - k1\n    values1 = list(map(int, input_data[2:k1+2]))\n    values2 = list(map(int, input_data[k1+2:n+2]))\n    print(*solve(n, k1, k2, values1, values2))",
    "def solve(n, k1, k2):\n    from collections import defaultdict\n    dp = defaultdict(int)\n    dp[(0, 0)] = 1\n    for i in range(1, n + 1):\n        new_dp = defaultdict(int)\n        for (a, b) in dp.items():\n            if a < k1:\n                new_dp[(a + 1, b)] += b\n            if b < k2:\n                new_dp[(a, b + 1)] += b\n        dp = new_dp\n    if dp[(n, n)] > 0:\n        return dp[(n, n)], 2\n    elif dp[(0, 0)] > 0:\n        return dp[(0, 0)], 1\n    else:\n        return -1\n\nif True:\n    n = int(input())\n    k1 = int(input())\n    k2 = int(input())\n    result, winner = solve(n, k1, k2)\n    print(result, winner)",
    "def solve(n, k1, k2):\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    k1, k2 = data[0], data[1]\n    cards1 = data[2:k1+2]\n    cards2 = data[k1+2:]\n    \n    def dfs(i, j):\n        nonlocal count\n        if i == j:\n            return True\n        if i > j:\n            return False\n        if (i, j) in memo:\n            return memo[(i, j)]\n        \n        if cards1[i] > cards2[j]:\n            result = dfs(i+1, j)\n        elif cards1[i] < cards2[j]:\n            result = dfs(i, j+1)\n        else:\n            result = dfs(i+1, j+1) or dfs(i+1, j) or dfs(i, j+1)\n        \n        memo[(i, j)] = result\n        return result\n    \n    count = 0\n    memo = {}\n    dfs(0, len(cards2)-1)\n    \n    if count >= 10**6:\n        print(-1)\n    else:\n        print(count, 1)\n\nif True:\n    solve(*map(int, input().split()))",
    "def solve(n, k1, k2):\n    import math\n    \n    # Calculate total number of states\n    total_states = math.factorial(n + 1)\n    \n    # Check if game will end\n    if total_states <= 100:\n        print(-1)\n    else:\n        print(total_states, 2)\n\n# Read input\nn = int(input())\nk1 = int(input())\nk2 = int(input())\n\n# Parse card values\ncards1 = list(map(int, input().split()))\ncards2 = list(map(int, input().split()))\n\n# Solve the problem\nsolve(n, k1, k2)",
    "import sys\nfrom collections import deque\n\ndef solve():\n    n = int(sys.stdin.readline())\n    s1 = list(map(int, sys.stdin.readline().split()))\n    s2 = list(map(int, sys.stdin.readline().split()))\n\n    def dfs(i):\n        nonlocal cnt\n        if i == len(s1) + len(s2):\n            cnt += 1\n            return\n        if s1[i] > s2[i]:\n            dfs(i + 1)\n            dfs(i + 2)\n        else:\n            dfs(i + 1)\n\n    cnt = 0\n    dfs(0)\n\n    if cnt < 1000000:\n        print(cnt, 2)\n    else:\n        print(-1)\n\nif True:\n    solve()",
    "import sys\nfrom collections import defaultdict\n\ndef solve():\n    n = int(input())\n    deck1 = list(map(int, input().split()))\n    deck2 = list(map(int, input().split()))\n    \n    def get_state(deck):\n        return tuple(sorted(deck))\n    \n    state_to_count = defaultdict(int)\n    current_state = get_state(deck1)\n    state_to_count[current_state] += 1\n    \n    num_fights = 0\n    while True:\n        num_fights += 1\n        if state_to_count[current_state] > 1:\n            print(num_fights, 1)\n            return\n        \n        new_deck1 = []\n        new_deck2 = []\n        \n        while deck1:\n            if deck1[-1] >= deck2[-1]:\n                new_deck1.append(deck1.pop())\n                new_deck2.append(deck2.pop())\n            else:\n                new_deck1.append(deck1.pop())\n                new_deck2.append(deck2.pop())\n        \n        while deck2:\n            if deck2[-1] >= deck1[-1]:\n                new_deck1.append(deck1.pop())\n                new_deck2.append(deck2.pop())\n            else:\n                new_deck1.append(deck1.pop())\n                new_deck2.append(deck2.pop())\n        \n        current_state = get_state(new_deck1 + new_deck2)\n        state_to_count[current_state] += 1\n\nif True:\n    solve()",
    "import sys\nfrom collections import defaultdict\n\ndef solve():\n    n = int(input())\n    s1 = list(map(int, input().split()))\n    s2 = list(map(int, input().split()))\n    \n    def dfs(s):\n        nonlocal cnt\n        if len(s) == 0:\n            return True\n        for i in range(len(s)):\n            if dfs(s[:i] + s[i+1:]):\n                cnt += 1\n                return True\n        return False\n    \n    cnt = 0\n    dfs(s1)\n    dfs(s2)\n    \n    if cnt > n * (n - 1) // 2:\n        print(-1)\n    else:\n        print(cnt, 1)\n\nif True:\n    solve()",
    "import sys\n\ndef solve(n, k1, k2, cards1, cards2):\n    states = set()\n    current_state = tuple(cards1) + tuple(cards2)\n    while current_state not in states:\n        states.add(current_state)\n        cards1.append(cards1.pop(0))\n        cards2.append(cards2.pop(0))\n        current_state = tuple(cards1) + tuple(cards2)\n    \n    if len(states) == n * (n - 1) // 2:\n        return -1\n    \n    num_fights = len(states) - 1\n    winner = 1 if len(states) % 2 else 2\n    print(num_fights, winner)\n\nif True:\n    n = int(sys.stdin.readline())\n    k1 = int(sys.stdin.readline())\n    k2 = n - k1\n    cards1 = list(map(int, sys.stdin.readline().split()))\n    cards2 = list(map(int, sys.stdin.readline().split()))\n    solve(n, k1, k2, cards1, cards2)",
    "def solve(n, k1, values1, k2, values2):\n    import sys\n    from collections import defaultdict\n    \n    # Calculate the number of states\n    total_states = (n + 1) * factorial(n)\n    \n    # Create a dictionary to store the number of times each state occurs\n    state_counts = defaultdict(int)\n    \n    # Initialize the current state with the initial positions of the cards\n    current_state = tuple(values1 + values2[::-1])\n    state_counts[current_state] += 1\n    \n    # Initialize variables to keep track of the number of fights and the last seen state\n    num_fights = 0\n    last_seen_state = None\n    \n    # Iterate until we reach a state we've seen before\n    while True:\n        num_fights += 1\n        \n        # Find the index of the smallest card in the current state\n        min_index = current_state.index(min(current_state))\n        \n        # Move the smallest card to the bottom of its stack\n        current_state = current_state[:min_index] + current_state[min_index+1:]\n        \n        # Check if we've seen this state before\n        if current_state == last_seen_state:\n            break\n        \n        # Update the state counts and the last seen state\n        state_counts[current_state] += 1\n        last_seen_state = current_state\n    \n    # Determine the winner based on the number of fights\n    if state_counts[current_state] % 2 == 0:\n        print(num_fights // 2, 2)\n    else:\n        print(num_fights // 2, 1)\n\n# Read input\nn = int(input())\nk1 = int(input())\nvalues1 = list(map(int, input().split()))\nk2 = int(input())\nvalues2 = list(map(int, input().split()))\n\n# Solve the problem\nsolve(n, k1, values1, k2, values2)",
    "import sys\nfrom collections import defaultdict\n\ndef solve(n, k1, k2, cards1, cards2):\n    def get_state(cards1, cards2):\n        return tuple(sorted(cards1)) + tuple(sorted(cards2))\n\n    states = defaultdict(int)\n    states[(cards1, cards2)] = 1\n    visited = set()\n    visited.add((cards1, cards2))\n    \n    def dfs(cards1, cards2):\n        nonlocal states, visited\n        state = get_state(cards1, cards2)\n        \n        if state in states:\n            return states[state]\n        \n        max_fights = 0\n        \n        for i in range(len(cards1)):\n            new_cards1 = cards1[:i] + cards1[i+1:]\n            new_cards2 = cards2[:len(cards2)-1] + [cards2[-1], cards1[i]]\n            \n            if new_cards1 != cards1 and new_cards2 != cards2:\n                max_fights = max(max_fights, dfs(new_cards1, new_cards2) + 1)\n        \n        states[state] = max_fights\n        visited.add(state)\n        \n        return max_fights\n    \n    max_fights = dfs(cards1, cards2)\n    if len(visited) == n * (n - 1):\n        print(-1)\n    else:\n        print(max_fights, 1 if max_fights % 2 == 0 else 2)\n\nif True:\n    n = int(sys.stdin.readline())\n    k1 = int(sys.stdin.readline())\n    k2 = n - k1\n    cards1 = list(map(int, sys.stdin.readline().split()))\n    cards2 = list(map(int, sys.stdin.readline().split()))\n    solve(n, k1, k2, cards1, cards2)",
    "import sys\n\ndef solve():\n    n = int(sys.stdin.readline().strip())\n    k1 = int(sys.stdin.readline().strip())\n    s1 = list(map(int, sys.stdin.readline().strip().split()))\n    k2 = int(sys.stdin.readline().strip())\n    s2 = list(map(int, sys.stdin.readline().strip().split()))\n\n    # Counting the number of different states\n    states = set()\n    def dfs(i):\n        if i == len(s1) + len(s2):\n            return True\n        if (i, tuple(s1[i:] + s2[:])) in states:\n            return False\n        states.add((i, tuple(s1[i:] + s2[:])))\n        return dfs(i+1) or dfs(i+k1)\n    \n    if dfs(0):\n        print(len(states) - 1, 1)\n    else:\n        print(-1)\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, k1, k2 = data[:3]\n    cards1 = data[3:k1+3]\n    cards2 = data[k1+3:]\n    \n    def get_next_state(state):\n        next_states = []\n        for i in range(k1):\n            for j in range(i + 1, k1):\n                next_states.append((state[:i] + state[i+1:j] + state[j:] + [cards1[i]] + [cards1[j]], 1))\n                next_states.append((state[:j] + state[j+1:i] + state[i:] + [cards2[i]] + [cards2[j]], 2))\n        return next_states\n    \n    def dfs(state, depth):\n        nonlocal max_depth\n        if depth > max_depth:\n            max_depth = depth\n        next_states = get_next_state(state)\n        for next_state, winner in next_states:\n            dfs(next_state, depth + 1)\n    \n    max_depth = 0\n    dfs(cards1 + cards2, 0)\n    \n    if max_depth == 106:\n        print(106, 2)\n    else:\n        print(-1)\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n = data[0]\n    k1 = data[1]\n    s1 = data[2:k1+2]\n    k2 = data[k1+2]\n    s2 = data[k1+2:]\n    \n    # Calculate number of different states\n    total_states = factorial(n)\n    \n    # Check if game won't end\n    if total_states <= 1000000:\n        print(-1)\n    else:\n        print(total_states // 2)\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, k1, k2 = data[0], data[1], data[2]\n    s1 = sorted(data[3:k1+3])\n    s2 = sorted(data[k1+3:])\n    i1, i2 = 0, 0\n    cnt = 0\n    while True:\n        if i1 == k1:\n            break\n        if i2 == k2:\n            break\n        if s1[i1] > s2[i2]:\n            i1 += 1\n        else:\n            i2 += 1\n        cnt += 1\n    print(cnt, 1 if i1 == k1 else 2)\n\nif True:\n    solve()",
    "import sys\nfrom collections import defaultdict\n\ndef solve(n, k1, cards1, k2, cards2):\n    def dfs(state):\n        nonlocal count, visited\n        if state in visited:\n            return False\n        visited.add(state)\n        count += 1\n        if state == target_state:\n            return True\n        for i in range(k1):\n            for j in range(i+1, k1):\n                new_state = tuple(sorted(cards1[:i]+cards1[i+1:j]+cards1[j:]))\n                if dfs(new_state):\n                    return True\n        for i in range(k2):\n            for j in range(i+1, k2):\n                new_state = tuple(sorted(cards2[:i]+cards2[i+1:j]+cards2[j:]))\n                if dfs(new_state):\n                    return True\n        return False\n    \n    visited = set()\n    count = 0\n    target_state = tuple(range(1, n+1))\n    \n    if not dfs(tuple(cards1)):\n        return -1\n    return count, 2 if count % 2 == 0 else 1\n\nif True:\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n = data[0]\n    k1 = data[1]\n    cards1 = data[2:k1+2]\n    k2 = data[k1+2]\n    cards2 = data[k1+2+k2:]\n    result = solve(n, k1, cards1, k2, cards2)\n    print(*result)",
    "def solve(n, k1, k2, values1, values2):\n    import sys\n    sys.setrecursionlimit(1000000)\n    \n    def dfs(i, j, visited):\n        if i >= n or j >= n:\n            return False\n        \n        if (i, j) in visited:\n            return True\n        \n        visited.add((i, j))\n        \n        if values1[i] > values2[j]:\n            return dfs(i + 1, j + 1, visited)\n        elif values1[i] < values2[j]:\n            return dfs(i + 1, j, visited)\n        else:\n            return dfs(i + 1, j + 1, visited) or dfs(i + 1, j, visited) or dfs(i, j + 1, visited) or dfs(i, j, visited)\n    \n    visited = set()\n    result = 0\n    \n    while not dfs(0, 0, visited):\n        result += 1\n    \n    return result, 1 if result % 2 == 0 else 2\n\n# Read input\nn = int(input())\nk1 = int(input())\nvalues1 = list(map(int, input().split()))\nk2 = int(input())\nvalues2 = list(map(int, input().split()))\n\n# Solve and print output\nresult, winner = solve(n, k1, k2, values1, values2)\nprint(result, winner)",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n = data[0]\n    k1 = data[1]\n    s1 = data[2:k1+2]\n    k2 = data[k1+2:]\n    s2 = data[k1+2:]\n    \n    def dfs(s1, s2):\n        if len(s1) == 0 or len(s2) == 0:\n            return 0\n        \n        # Check if we've seen this state before\n        key = tuple(sorted(s1)) + tuple(sorted(s2))\n        if key in memo:\n            return memo[key]\n        \n        # Calculate the number of fights\n        fights = 1\n        if s1[-1] > s2[-1]:\n            s1.pop()\n            s2.pop()\n        else:\n            s1.pop()\n        \n        # Recursively calculate the number of fights\n        fights += dfs(s1, s2)\n        \n        memo[key] = fights\n        return fights\n    \n    memo = {}\n    result = dfs(s1, s2)\n    \n    if result == 0:\n        print(-1)\n    else:\n        print(result, 2)\n\nif True:\n    solve()",
    "def solve(n, k1, k2, cards1, cards2):\n    import math\n    # Calculate the total number of possible states\n    total_states = math.factorial(n + 1)\n    \n    # Check if the game will end\n    if total_states <= 10**6:\n        return -1\n    \n    # Initialize variables\n    current_state = tuple(cards1 + cards2)\n    visited = set()\n    visited.add(current_state)\n    fights_count = 0\n    \n    # Perform the fights until we find a cycle\n    while True:\n        next_state = tuple(sorted([max(card1, card2) for card1, card2 in zip(cards1, cards2)]))\n        \n        if next_state in visited:\n            break\n        \n        visited.add(next_state)\n        fights_count += 1\n        cards1.append(min(card1, card2))\n        cards2.remove(max(card1, card2))\n    \n    # Determine the winner based on the number of fights\n    if fights_count % 2 == 0:\n        return fights_count // 2, 2\n    else:\n        return fights_count // 2 + 1, 1\n\n# Read input\nn = int(input())\nk1 = int(input())\ncards1 = list(map(int, input().split()))\nk2 = int(input())\ncards2 = list(map(int, input().split()))\n\n# Solve the problem\nresult = solve(n, k1, k2, cards1, cards2)\nprint(*result)",
    "def solve(n, k1, values1, k2, values2):\n    import itertools\n    from collections import defaultdict\n    \n    def generate_states():\n        for i in range(n + 1):\n            for perm in itertools.permutations(range(1, n + 1)):\n                yield tuple(perm[:i]) + tuple(values1) + tuple(perm[i:]) + tuple(values2)\n    \n    def get_state_hash(state):\n        return hash(tuple(sorted(state)))\n    \n    def check_cycle(states):\n        visited = defaultdict(int)\n        for state in states:\n            visited[get_state_hash(state)] += 1\n            if visited[get_state_hash(state)] > 1:\n                return True\n        return False\n    \n    states = list(generate_states())\n    if check_cycle(states):\n        print(-1)\n    else:\n        num_fights = len(states)\n        print(num_fights, 2)\n\nif True:\n    n = int(input())\n    k1 = int(input())\n    values1 = list(map(int, input().split()))\n    k2 = int(input())\n    values2 = list(map(int, input().split()))\n    solve(n, k1, values1, k2, values2)",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k1 = int(data[1])\n    s1 = list(map(int, data[2:k1+2]))\n    k2 = int(data[k1+2])\n    s2 = list(map(int, data[k1+3:]))\n\n    def dfs(i, j):\n        if i == j:\n            return 0\n        if (i, j) in memo:\n            return memo[(i, j)]\n        \n        if s1[i-1] > s2[j-1]:\n            result = dfs(i+1, j)\n        else:\n            result = max(dfs(i+1, j)+1, dfs(i, j+1)+1)\n\n        memo[(i, j)] = result\n        return result\n\n    memo = {}\n    result = dfs(1, n)\n    \n    if result == n:\n        print(n, 1)\n    elif result == n+1:\n        print(n, 2)\n    else:\n        print(-1)\n\nif True:\n    solve()",
    "def solve(n, k1, k2):\n    from collections import defaultdict\n    from math import factorial\n    \n    # Calculate the total number of states\n    total_states = factorial(n)\n    \n    # Create a dictionary to store the number of times each state occurs\n    state_count = defaultdict(int)\n    \n    # Iterate through all possible ways to split the deck into two parts\n    for i in range(1, n + 1):\n        # Calculate the number of ways to choose i cards for the first part\n        ways_to_choose_first_part = factorial(i) * factorial(n - i)\n        \n        # Calculate the number of ways to arrange the remaining cards\n        arrangements_of_remaining_cards = factorial(n - i)\n        \n        # Calculate the total number of states for this split\n        total_states_for_split = ways_to_choose_first_part * arrangements_of_remaining_cards\n        \n        # Update the state count for this split\n        state_count[total_states_for_split] += 1\n    \n    # Find the maximum number of states that occur more than once\n    max_state_count = max(state_count.values())\n    \n    # Print the result\n    if max_state_count > 1:\n        print(max_state_count, 1)\n    else:\n        print(-1)\n\n# Read input\nn = int(input().strip())\nk1 = int(input().strip())\ncards1 = list(map(int, input().strip().split()))\nk2 = int(input().strip())\ncards2 = list(map(int, input().strip().split()))\n\n# Solve the problem\nsolve(n, k1, k2)",
    "import sys\nfrom collections import defaultdict\n\ndef solve(n, k1, values1, k2, values2):\n    # Calculate the number of different states\n    total_states = factorial(n + 1)\n    \n    # Initialize a dictionary to store the number of times each state appears\n    state_counts = defaultdict(int)\n    \n    # Perform the game until we find a cycle or reach the maximum number of states\n    for i in range(total_states):\n        # Choose a random state to start the game\n        current_state = tuple(values1[i % k1]) + tuple(values2[i % k2])\n        \n        # Count the number of times this state has been seen\n        state_counts[current_state] += 1\n        \n        # Check if we have reached a cycle or exceeded the maximum number of states\n        if state_counts[current_state] > 1 or i == total_states - 1:\n            # Print the result based on the type of game outcome\n            if state_counts[current_state] > 1:\n                print(i // total_states, 1)\n            else:\n                print(i // total_states, 2)\n            break\n    \n    # If the game didn't end, print -1\n    else:\n        print(-1)\n\n# Read input from stdin\ninput_data = sys.stdin.read().strip()\ndata = input_data.split('\\n')\nn = int(data[0])\nk1 = int(data[1])\nvalues1 = list(map(int, data[2].split()))\nk2 = int(data[3])\nvalues2 = list(map(int, data[4].split()))\n\n# Call the solve function with the provided input\nsolve(n, k1, values1, k2, values2)",
    "def solve(n, k1, k2, cards1, cards2):\n    from collections import deque\n    from functools import lru_cache\n    \n    @lru_cache(None)\n    def dfs(state):\n        if len(cards1) == 0 or len(cards2) == 0:\n            return True\n        for i in range(k1):\n            if dfs((state[0], state[1] + (cards1[i] - state[0]) % n)):\n                return True\n        for i in range(k2):\n            if dfs((state[0] + (cards2[i] - state[0]) % n, state[1])):\n                return True\n        return False\n    \n    queue = deque([(0, 0)])\n    visited = set()\n    while queue:\n        state = queue.popleft()\n        if state in visited:\n            continue\n        visited.add(state)\n        if dfs(state):\n            return len(queue), 1\n        for i in range(k1):\n            new_state = (state[0], state[1] + (cards1[i] - state[0]) % n)\n            queue.append(new_state)\n        for i in range(k2):\n            new_state = (state[0] + (cards2[i] - state[0]) % n, state[1])\n            queue.append(new_state)\n    return -1\n\n# Read input\nn = int(input())\nk1 = int(input())\ncards1 = list(map(int, input().split()))\nk2 = int(input())\ncards2 = list(map(int, input().split()))\n\n# Solve the problem\nresult = solve(n, k1, k2, cards1, cards2)\nprint(*result)",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k1 = int(data[1])\n    cards1 = list(map(int, data[2:k1+2]))\n    k2 = int(data[2+k1])\n    cards2 = list(map(int, data[2+k1+2:]))\n\n    def dfs(state):\n        if len(cards1) == 0 or len(cards2) == 0:\n            return True\n        for i in range(len(cards1)):\n            for j in range(len(cards2)):\n                if cards1[i] > cards2[j]:\n                    cards1.pop(i)\n                    cards2.pop(j)\n                    if dfs((cards1, cards2)):\n                        return True\n                    cards1.insert(i, cards1.pop())\n                    cards2.insert(j, cards2.pop())\n        return False\n\n    if dfs((cards1, cards2)):\n        print(n * (n + 1) // 2, 2)\n    else:\n        print(-1)\n\nsolve()",
    "def solve(n, k1, values1, k2, values2):\n    from collections import defaultdict\n    \n    # Counting the number of distinct states\n    states = defaultdict(int)\n    states[0] = 1\n    \n    # Function to check if the game has ended\n    def is_game_over():\n        return sum(states.values()) > 10**6\n    \n    # Function to perform a single fight\n    def perform_fight(state):\n        i, j = 0, 0\n        while i < k1 and j < k2:\n            if values1[i] == values2[j]:\n                i += 1\n                j += 1\n            elif values1[i] > values2[j]:\n                state ^= (1 << i)\n                i += 1\n            else:\n                state ^= (1 << j)\n                j += 1\n        \n        if i < k1:\n            state ^= ((1 << i) << k2)\n        elif j < k2:\n            state ^= ((1 << j) << k1)\n        \n        return state\n    \n    # Main loop\n    state = 0\n    while True:\n        if is_game_over():\n            break\n        \n        state = perform_fight(state)\n        states[state] += 1\n    \n    # Determine the winner\n    if states[state] % 2 == 0:\n        print(0, 2)\n    else:\n        print(states[state], 1)\n\n# Reading input\nimport sys\ninput = sys.stdin.read\n\n# Parsing input\nn, k1, values1, k2, values2 = map(int, input().split())\nvalues1 = list(map(int, input().split()))\nvalues2 = list(map(int, input().split()))\n\n# Solving the problem\nsolve(n, k1, values1, k2, values2)",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n = data[0]\n    k1 = data[1]\n    s1 = data[2:k1+2]\n    k2 = data[k1+2]\n    s2 = data[k1+2+k2:]\n    \n    def dfs(s1, s2):\n        if not s1 or not s2:\n            return len(s1) + len(s2)\n        \n        if (s1, s2) in memo:\n            return memo[(s1, s2)]\n        \n        res = float('inf')\n        for i in range(len(s1)):\n            for j in range(len(s2)):\n                if s1[i] > s2[j]:\n                    res = min(res, dfs(s1[:i]+s1[i+1:], s2[:j]+s2[j+1:]) + 2)\n                else:\n                    res = min(res, dfs(s1[:i], s2[:j]) + 2)\n        \n        memo[(s1, s2)] = res\n        return res\n    \n    memo = {}\n    res = dfs(s1, s2)\n    if res == len(s1) + len(s2):\n        print(0, 1)\n    elif res < len(s1) + len(s2):\n        print(res, 2)\n    else:\n        print(-1)\n\nsolve()",
    "import sys\nfrom collections import defaultdict\n\ndef solve():\n    n = int(input())\n    deck1 = list(map(int, input().split()))\n    deck2 = list(map(int, input().split()))\n\n    def get_next_state(state):\n        i = state.index(min(deck1))\n        j = state.index(max(deck2))\n        new_state = state[:i] + state[i+1:j] + state[j+1:] + [deck1[i], deck2[j]]\n        return tuple(new_state)\n\n    visited = set()\n    queue = [(tuple(deck1), 0)]\n    while queue:\n        state, steps = queue.pop(0)\n        if state in visited:\n            continue\n        visited.add(state)\n        if min(deck1) > max(deck2):\n            print(steps + 1, 2)\n            return\n        if len(deck1) == 0 or len(deck2) == 0:\n            print(steps + 1, 1)\n            return\n        next_states = [get_next_state(state) for state in visited]\n        queue.extend([(state, steps + 1) for state in next_states])\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k1 = int(data[1])\n    k2 = n - k1\n    s1 = list(map(int, data[k1+1:k1+k2+1]))\n    s2 = list(map(int, data[k1+k2+1:]))\n\n    def get_state(s):\n        return tuple(sorted(s))\n\n    def dfs(state, visited):\n        visited.add(get_state(state))\n        for i in range(len(state)):\n            new_state = state[:i] + state[i+1:]\n            if get_state(new_state) not in visited:\n                dfs(new_state, visited)\n\n    visited = set()\n    dfs(s1, visited)\n    dfs(s2, visited)\n\n    if len(visited) == n * (n - 1):\n        print(n * (n - 1) // 2, 1)\n    else:\n        print(-1)\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n = data[0]\n    k1 = data[1]\n    s1 = data[2:k1+2]\n    k2 = data[k1+2:]\n    s2 = data[k1+2:]\n\n    # Calculate the number of different states\n    total_states = factorial(n)\n\n    # Check if the game will end with a cycle\n    for i in range(total_states):\n        # Simulate the game until it ends or cycles back to the same state\n        while True:\n            # Pick cards from both players' stacks\n            c1 = s1.pop(0)\n            c2 = s2.pop(0)\n            # Compare the card values\n            if c1 > c2:\n                # Add the cards to the winner's stack\n                s1.append(c1)\n                s1.append(c2)\n            elif c1 < c2:\n                # Add the cards to the winner's stack\n                s2.append(c2)\n                s2.append(c1)\n            else:\n                # Both players lose\n                break\n        # If the game ended, check if it was due to a cycle\n        if len(s1) == 0 or len(s2) == 0:\n            break\n\n    # Print the result\n    if len(s1) == 0:\n        print(f\"{total_states} 1\")\n    elif len(s2) == 0:\n        print(f\"{total_states} 2\")\n    else:\n        print(\"-1\")\n\nif True:\n    solve()",
    "def solve(n, k1, values1, k2, values2):\n    import sys\n    sys.setrecursionlimit(10**6)\n    \n    def dfs(state):\n        nonlocal count\n        if state == 0:\n            count += 1\n            return\n        visited.add(state)\n        for i in range(k1):\n            for j in range(i+1, k1):\n                new_state = (state | (values1[i] << (j-i)) | (values1[j] << (j-i)))\n                if new_state not in visited:\n                    dfs(new_state)\n        for i in range(k2):\n            for j in range(i+1, k2):\n                new_state = (state | (values2[i] << (j-i)) | (values2[j] << (j-i)))\n                if new_state not in visited:\n                    dfs(new_state)\n    \n    visited = set()\n    count = 0\n    dfs((1 << n) - 1)\n    print(count, 2 if count % 2 else 1)\n\nif True:\n    n = int(input())\n    k1 = int(input())\n    values1 = list(map(int, input().split()))\n    k2 = int(input())\n    values2 = list(map(int, input().split()))\n    solve(n, k1, values1, k2, values2)",
    "import sys\nfrom collections import defaultdict\n\ndef solve():\n    n = int(sys.stdin.readline())\n    s1 = list(map(int, sys.stdin.readline().split()))\n    s2 = list(map(int, sys.stdin.readline().split()))\n\n    def get_state(s):\n        return tuple(sorted(s))\n\n    def dfs(state, visited):\n        if state in visited:\n            return True\n        visited.add(state)\n        for i in range(n):\n            for j in range(i + 1, n):\n                new_s1 = s1[:i] + s1[i:j+1][::-1] + s1[j+1:]\n                new_s2 = s2[:j] + s2[j:i+1][::-1] + s2[i+1:]\n                if dfs(get_state(new_s1), visited) or dfs(get_state(new_s2), visited):\n                    return True\n        return False\n\n    visited = set()\n    if dfs(get_state(s1), visited):\n        print(len(visited) // 2, 1)\n    elif dfs(get_state(s2), visited):\n        print(len(visited) // 2, 2)\n    else:\n        print(-1)\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, k1, k2 = data[0], data[1], data[2]\n    deck1 = data[3:k1+3]\n    deck2 = data[k1+3:]\n    \n    def get_next_state(state):\n        i, j = 0, 0\n        while i < len(deck1) and j < len(deck2):\n            if deck1[i] > deck2[j]:\n                state.append((deck1[i], deck2[j]))\n                i += 1\n            else:\n                state.append((deck2[j], deck1[i]))\n                j += 1\n        while i < len(deck1):\n            state.append((deck1[i], None))\n            i += 1\n        while j < len(deck2):\n            state.append((None, deck2[j]))\n            j += 1\n        return state\n    \n    def check_cycle(state):\n        seen = set()\n        current = state[:]\n        while current not in seen:\n            seen.add(current)\n            current = get_next_state(current)\n        return len(seen) == len(state)\n    \n    def count_fights(n, k1, k2, deck1, deck2):\n        state = []\n        for _ in range(k1 + k2):\n            state.append(None)\n        \n        while True:\n            next_state = get_next_state(state)\n            if check_cycle(next_state):\n                break\n            state = next_state\n            \n            if len(state) >= n * 2:\n                return len(state), 2\n            elif len(state) >= n * 3:\n                return len(state), 1\n    \n    result = count_fights(n, k1, k2, deck1, deck2)\n    print(result)\n\nif True:\n    solve()",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n = data[0]\n    k1 = data[1]\n    cards1 = data[2:k1+2]\n    k2 = data[k1+2]\n    cards2 = data[k1+2:]\n    \n    def dfs(cards1, cards2):\n        if not cards1 or not cards2:\n            return len(cards1) + len(cards2)\n        \n        # Try all possible moves for the first soldier\n        max_fights = 0\n        for i in range(len(cards1)):\n            new_cards1 = cards1[:i] + cards1[i+1:]\n            new_cards2 = cards2 + [cards1[i]]\n            max_fights = max(max_fights, dfs(new_cards1, new_cards2))\n        \n        # Try all possible moves for the second soldier\n        for i in range(len(cards2)):\n            new_cards1 = cards1 + [cards2[i]]\n            new_cards2 = cards2[:i] + cards2[i+1:]\n            max_fights = max(max_fights, dfs(new_cards1, new_cards2))\n        \n        return max_fights\n    \n    max_fights = dfs(cards1, cards2)\n    print(max_fights % 2, max_fights // 2)\n\nif True:\n    solve()",
    "import sys\nfrom collections import defaultdict\n\ndef solve(n, k1, values1, k2, values2):\n    def dfs(state):\n        nonlocal visited, cycles\n        if state in visited:\n            cycles.append(visited[state])\n            return True\n        visited[state] = len(cycles)\n        for i in range(k1):\n            for j in range(i+1, k1):\n                if values1[i] < values1[j]:\n                    values1[i], values1[j] = values1[j], values1[i]\n                elif values1[i] > values1[j]:\n                    break\n        for i in range(k2):\n            for j in range(i+1, k2):\n                if values2[i] < values2[j]:\n                    values2[i], values2[j] = values2[j], values2[i]\n                elif values2[i] > values2[j]:\n                    break\n        for i in range(k1+k2):\n            for j in range(i+1, k1+k2):\n                if values1[i] < values2[j]:\n                    values1[i], values2[j] = values2[j], values1[i]\n                elif values1[i] > values2[j]:\n                    break\n        for i in range(k1+k2):\n            for j in range(i+1, k1+k2):\n                if values2[i] < values1[j]:\n                    values2[i], values1[j] = values1[j], values2[i]\n                elif values2[i] > values1[j]:\n                    break\n        for i in range(k1+k2):\n            for j in range(i+1, k1+k2):\n                if values1[i] == values2[j]:\n                    return True\n        for i in range(k1+k2):\n            for j in range(i+1, k1+k2):\n                if values1[i] != values2[j]:\n                    continue\n                if dfs((values1[:i]+values1[i+1:], values2[:j]+values2[j+1:])):\n                    return True\n        return False\n    \n    visited = defaultdict(int)\n    cycles = []\n    if dfs((values1, values2)):\n        return len(cycles), 1\n    else:\n        return -1\n\nif True:\n    input_data = sys.stdin.read().split()\n    n = int(input_data[0])\n    k1 = int(input_data[1])\n    values1 = list(map(int, input_data[2:k1+2]))\n    k2 = int(input_data[k1+2])\n    values2 = list(map(int, input_data[k1+3:k1+3+k2]))\n    result = solve(n, k1, values1, k2, values2)\n    print(*result)",
    "def solve(n, k1, k2):\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, k1, k2 = data[0], data[1], data[2]\n    \n    # Calculate total number of states\n    total_states = (n + 1) * factorial(n)\n    \n    # Check if the game will end\n    if total_states <= 1000000:\n        return -1\n    \n    # Initialize visited states\n    visited = set()\n    visited.add((k1, k2))\n    \n    # Initialize current state\n    current_state = (k1, k2)\n    \n    # Initialize fight counter\n    fight_count = 0\n    \n    # Play the game until we find a cycle or reach the maximum number of fights\n    while True:\n        fight_count += 1\n        \n        # Find the next state\n        next_state = (current_state[1], current_state[0])\n        \n        # If we've seen this state before, we have a cycle\n        if next_state in visited:\n            break\n        \n        # Add the new state to the visited set\n        visited.add(next_state)\n        \n        # Move to the next state\n        current_state = next_state\n    \n    # Print the result\n    if fight_count == total_states:\n        print(fight_count, 1)\n    else:\n        print(fight_count, 2)\n\nif True:\n    solve(4, 2, 3)\n    solve(3, 1, 2)",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k1 = int(data[1])\n    k2 = n - k1\n    \n    s1 = list(map(int, data[2:k1+2]))\n    s2 = list(map(int, data[k1+2:n+2]))\n    \n    def dfs(i, j):\n        if i == len(s1) or j == len(s2):\n            return 1\n        if (i, j) in memo:\n            return memo[(i, j)]\n        \n        memo[(i, j)] = max(dfs(i+1, j), dfs(i, j+1))\n        return memo[(i, j)]\n    \n    memo = {}\n    ans = dfs(0, 0)\n    \n    if ans == 1:\n        print(n*(n+1)//2)\n    elif ans == 2:\n        print(n*(n+1)//2 - 1)\n    else:\n        print(-1)\n\nif True:\n    solve()",
    "import sys\nfrom collections import deque\n\ndef solve(n, k1, k2):\n    cards1 = list(map(int, sys.stdin.readline().split()))\n    cards2 = list(map(int, sys.stdin.readline().split()))\n    \n    def get_next_state(state):\n        i = state.index(max(state))\n        next_state = state[:i] + state[i+1:]\n        return next_state\n    \n    queue = deque([(cards1, cards2)])\n    visited = set()\n    visited.add(tuple(cards1) + tuple(cards2))\n    current_state = (cards1, cards2)\n    \n    while True:\n        if current_state in visited:\n            break\n        \n        visited.add(current_state)\n        \n        next_state = get_next_state(current_state[0])\n        if next_state == current_state[1]:\n            print(len(visited) - 1, 2)\n            return\n        else:\n            queue.append((next_state, current_state[1]))\n            \n        next_state = get_next_state(current_state[1])\n        if next_state == current_state[0]:\n            print(len(visited) - 1, 1)\n            return\n        else:\n            queue.append((current_state[0], next_state))\n\nif True:\n    solve(*map(int, sys.stdin.readline().split()))",
    "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k1 = int(data[1])\n    cards1 = list(map(int, data[2:k1+2]))\n    k2 = int(data[2+k1])\n    cards2 = list(map(int, data[2+k1+2:]))\n\n    def dfs(state):\n        if state == (0, 0):\n            return 0\n        if state in memo:\n            return memo[state]\n        memo[state] = max(dfs((state[0]-cards1[-1], state[1]+cards1[-1]))+1, dfs((state[0], state[1]-cards2[-1]))+1)\n        return memo[state]\n\n    memo = {}\n    result = dfs((n-k1, n-k2))\n    if result == 0:\n        print(-1)\n    else:\n        print(result, 2)\n\nif True:\n    solve()"
  ],
  "rewards": [
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.34146341463414637,
    0.024390243902439025,
    0.024390243902439025,
    0.0,
    0.34146341463414637,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.024390243902439025,
    0.0,
    0.0,
    0.0,
    0.0,
    0.07317073170731707,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0975609756097561,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.34146341463414637,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0
  ],
  "train rewards": [
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.275,
    0.175,
    0.1,
    0.05,
    0.275,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.125,
    0.0,
    0.0,
    0.0,
    0.0,
    0.05,
    0.0,
    0.1,
    0.0,
    0.0,
    0.325,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.025,
    0.0,
    0.0,
    0.0,
    0.225,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0
  ],
  "time": 434.62597131729126,
  "sample times": 50
}