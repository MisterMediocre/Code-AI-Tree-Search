{
  "prompt": "\nQUESTION:\nAndrey thinks he is truly a successful developer, but in reality he didn't know about the binary search algorithm until recently. After reading some literature Andrey understood that this algorithm allows to quickly find a certain number $x$ in an array. For an array $a$ indexed from zero, and an integer $x$ the pseudocode of the algorithm is as follows:\n\nBinarySearch(a, x)\n  left = 0\n  right = a.size()\n  while left < right\n    middle = (left + right) / 2\n    if a[middle] <= x then\n      left = middle + 1\n    else\n      right = middle\n  \n  if left > 0 and a[left - 1] == x then\n    return true\n  else\n    return false\n\nNote that the elements of the array are indexed from zero, and the division is done in integers (rounding down).\n\nAndrey read that the algorithm only works if the array is sorted. However, he found this statement untrue, because there certainly exist unsorted arrays for which the algorithm find $x$!\n\nAndrey wants to write a letter to the book authors, but before doing that he must consider the permutations of size $n$ such that the algorithm finds $x$ in them. A permutation of size $n$ is an array consisting of $n$ distinct integers between $1$ and $n$ in arbitrary order.\n\nHelp Andrey and find the number of permutations of size $n$ which contain $x$ at position $pos$ and for which the given implementation of the binary search algorithm finds $x$ (returns true). As the result may be extremely large, print the remainder of its division by $10^9+7$.\n\n\n-----Input-----\n\nThe only line of input contains integers $n$, $x$ and $pos$ ($1 \\le x \\le n \\le 1000$, $0 \\le pos \\le n - 1$) \u2014 the required length of the permutation, the number to search, and the required position of that number, respectively.\n\n\n-----Output-----\n\nPrint a single number\u00a0\u2014 the remainder of the division of the number of valid permutations by $10^9+7$.\n\n\n-----Examples-----\nInput\n4 1 2\n\nOutput\n6\n\nInput\n123 42 24\n\nOutput\n824071958\n\n\n\n-----Note-----\n\nAll possible permutations in the first test case: $(2, 3, 1, 4)$, $(2, 4, 1, 3)$, $(3, 2, 1, 4)$, $(3, 4, 1, 2)$, $(4, 2, 1, 3)$, $(4, 3, 1, 2)$.\n\nTUTORIAL:\nLet's simulate a binary search algorithm. Initially, we have the required position pos. For the next middle position in the binary search, we can determine exactly whether the next number at this position should be greater or less than x. For all other positions, the values can be either greater or less than x. As a result of the simulation of the algorithm, we have cntBig positions at which numbers must be greater than x and cntLess positions at which numbers must be less than x. Let the large numbers be hasBig, and the smaller ones hasLess. Now let's count the number of ways to place large numbers in cntBig positions using the formula C(hasBig, cntBig) \u00b7 cntBig!.\n\nLet's calculate in a similar way for smaller numbers, and the product of the resulting results will be the answer to the problem.\n\n\nInstructions:\n\n\nYou are a Python3 code generator.  Output **only** valid Python code. No explanations, no commentary, no filenames, no Markdown formatting. You will spit out a code block that can be pasted into any script. It must read the input, execute the logic and then print the output. Ensure that you invoke the main() or solve() function at the end if you're writing your code inside them.\nANSWER:\n",
  "codes": [
    "def bin_search_permutations(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of ways to place large numbers\n    big_count = min(pos, n - pos)\n    big_ways = binomial(big_count, big_count) % mod\n    \n    # Calculate the number of ways to place small numbers\n    small_count = max(pos, n - pos)\n    small_ways = binomial(small_count, small_count) % mod\n    \n    # Calculate the total number of valid permutations\n    total_ways = (big_ways * small_ways) % mod\n    \n    return total_ways\n\n# Helper function to calculate binomial coefficient\ndef binomial(n, k):\n    if k > n // 2:\n        k = n - k\n    res = 1\n    for i in range(k):\n        res = (res * (n - i)) % mod\n        res = (res * pow(i + 1, mod - 2, mod)) % mod\n    return res\n\n# Main function to handle the input and call the helper function\ndef main():\n    n, x, pos = map(int, input().split())\n    result = bin_search_permutations(n, x, pos)\n    print(result)\n\nif True:\n    main()",
    "def bin_search_permutations(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of ways to choose cntBig positions from hasBig\n    cntBig = min(pos, n - pos - 1)\n    hasBig = n - cntBig - 1\n    ways_big = comb(hasBig, cntBig) * cntBig % MOD\n    \n    # Calculate the number of ways to choose cntLess positions from hasLess\n    cntLess = max(pos, n - pos - 1)\n    hasLess = n - cntLess - 1\n    ways_less = comb(hasLess, cntLess) * cntLess % MOD\n    \n    # The total number of permutations is the product of the two results\n    result = ways_big * ways_less % MOD\n    \n    return result\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Print the result\nprint(bin_search_permutations(n, x, pos))",
    "def bin_search_permutations(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of ways to choose positions where x can be greater than or equal to x\n    cntBig = pos + 1\n    hasBig = n - cntBig\n    \n    # Calculate the number of ways to choose positions where x can be less than x\n    cntLess = n - pos - 1\n    hasLess = cntBig\n    \n    # Calculate the number of ways to choose positions where x can be greater than x\n    C_big = math.comb(hasBig, cntBig)\n    \n    # Calculate the number of ways to choose positions where x can be less than x\n    C_less = math.comb(hasLess, cntLess)\n    \n    # Calculate the total number of valid permutations\n    total_permutations = (C_big * cntBig) % MOD * (C_less * cntLess) % MOD\n    \n    return total_permutations\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Print the result\nprint(bin_search_permutations(n, x, pos))",
    "def bin_search_permutations(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    cntBig = n - pos - 1\n    hasBig = min(x, n - x)\n    \n    # Calculate the number of ways to place small numbers in cntLess positions\n    cntLess = pos\n    hasLess = min(x, n - x)\n    \n    # Calculate the number of valid permutations\n    ans = (comb(hasBig, cntBig) * comb(hasLess, cntLess)) % mod\n    \n    return ans\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n, x, pos = int(data[0]), int(data[1]), int(data[2])\n    print(bin_search_permutations(n, x, pos))\n\n\nif True:\n    main()",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    hasBig = hasLess = cntBig = cntLess = 0\n    \n    # Count the occurrences of x in the array\n    for i in range(n):\n        if i != pos and arr[i] == x:\n            hasBig += 1\n        elif i != pos and arr[i] > x:\n            hasLess += 1\n        elif i != pos and arr[i] < x:\n            cntBig += 1\n        elif i != pos:\n            cntLess += 1\n            \n    # Calculate the number of ways to place large numbers\n    waysBig = math.comb(hasBig, cntBig) * cntBig % MOD\n    waysLess = math.comb(hasLess, cntLess) * cntLess % MOD\n    \n    # The total number of valid permutations\n    result = (waysBig * waysLess) % MOD\n    \n    return result\n\nif True:\n    n, x, pos = map(int, input().split())\n    arr = list(map(int, input().split()))\n    \n    print(solve(n, x, pos))",
    "from math import comb\n\ndef solve(n, x, pos):\n    # Calculate the number of larger numbers\n    cntBig = pos + 1\n    hasBig = n - pos - 1\n    \n    # Calculate the number of smaller numbers\n    cntLess = n - pos - 1\n    hasLess = pos\n    \n    # Calculate the number of ways to place larger numbers\n    res = comb(hasBig, cntBig) * cntBig\n    \n    # Calculate the number of ways to place smaller numbers\n    res *= comb(hasLess, cntLess) * cntLess\n    \n    # Return the result modulo 10^9 + 7\n    return res % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nprint(solve(n, x, pos))",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    cntBig = pos + 1\n    hasBig = cntBig * (cntBig - 1) // 2\n    \n    # Calculate the number of ways to place small numbers in cntLess positions\n    cntLess = n - pos - 1\n    hasLess = cntLess * (cntLess - 1) // 2\n    \n    # Calculate the number of ways to choose cntBig large numbers from hasBig possibilities\n    waysToChooseBig = comb(hasBig, cntBig)\n    \n    # Calculate the number of ways to choose cntLess small numbers from hasLess possibilities\n    waysToChooseLess = comb(hasLess, cntLess)\n    \n    # Calculate the total number of valid permutations\n    totalPermutations = (waysToChooseBig * waysToChooseLess) % MOD\n    \n    return totalPermutations\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of ways to choose positions for larger numbers\n    hasBig = n - pos - 1\n    cntBig = min(hasBig, x)\n    ansBig = pow(2, cntBig, MOD)\n    \n    # Calculate the number of ways to choose positions for smaller numbers\n    hasLess = pos\n    cntLess = min(hasLess, n - x - 1)\n    ansLess = pow(2, cntLess, MOD)\n    \n    # Calculate the total number of permutations with the given constraints\n    ans = (ansBig * ansLess) % MOD\n    \n    return ans\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Print the result\nprint(solve(n, x, pos))",
    "from math import comb\n\ndef solve(n, x, pos):\n    # Calculate the number of positions where the next number must be greater than x\n    cntBig = pos + 1\n    # Calculate the number of positions where the next number must be less than x\n    cntLess = n - pos - 1\n    \n    # Calculate the number of ways to choose cntBig positions from hasBig\n    hasBig = n - cntLess\n    ansBig = comb(hasBig, cntBig)\n    \n    # Calculate the number of ways to choose cntLess positions from hasLess\n    hasLess = n - cntBig\n    ansLess = comb(hasLess, cntLess)\n    \n    # The total number of permutations is the product of the two results\n    ans = ansBig * ansLess\n    \n    # Return the remainder of the division by 10^9+7\n    return ans % (10**9 + 7)\n\n# Read the input\nn, x, pos = map(int, input().split())\n\n# Solve the problem and print the result\nprint(solve(n, x, pos))",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    hasBig = 0\n    hasLess = 0\n    \n    # Count the number of larger and smaller numbers than x\n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    # Calculate the number of valid permutations\n    cntBig = hasBig // 2\n    cntLess = hasLess // 2\n    bigComb = math.comb(hasBig, cntBig) * cntBig % MOD\n    lessComb = math.comb(hasLess, cntLess) * cntLess % MOD\n    \n    # Multiply the combinations to get the final answer\n    ans = bigComb * lessComb % MOD\n    return ans\n\n# Main function to handle multiple inputs\ndef main():\n    while True:\n        try:\n            n, x, pos = map(int, input().split())\n            result = solve(n, x, pos)\n            print(result)\n        except EOFError:\n            break\n\nif True:\n    main()",
    "def bin_search_permutations(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of ways to place larger numbers in cntBig positions\n    hasBig = x - pos\n    cntBig = hasBig // 2\n    if hasBig % 2 != 0:\n        cntBig += 1\n    ways_big = comb(hasBig, cntBig) * cntBig % MOD\n    \n    # Calculate the number of ways to place smaller numbers in cntLess positions\n    hasLess = n - x - pos\n    cntLess = hasLess // 2\n    if hasLess % 2 != 0:\n        cntLess += 1\n    ways_less = comb(hasLess, cntLess) * cntLess % MOD\n    \n    # The total number of permutations is the product of the two results\n    result = (ways_big * ways_less) % MOD\n    \n    return result\n\n# Main function to handle input and call the binary search permutation function\ndef main():\n    n, x, pos = map(int, input().split())\n    result = bin_search_permutations(n, x, pos)\n    print(result)\n\nif True:\n    main()",
    "def bin_search_permutations(n, x, pos):\n    mod = 10**9 + 7\n    # Calculate the number of larger numbers\n    cntBig = n - pos - 1\n    # Calculate the number of smaller numbers\n    cntLess = pos\n    \n    # Calculate combinations for larger numbers\n    hasBig = comb(cntBig, cntBig % mod)\n    \n    # Calculate combinations for smaller numbers\n    hasLess = comb(cntLess, cntLess % mod)\n    \n    # The total number of permutations is the product of the combinations\n    result = (hasBig * hasLess) % mod\n    \n    return result\n\n\n# Main function to handle input and call the binary search permutation function\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, x, pos = data\n    result = bin_search_permutations(n, x, pos)\n    print(result)\n\n\nif True:\n    main()",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    big = 0\n    small = 0\n    for i in range(1, n + 1):\n        if i == x:\n            continue\n        if i < x:\n            small += 1\n        else:\n            big += 1\n    \n    bigC = [1]\n    smallC = [1]\n    for i in range(1, big + 1):\n        bigC.append((bigC[-1] * (i + big)) % MOD)\n    \n    for i in range(1, small + 1):\n        smallC.append((smallC[-1] * (i + small)) % MOD)\n    \n    ans = 0\n    for i in range(big + 1):\n        ans = (ans + (bigC[i] * smallC[big - i]) % MOD) % MOD\n    \n    print(ans)\n\nif True:\n    n, x, pos = map(int, input().split())\n    solve(n, x, pos)",
    "def bin_search_permutations(n, x, pos):\n    # Calculate the number of permutations where x is placed at pos\n    # The number of ways to choose cntBig positions out of n-1 for larger numbers\n    # The number of ways to choose cntLess positions out of n-1 for smaller numbers\n    # The total number of permutations is the product of these two combinations\n    # We use comb() from math module to calculate combinations\n    import math\n    cntBig = n - pos - 1\n    cntLess = pos\n    hasBig = math.comb(cntBig, cntBig)\n    hasLess = math.comb(cntLess, cntLess)\n    return (hasBig * hasLess) % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Print the result\nprint(bin_search_permutations(n, x, pos))",
    "def bin_search_permutations(n, x, pos):\n    # Calculate the number of permutations where x is at pos\n    if pos == 0:\n        return n * (n - 1) // 2 % (10**9 + 7)\n    elif pos == n - 1:\n        return n * (n - 1) // 2 % (10**9 + 7)\n    else:\n        # Calculate the number of permutations where x is not at pos\n        has_big = pos + 1\n        has_less = n - pos - 1\n        return binomial_coefficient(has_big, pos) * binomial_coefficient(has_less, n - pos - 1) % (10**9 + 7)\n\ndef binomial_coefficient(n, k):\n    if k > n // 2:\n        k = n - k\n    result = 1\n    for i in range(1, k + 1):\n        result *= (n - i + 1) // i\n    return result % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Print the result\nprint(bin_search_permutations(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    big = 0\n    small = 0\n    for i in range(1, n + 1):\n        if i > x:\n            big += 1\n        elif i < x:\n            small += 1\n    \n    big_comb = comb(big, pos)\n    small_comb = comb(small, n - pos - 1)\n    \n    return (big_comb * small_comb) % mod\n\ndef comb(n, k):\n    if k > n // 2:\n        k = n - k\n    res = 1\n    for i in range(1, k + 1):\n        res *= (n - i + 1) // i\n    return res\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "def bin_search_permutations(n, x, pos):\n    mod = 10**9 + 7\n    # Calculate the number of larger and smaller elements than x\n    hasBig = n - pos - 1\n    hasLess = pos\n    \n    # Calculate combinations with repetition for larger elements\n    big_combinations = comb(hasBig, hasBig)\n    \n    # Calculate combinations with repetition for smaller elements\n    less_combinations = comb(hasLess, hasLess)\n    \n    # Calculate the total number of permutations\n    total_permutations = big_combinations * less_combinations % mod\n    \n    return total_permutations\n\ndef comb(n, k):\n    if k > n // 2:\n        k = n - k\n    res = 1\n    for i in range(1, k + 1):\n        res *= (n - k + i)\n        res //= i\n    return res\n\n# Main function to handle input and output\ndef main():\n    n, x, pos = map(int, input().split())\n    result = bin_search_permutations(n, x, pos)\n    print(result)\n\nif True:\n    main()",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    big = [i for i in range(1, n + 1) if i >= x]\n    small = [i for i in range(1, n + 1) if i < x]\n\n    def binomial_coefficient(n, k):\n        if k > n // 2:\n            k = n - k\n        res = 1\n        for i in range(k):\n            res = (res * (n - i)) % MOD\n            res = (res * pow(i + 1, MOD - 2, MOD)) % MOD\n        return res\n\n    big_count = len(big)\n    small_count = len(small)\n\n    big_combinations = binomial_coefficient(big_count, big_count - pos)\n    small_combinations = binomial_coefficient(small_count, pos)\n\n    total_permutations = (big_combinations * small_combinations) % MOD\n\n    return total_permutations\n\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "from math import comb\n\ndef solve(n, x, pos):\n    # Calculate the number of larger and smaller numbers\n    cntBig = sum(1 for i in range(pos + 1, n) if i > x)\n    cntLess = sum(1 for i in range(pos + 1, n) if i < x)\n    \n    # Calculate the number of ways to choose positions for larger numbers\n    hasBig = comb(cntBig, pos + 1)\n    \n    # Calculate the number of ways to choose positions for smaller numbers\n    hasLess = comb(cntLess, pos + 1)\n    \n    # The total number of valid permutations is the product of the two counts\n    result = hasBig * hasLess\n    \n    # Print the result modulo 10^9 + 7\n    print(result % (10**9 + 7))\n\n# Main function to handle input and call the solve function\ndef main():\n    n, x, pos = map(int, input().split())\n    solve(n, x, pos)\n\nif True:\n    main()",
    "from math import comb\nMOD = 10**9 + 7\n\ndef solve(n, x, pos):\n    hasBig = 0\n    hasLess = 0\n    for i in range(1, n + 1):\n        if i < pos:\n            hasLess += 1\n        elif i > pos:\n            hasBig += 1\n    \n    ans = comb(hasBig, x - pos) * comb(hasLess, n - x - pos)\n    return ans % MOD\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nprint(solve(n, x, pos))",
    "from math import comb\n\ndef solve(n, x, pos):\n    hasBig = 0\n    hasLess = 0\n    \n    # Count the number of larger and smaller numbers than x\n    for i in range(1, n + 1):\n        if i < x:\n            hasLess += 1\n        elif i > x:\n            hasBig += 1\n            \n    # Calculate the number of valid permutations\n    cntBig = hasBig - pos\n    cntLess = pos\n    \n    # Calculate the combinations for both cases\n    res = comb(hasBig, cntBig) * comb(hasLess, cntLess)\n    \n    # Return the result modulo 10^9 + 7\n    return res % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nprint(solve(n, x, pos))",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Count the number of larger and smaller elements\n    cntBig = 0\n    cntLess = 0\n    for i in range(n):\n        if i == pos:\n            continue\n        if a[i] > x:\n            cntBig += 1\n        elif a[i] < x:\n            cntLess += 1\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    hasBig = cntBig\n    cntBig = min(cntBig, pos)\n    resBig = comb(hasBig, cntBig) * cntBig % MOD\n    \n    # Calculate the number of ways to place small numbers in cntLess positions\n    hasLess = cntLess\n    cntLess = min(cntLess, n - pos - 1)\n    resLess = comb(hasLess, cntLess) * cntLess % MOD\n    \n    # The final result is the product of the two results\n    return resBig * resLess % MOD\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Call the solve function\nprint(solve(n, x, pos))",
    "def bin_search_permutations(n, x, pos):\n    # Initialize variables\n    cnt_big = 0\n    cnt_less = 0\n    \n    # Count the number of positions where the current number is larger than x\n    for i in range(pos + 1, n):\n        if i > x:\n            cnt_big += 1\n    \n    # Count the number of positions where the current number is smaller than x\n    for i in range(pos):\n        if i < x:\n            cnt_less += 1\n    \n    # Calculate the number of ways to place large numbers in cnt_big positions\n    has_big = cnt_big + 1\n    cnt_big_fact = math.factorial(cnt_big)\n    \n    # Calculate the number of ways to place small numbers in cnt_less positions\n    has_less = cnt_less + 1\n    cnt_less_fact = math.factorial(cnt_less)\n    \n    # Calculate the total number of valid permutations\n    total_permutations = (has_big * cnt_big_fact) % (10**9 + 7) * (has_less * cnt_less_fact) % (10**9 + 7)\n    \n    # Print the result\n    print(total_permutations)\n\n# Main function\nif True:\n    # Read input\n    n, x, pos = map(int, input().split())\n    \n    # Call the function with the input parameters\n    bin_search_permutations(n, x, pos)",
    "from math import comb\n\ndef solve(n, x, pos):\n    # Initialize counts for larger and smaller numbers\n    cntBig = 0\n    cntLess = 0\n    \n    # Count the number of larger and smaller numbers in the range [1, n]\n    for i in range(1, n + 1):\n        if i > x:\n            cntBig += 1\n        elif i < x:\n            cntLess += 1\n    \n    # Calculate the number of ways to place larger numbers\n    waysBig = comb(cntBig, pos)\n    \n    # Calculate the number of ways to place smaller numbers\n    waysLess = comb(cntLess, n - pos - 1)\n    \n    # Return the total number of valid permutations modulo 10^9 + 7\n    return (waysBig * waysLess) % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of larger and smaller elements\n    hasBig = n - pos - 1\n    hasLess = pos\n    \n    # Calculate the combinations of larger and smaller elements\n    combBig = math.comb(hasBig, hasBig)\n    combLess = math.comb(hasLess, hasLess)\n    \n    # Calculate the final result\n    result = combBig * combLess % MOD\n    \n    return result\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def bin_search_permutations(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    hasBig = n - pos\n    cntBig = hasBig // 2\n    hasBig -= cntBig\n    cntBig += 1\n    \n    # Calculate the number of ways to place small numbers in cntLess positions\n    hasLess = pos + 1\n    cntLess = hasLess // 2\n    hasLess -= cntLess\n    cntLess += 1\n    \n    # Calculate the number of ways to choose cntBig large numbers from hasBig\n    C_hasBig_cntBig = comb(hasBig, cntBig)\n    \n    # Calculate the number of ways to choose cntLess small numbers from hasLess\n    C_hasLess_cntLess = comb(hasLess, cntLess)\n    \n    # Calculate the total number of valid permutations\n    total_permutations = C_hasBig_cntBig * C_hasLess_cntLess\n    \n    # Return the remainder of the division of the total number of valid permutations by mod\n    return total_permutations % mod\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    x = int(data[1])\n    pos = int(data[2])\n    print(bin_search_permutations(n, x, pos))\n\nif True:\n    main()",
    "def bin_search_permutations(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of larger and smaller numbers\n    has_big = sum(i > x for i in range(1, n + 1))\n    has_less = n - has_big\n    \n    # Calculate the number of ways to choose positions for larger and smaller numbers\n    cnt_big = has_big // 2 + has_big % 2\n    cnt_less = has_less // 2 + has_less % 2\n    \n    # Calculate the number of permutations with the given constraints\n    ans = (comb(has_big, cnt_big) * comb(has_less, cnt_less)) % MOD\n    \n    return ans\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    \n    n, x, pos = data\n    print(bin_search_permutations(n, x, pos))\n\n\nif True:\n    main()",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    hasBig = 0\n    hasLess = 0\n    \n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    if pos >= hasLess:\n        return 0\n    \n    cntBig = pos + 1\n    cntLess = n - pos\n    \n    hasBig -= min(cntBig, hasLess)\n    hasLess -= max(cntLess, hasBig)\n    \n    return (comb(hasBig, cntBig) * comb(hasLess, cntLess)) % mod\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, x, pos = data[0], data[1], data[2]\n    print(solve(n, x, pos))\n\nif True:\n    main()",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    big = 0\n    small = 0\n    for i in range(1, n + 1):\n        if i <= pos:\n            if i <= x:\n                big += 1\n            else:\n                small += 1\n        else:\n            if i <= x:\n                small += 1\n            else:\n                big += 1\n    \n    def binomial_coefficient(n, k):\n        if k > n // 2:\n            k = n - k\n        res = 1\n        for i in range(k):\n            res *= (n - i)\n            res //= (i + 1)\n        return res % mod\n    \n    big_combinations = binomial_coefficient(big, pos)\n    small_combinations = binomial_coefficient(small, n - pos - 1)\n    \n    return (big_combinations * small_combinations) % mod\n\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    hasBig = hasLess = 0\n    \n    # Count the number of larger and smaller elements than x\n    for i in range(1, n + 1):\n        if i < x:\n            hasLess += 1\n        elif i > x:\n            hasBig += 1\n    \n    # Calculate the number of ways to place large numbers\n    cntBig = hasBig\n    cntLess = hasLess\n    ans = 1\n    \n    for i in range(cntBig):\n        ans *= (hasBig - i)\n        ans %= mod\n    \n    for i in range(cntLess):\n        ans *= (hasLess - i)\n        ans %= mod\n    \n    return ans\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Print the output\nprint(solve(n, x, pos))",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of larger and smaller numbers\n    hasBig = sum(i > x for i in range(1, n + 1))\n    hasLess = sum(i < x for i in range(1, n + 1))\n    \n    # Calculate the number of ways to choose positions for larger and smaller numbers\n    cntBig = hasBig - pos\n    cntLess = hasLess - pos\n    \n    # Calculate the number of valid permutations\n    result = (comb(hasBig, cntBig) * comb(hasLess, cntLess)) % MOD\n    \n    return result\n\n# Main function to handle input and call the solve function\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, x, pos = data\n    print(solve(n, x, pos))\n\nif True:\n    main()",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of larger and smaller elements\n    hasBig = n - pos - 1\n    hasLess = pos\n    \n    # Calculate the combinations for larger and smaller elements\n    combBig = math.comb(hasBig, pos)\n    combLess = math.comb(hasLess, n - pos - 1)\n    \n    # Calculate the final result\n    result = combBig * combLess % mod\n    \n    return result\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    big = 0\n    small = 0\n    for i in range(1, n + 1):\n        if i < x:\n            small += 1\n        elif i > x:\n            big += 1\n    \n    def binomial_coefficient(n, k):\n        if k > n // 2:\n            k = n - k\n        res = 1\n        for i in range(k):\n            res *= (n - i)\n            res //= (i + 1)\n        return res\n    \n    ans = binomial_coefficient(big, pos) * binomial_coefficient(small, n - pos - 1)\n    return ans % mod\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of ways to choose positions where x is greater than the current element\n    cntBig = pos\n    hasBig = cntBig * (cntBig + 1) // 2 % mod\n    \n    # Calculate the number of ways to choose positions where x is less than the current element\n    cntLess = n - pos - 1\n    hasLess = cntLess * (cntLess + 1) // 2 % mod\n    \n    # Calculate the total number of valid permutations\n    ans = (hasBig * hasLess) % mod\n    \n    return ans\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "from math import comb\n\ndef solve(n, x, pos):\n    # Initialize counts for large and small numbers\n    hasBig, hasLess = 0, 0\n    \n    # Count how many numbers are larger than x\n    for i in range(pos):\n        if i + 1 > x:\n            hasBig += 1\n        else:\n            hasLess += 1\n            \n    # Count how many numbers are smaller than x\n    for i in range(pos + 1, n):\n        if i + 1 < x:\n            hasBig += 1\n        else:\n            hasLess += 1\n            \n    # Calculate the number of ways to choose positions for large numbers\n    waysBig = comb(hasBig, n - pos)\n    \n    # Calculate the number of ways to choose positions for small numbers\n    waysLess = comb(hasLess, pos)\n    \n    # Calculate the total number of valid permutations\n    total_permutations = waysBig * waysLess\n    \n    # Return the result modulo 10^9 + 7\n    return total_permutations % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    hasBig = 0\n    hasLess = 0\n    \n    # Count the number of large numbers and small numbers\n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n    \n    # Calculate the number of ways to place large numbers and small numbers\n    cntBig = hasBig // 2\n    cntLess = hasLess // 2\n    \n    # Calculate the number of valid permutations\n    ans = pow(cntBig + 1, cntBig, mod) * pow(cntLess + 1, cntLess, mod)\n    \n    # Return the result modulo 10^9 + 7\n    return ans % mod\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "from math import comb\nMOD = 10**9 + 7\n\ndef solve(n, x, pos):\n    hasBig = 0\n    hasLess = 0\n    \n    for i in range(pos):\n        if i < n and i != pos and a[i] >= x:\n            hasBig += 1\n        elif i < n and i != pos and a[i] < x:\n            hasLess += 1\n            \n    for i in range(n, pos, -1):\n        if i < n and i != pos and a[i] >= x:\n            hasLess += 1\n        elif i < n and i != pos and a[i] < x:\n            hasBig += 1\n            \n    return (comb(hasBig, n-pos) * comb(hasLess, pos)) % MOD\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Initialize array with numbers from 1 to n\na = list(range(1, n+1))\n\n# Solve the problem\nprint(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    cntBig = pos\n    hasBig = n - cntBig\n    cntSmall = n - pos - 1\n    hasLess = cntSmall\n    \n    # Calculate the binomial coefficient C(hasBig, cntBig)\n    binom = 1\n    for i in range(1, cntBig + 1):\n        binom = (binom * (hasBig - i + 1)) % mod\n    \n    # Calculate the binomial coefficient C(hasLess, cntSmall)\n    binom_small = 1\n    for i in range(1, cntSmall + 1):\n        binom_small = (binom_small * (hasLess - i + 1)) % mod\n    \n    # The total number of permutations is the product of the two binomial coefficients\n    result = (binom * binom_small) % mod\n    \n    return result\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nprint(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    cntBig = 0\n    cntLess = 0\n    \n    for i in range(n):\n        if i < pos:\n            cntLess += 1\n        elif i > pos:\n            cntBig += 1\n    \n    hasBig = cntBig * (cntBig + 1) // 2 % mod\n    hasLess = cntLess * (cntLess + 1) // 2 % mod\n    \n    ans = (hasBig * hasLess) % mod\n    return ans\n\n# Main function\nif True:\n    n, x, pos = map(int, input().split())\n    result = solve(n, x, pos)\n    print(result)",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of ways to choose cntBig positions from hasBig\n    def binomial_coefficient(n, k):\n        return math.comb(n, k)\n    \n    hasBig = n - x + 1\n    hasLess = x\n    cntBig = hasBig - pos\n    cntLess = pos\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    ways_big = binomial_coefficient(hasBig, cntBig)\n    \n    # Calculate the number of ways to place small numbers in cntLess positions\n    ways_less = binomial_coefficient(hasLess, cntLess)\n    \n    # The total number of valid permutations\n    total_permutations = (ways_big * ways_less) % MOD\n    \n    return total_permutations\n\n# Read input\ninput_line = sys.stdin.readline().strip()\nn, x, pos = map(int, input_line.split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "from math import comb\n\ndef solve(n, x, pos):\n    cntBig = cntLess = 0\n    for i in range(n):\n        if i == pos:\n            continue\n        if a[i] > x:\n            cntBig += 1\n        else:\n            cntLess += 1\n    \n    hasBig = comb(cntBig, cntBig)\n    hasLess = comb(cntLess, cntLess)\n    \n    return hasBig * hasLess % (10**9 + 7)\n\nif True:\n    n, x, pos = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(solve(n, x, pos))",
    "from math import comb\n\ndef solve(n, x, pos):\n    # Calculate the number of larger and smaller elements\n    hasBig = n - pos - 1\n    hasLess = pos\n    \n    # Calculate the number of ways to choose the positions for larger elements\n    cntBig = comb(hasBig, hasBig)\n    \n    # Calculate the number of ways to choose the positions for smaller elements\n    cntLess = comb(hasLess, hasLess)\n    \n    # Calculate the total number of permutations\n    total_permutations = cntBig * cntLess\n    \n    # Return the result modulo 10^9 + 7\n    return total_permutations % (10**9 + 7)\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    hasBig = 0\n    hasLess = 0\n    \n    for i in range(1, n + 1):\n        if i > x:\n            hasBig += 1\n        elif i < x:\n            hasLess += 1\n            \n    cntBig = hasBig // 2\n    cntLess = hasLess // 2\n    \n    if hasBig % 2 != 0:\n        cntBig += 1\n        \n    if hasLess % 2 != 0:\n        cntLess += 1\n    \n    ans = pow(2, cntBig, mod) * pow(2, cntLess, mod)\n    \n    return ans % mod\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of positions where x can be placed\n    cntBig = n - pos - 1\n    cntLess = pos\n    \n    # Calculate the binomial coefficients\n    def binom(x, y):\n        if x < y:\n            return binom(y, x)\n        \n        res = 1\n        for i in range(1, y + 1):\n            res *= (x - i + 1) // i\n            res %= mod\n        \n        return res\n    \n    # Calculate the number of valid permutations\n    ans = binom(cntBig, cntBig) * binom(cntLess, cntLess)\n    ans %= mod\n    \n    return ans\n\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nprint(solve(n, x, pos))",
    "def solve(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of larger numbers\n    hasBig = min(x - 1, n - pos)\n    \n    # Calculate the number of smaller numbers\n    hasLess = min(pos, n - x)\n    \n    # Calculate the number of ways to choose the larger numbers\n    cntBig = comb(hasBig, hasBig)\n    \n    # Calculate the number of ways to choose the smaller numbers\n    cntLess = comb(hasLess, hasLess)\n    \n    # Calculate the total number of valid permutations\n    ans = (cntBig * cntLess) % MOD\n    \n    return ans\n\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    hasBig = 0\n    hasLess = 0\n    \n    # Count the number of larger and smaller numbers\n    for i in range(n):\n        if i != pos:\n            if a[i] > x:\n                hasBig += 1\n            else:\n                hasLess += 1\n                \n    # Calculate the number of ways to place large and small numbers\n    cntBig = math.comb(hasBig, pos)\n    cntLess = math.comb(hasLess, n-pos-1)\n    \n    # Calculate the final answer\n    ans = cntBig * cntLess % mod\n    return ans\n\n# Read input\ninput_data = input().split()\nn = int(input_data[0])\nx = int(input_data[1])\npos = int(input_data[2])\n\n# Call the solve function and print the output\nprint(solve(n, x, pos))",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    \n    # Calculate the number of ways to choose cntBig positions from hasBig numbers\n    cntBig = min(pos, n - pos)\n    hasBig = n - cntBig\n    cntBig_fact = math.factorial(cntBig)\n    hasBig_fact = math.factorial(hasBig)\n    \n    # Calculate the number of ways to choose cntLess positions from hasLess numbers\n    cntLess = max(pos, n - pos)\n    hasLess = n - cntLess\n    cntLess_fact = math.factorial(cntLess)\n    hasLess_fact = math.factorial(hasLess)\n    \n    # Calculate the total number of valid permutations\n    total_permutations = (cntBig_fact * hasBig_fact) % mod\n    total_permutations *= (cntLess_fact * hasLess_fact) % mod\n    \n    return total_permutations\n\n# Read input\ninput_line = input().strip()\nn, x, pos = map(int, input_line.split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def bin_search_permutations(n, x, pos):\n    MOD = 10**9 + 7\n    # Calculate the number of ways to choose positions for large numbers\n    big_positions = min(pos, n - pos)\n    big_ways = comb(big_positions, big_positions)\n    \n    # Calculate the number of ways to choose positions for small numbers\n    small_positions = max(0, n - pos - big_positions)\n    small_ways = comb(small_positions, small_positions)\n    \n    # Calculate the total number of permutations\n    total_permutations = (big_ways * small_ways) % MOD\n    \n    return total_permutations\n\n# Main function to handle input and output\ndef main():\n    n, x, pos = map(int, input().split())\n    result = bin_search_permutations(n, x, pos)\n    print(result)\n\nif True:\n    main()",
    "def solve(n, x, pos):\n    mod = 10**9 + 7\n    cntBig = 0\n    cntLess = 0\n    hasBig = 0\n    hasLess = 0\n    \n    # Count the number of positions where x should be greater or less than x\n    for i in range(pos):\n        if i == 0:\n            hasBig += 1\n        elif i == pos:\n            hasLess += 1\n        else:\n            if a[i-1] > x:\n                hasBig += 1\n            else:\n                hasLess += 1\n    for i in range(pos+1, n):\n        if i == pos:\n            hasBig += 1\n        elif i == n-1:\n            hasLess += 1\n        else:\n            if a[i+1] < x:\n                hasBig += 1\n            else:\n                hasLess += 1\n    \n    # Calculate the number of ways to place large numbers in cntBig positions\n    for i in range(cntBig + 1):\n        cntBigC = math.comb(hasBig, i)\n        cntBig *= i\n        \n    # Calculate the number of ways to place small numbers in cntLess positions\n    for i in range(cntLess + 1):\n        cntLessC = math.comb(hasLess, i)\n        cntLess *= i\n    \n    # The total number of permutations is the product of the two counts\n    result = (cntBigC * cntLessC) % mod\n    \n    return result\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, x, pos)\n\n# Print the result\nprint(result)",
    "def bin_search_permutations(n, x, pos):\n    MOD = 10**9 + 7\n    # Count the number of positions where x should be greater than or equal to\n    cntGreater = pos + 1\n    # Count the number of positions where x should be less than\n    cntLess = n - pos - 1\n    \n    # Calculate combinations for larger numbers\n    hasGreater = cntGreater * (cntGreater - 1) // 2\n    # Calculate combinations for smaller numbers\n    hasLess = cntLess * (cntLess - 1) // 2\n    \n    # Calculate the total number of valid permutations\n    result = (hasGreater * hasLess) % MOD\n    \n    return result\n\nif True:\n    n, x, pos = map(int, input().split())\n    print(bin_search_permutations(n, x, pos))"
  ],
  "rewards": [
    0.025,
    0.0,
    0.05,
    0.0,
    0.0,
    0.05,
    0.0,
    0.0,
    0.025,
    0.05,
    0.0,
    0.0,
    0.0,
    0.025,
    0.0,
    0.025,
    0.025,
    0.0,
    0.05,
    0.0,
    0.05,
    0.0,
    0.025,
    0.075,
    0.025,
    0.0,
    0.0,
    0.025,
    0.0,
    0.175,
    0.0,
    0.05,
    0.025,
    0.025,
    0.05,
    0.025,
    0.05,
    0.05,
    0.025,
    0.025,
    0.0,
    0.025,
    0.0,
    0.075,
    0.0,
    0.0,
    0.0,
    0.0,
    0.025,
    0.0
  ],
  "train rewards": [
    0.075,
    0.0,
    0.175,
    0.0,
    0.0,
    0.2,
    0.0,
    0.075,
    0.075,
    0.2,
    0.0,
    0.0,
    0.025,
    0.075,
    0.05,
    0.1,
    0.075,
    0.075,
    0.2,
    0.05,
    0.1,
    0.0,
    0.05,
    0.2,
    0.075,
    0.0,
    0.0,
    0.075,
    0.025,
    0.375,
    0.0,
    0.2,
    0.1,
    0.05,
    0.2,
    0.125,
    0.2,
    0.25,
    0.05,
    0.125,
    0.0,
    0.075,
    0.025,
    0.2,
    0.0,
    0.025,
    0.05,
    0.0,
    0.05,
    0.1
  ],
  "time": 410.7564764022827,
  "sample times": 50
}